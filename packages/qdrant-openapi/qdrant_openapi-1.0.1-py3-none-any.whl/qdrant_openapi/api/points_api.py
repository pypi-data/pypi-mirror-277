"""
    Qdrant API

    API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   --data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ --data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ --data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ```   # noqa: E501

    The version of the OpenAPI document: v1.7.x
    Contact: andrey@vasnetsov.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from qdrant_openapi.api_client import ApiClient, Endpoint as _Endpoint
from qdrant_openapi.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from qdrant_openapi.model.count_request import CountRequest
from qdrant_openapi.model.delete_payload import DeletePayload
from qdrant_openapi.model.delete_vectors import DeleteVectors
from qdrant_openapi.model.discover_request import DiscoverRequest
from qdrant_openapi.model.discover_request_batch import DiscoverRequestBatch
from qdrant_openapi.model.error_response import ErrorResponse
from qdrant_openapi.model.extended_point_id import ExtendedPointId
from qdrant_openapi.model.inline_response20011 import InlineResponse20011
from qdrant_openapi.model.inline_response20012 import InlineResponse20012
from qdrant_openapi.model.inline_response20013 import InlineResponse20013
from qdrant_openapi.model.inline_response20014 import InlineResponse20014
from qdrant_openapi.model.inline_response20015 import InlineResponse20015
from qdrant_openapi.model.inline_response20016 import InlineResponse20016
from qdrant_openapi.model.inline_response20017 import InlineResponse20017
from qdrant_openapi.model.inline_response20018 import InlineResponse20018
from qdrant_openapi.model.inline_response2006 import InlineResponse2006
from qdrant_openapi.model.point_insert_operations import PointInsertOperations
from qdrant_openapi.model.point_request import PointRequest
from qdrant_openapi.model.points_selector import PointsSelector
from qdrant_openapi.model.read_consistency import ReadConsistency
from qdrant_openapi.model.recommend_groups_request import RecommendGroupsRequest
from qdrant_openapi.model.recommend_request import RecommendRequest
from qdrant_openapi.model.recommend_request_batch import RecommendRequestBatch
from qdrant_openapi.model.scroll_request import ScrollRequest
from qdrant_openapi.model.search_groups_request import SearchGroupsRequest
from qdrant_openapi.model.search_request import SearchRequest
from qdrant_openapi.model.search_request_batch import SearchRequestBatch
from qdrant_openapi.model.set_payload import SetPayload
from qdrant_openapi.model.update_operations import UpdateOperations
from qdrant_openapi.model.update_vectors import UpdateVectors
from qdrant_openapi.model.write_ordering import WriteOrdering


class PointsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.batch_update_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20013,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/batch',
                'operation_id': 'batch_update',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'update_operations',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'update_operations':
                        (UpdateOperations,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'update_operations': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.clear_payload_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/payload/clear',
                'operation_id': 'clear_payload',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'points_selector',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'points_selector':
                        (PointsSelector,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'points_selector': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.count_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20018,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/count',
                'operation_id': 'count_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'count_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'count_request':
                        (CountRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                },
                'location_map': {
                    'collection_name': 'path',
                    'count_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_payload_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/payload/delete',
                'operation_id': 'delete_payload',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'delete_payload',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'delete_payload':
                        (DeletePayload,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'delete_payload': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/delete',
                'operation_id': 'delete_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'points_selector',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'points_selector':
                        (PointsSelector,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'points_selector': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_vectors_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/vectors/delete',
                'operation_id': 'delete_vectors',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'delete_vectors',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'delete_vectors':
                        (DeleteVectors,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'delete_vectors': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.discover_batch_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20016,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/discover/batch',
                'operation_id': 'discover_batch_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'discover_request_batch',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'discover_request_batch':
                        (DiscoverRequestBatch,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'discover_request_batch': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.discover_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20015,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/discover',
                'operation_id': 'discover_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'discover_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'discover_request':
                        (DiscoverRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'discover_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.get_point_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20011,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/{id}',
                'operation_id': 'get_point',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'id',
                    'consistency',
                ],
                'required': [
                    'collection_name',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'id':
                        (ExtendedPointId,),
                    'consistency':
                        (ReadConsistency,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'id': 'id',
                    'consistency': 'consistency',
                },
                'location_map': {
                    'collection_name': 'path',
                    'id': 'path',
                    'consistency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20012,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points',
                'operation_id': 'get_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'point_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'point_request':
                        (PointRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'point_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.overwrite_payload_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/payload',
                'operation_id': 'overwrite_payload',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'set_payload',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'set_payload':
                        (SetPayload,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'set_payload': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.recommend_batch_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20016,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/recommend/batch',
                'operation_id': 'recommend_batch_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'recommend_request_batch',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'recommend_request_batch':
                        (RecommendRequestBatch,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'recommend_request_batch': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.recommend_point_groups_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20017,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/recommend/groups',
                'operation_id': 'recommend_point_groups',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'recommend_groups_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'recommend_groups_request':
                        (RecommendGroupsRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'recommend_groups_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.recommend_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20015,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/recommend',
                'operation_id': 'recommend_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'recommend_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'recommend_request':
                        (RecommendRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'recommend_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.scroll_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20014,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/scroll',
                'operation_id': 'scroll_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'scroll_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'scroll_request':
                        (ScrollRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'scroll_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.search_batch_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20016,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/search/batch',
                'operation_id': 'search_batch_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'search_request_batch',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'search_request_batch':
                        (SearchRequestBatch,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'search_request_batch': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.search_point_groups_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20017,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/search/groups',
                'operation_id': 'search_point_groups',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'search_groups_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'search_groups_request':
                        (SearchGroupsRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'search_groups_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.search_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse20015,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/search',
                'operation_id': 'search_points',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'consistency',
                    'timeout',
                    'search_request',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'timeout',
                ]
            },
            root_map={
                'validations': {
                    ('timeout',): {

                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'consistency':
                        (ReadConsistency,),
                    'timeout':
                        (int,),
                    'search_request':
                        (SearchRequest,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'consistency': 'consistency',
                    'timeout': 'timeout',
                },
                'location_map': {
                    'collection_name': 'path',
                    'consistency': 'query',
                    'timeout': 'query',
                    'search_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.set_payload_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/payload',
                'operation_id': 'set_payload',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'set_payload',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'set_payload':
                        (SetPayload,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'set_payload': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_vectors_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points/vectors',
                'operation_id': 'update_vectors',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'update_vectors',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'update_vectors':
                        (UpdateVectors,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'update_vectors': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.upsert_points_endpoint = _Endpoint(
            settings={
                'response_type': (InlineResponse2006,),
                'auth': [
                    'api-key',
                    'bearerAuth'
                ],
                'endpoint_path': '/collections/{collection_name}/points',
                'operation_id': 'upsert_points',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'collection_name',
                    'wait',
                    'ordering',
                    'point_insert_operations',
                ],
                'required': [
                    'collection_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'collection_name':
                        (str,),
                    'wait':
                        (bool,),
                    'ordering':
                        (WriteOrdering,),
                    'point_insert_operations':
                        (PointInsertOperations,),
                },
                'attribute_map': {
                    'collection_name': 'collection_name',
                    'wait': 'wait',
                    'ordering': 'ordering',
                },
                'location_map': {
                    'collection_name': 'path',
                    'wait': 'query',
                    'ordering': 'query',
                    'point_insert_operations': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def batch_update(
        self,
        collection_name,
        **kwargs
    ):
        """Batch update points  # noqa: E501

        Apply a series of update operations for points, vectors and payloads  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.batch_update(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to apply operations on

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            update_operations (UpdateOperations): update operations. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20013
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.batch_update_endpoint.call_with_http_info(**kwargs)

    def clear_payload(
        self,
        collection_name,
        **kwargs
    ):
        """Clear payload  # noqa: E501

        Remove all payload for specified points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.clear_payload(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to clear payload from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            points_selector (PointsSelector): clear payload on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.clear_payload_endpoint.call_with_http_info(**kwargs)

    def count_points(
        self,
        collection_name,
        **kwargs
    ):
        """Count points  # noqa: E501

        Count points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.count_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to count in

        Keyword Args:
            count_request (CountRequest): Request counts of points which matches given filtering condition. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20018
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.count_points_endpoint.call_with_http_info(**kwargs)

    def delete_payload(
        self,
        collection_name,
        **kwargs
    ):
        """Delete payload  # noqa: E501

        Delete specified key payload for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_payload(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to delete from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            delete_payload (DeletePayload): delete payload on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.delete_payload_endpoint.call_with_http_info(**kwargs)

    def delete_points(
        self,
        collection_name,
        **kwargs
    ):
        """Delete points  # noqa: E501

        Delete points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to delete from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            points_selector (PointsSelector): Operation to perform on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.delete_points_endpoint.call_with_http_info(**kwargs)

    def delete_vectors(
        self,
        collection_name,
        **kwargs
    ):
        """Delete vectors  # noqa: E501

        Delete named vectors from the given points.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_vectors(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to delete from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            delete_vectors (DeleteVectors): Delete named vectors from points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.delete_vectors_endpoint.call_with_http_info(**kwargs)

    def discover_batch_points(
        self,
        collection_name,
        **kwargs
    ):
        """Discover batch points  # noqa: E501

        Look for points based on target and/or positive and negative example pairs, in batch.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_batch_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            discover_request_batch (DiscoverRequestBatch): Batch request points based on { positive, negative } pairs of examples, and/or a target.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20016
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.discover_batch_points_endpoint.call_with_http_info(**kwargs)

    def discover_points(
        self,
        collection_name,
        **kwargs
    ):
        """Discover points  # noqa: E501

        Use context and a target to find the most similar points to the target, constrained by the context. When using only the context (without a target), a special search - called context search - is performed where pairs of points are used to generate a loss that guides the search towards the zone where most positive examples overlap. This means that the score minimizes the scenario of finding a point closer to a negative than to a positive part of a pair. Since the score of a context relates to loss, the maximum score a point can get is 0.0, and it becomes normal that many points can have a score of 0.0. When using target (with or without context), the score behaves a little different: The  integer part of the score represents the rank with respect to the context, while the decimal part of the score relates to the distance to the target. The context part of the score for  each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair,  and -1 otherwise.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.discover_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            discover_request (DiscoverRequest): Request points based on {positive, negative} pairs of examples, and/or a target. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20015
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.discover_points_endpoint.call_with_http_info(**kwargs)

    def get_point(
        self,
        collection_name,
        id,
        **kwargs
    ):
        """Get point  # noqa: E501

        Retrieve full information of single point by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_point(collection_name, id, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to retrieve from
            id (ExtendedPointId): Id of the point

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20011
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        kwargs['id'] = \
            id
        return self.get_point_endpoint.call_with_http_info(**kwargs)

    def get_points(
        self,
        collection_name,
        **kwargs
    ):
        """Get points  # noqa: E501

        Retrieve multiple points by specified IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to retrieve from

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            point_request (PointRequest): List of points to retrieve. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20012
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.get_points_endpoint.call_with_http_info(**kwargs)

    def overwrite_payload(
        self,
        collection_name,
        **kwargs
    ):
        """Overwrite payload  # noqa: E501

        Replace full payload of points with new one  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.overwrite_payload(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to set from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            set_payload (SetPayload): Payload and points selector. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.overwrite_payload_endpoint.call_with_http_info(**kwargs)

    def recommend_batch_points(
        self,
        collection_name,
        **kwargs
    ):
        """Recommend batch points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_batch_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            recommend_request_batch (RecommendRequestBatch): Request points based on positive and negative examples.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20016
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.recommend_batch_points_endpoint.call_with_http_info(**kwargs)

    def recommend_point_groups(
        self,
        collection_name,
        **kwargs
    ):
        """Recommend point groups  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given payload field.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_point_groups(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            recommend_groups_request (RecommendGroupsRequest): Request points based on positive and negative examples, grouped by a payload field.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20017
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.recommend_point_groups_endpoint.call_with_http_info(**kwargs)

    def recommend_points(
        self,
        collection_name,
        **kwargs
    ):
        """Recommend points  # noqa: E501

        Look for the points which are closer to stored positive examples and at the same time further to negative examples.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.recommend_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            recommend_request (RecommendRequest): Request points based on positive and negative examples.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20015
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.recommend_points_endpoint.call_with_http_info(**kwargs)

    def scroll_points(
        self,
        collection_name,
        **kwargs
    ):
        """Scroll points  # noqa: E501

        Scroll request - paginate over all points which matches given filtering condition  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.scroll_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to retrieve from

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            scroll_request (ScrollRequest): Pagination and filter parameters. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20014
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.scroll_points_endpoint.call_with_http_info(**kwargs)

    def search_batch_points(
        self,
        collection_name,
        **kwargs
    ):
        """Search batch points  # noqa: E501

        Retrieve by batch the closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_batch_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            search_request_batch (SearchRequestBatch): Search batch request. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20016
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.search_batch_points_endpoint.call_with_http_info(**kwargs)

    def search_point_groups(
        self,
        collection_name,
        **kwargs
    ):
        """Search point groups  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given payload field  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_point_groups(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            search_groups_request (SearchGroupsRequest): Search request with optional filtering, grouped by a given payload field. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20017
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.search_point_groups_endpoint.call_with_http_info(**kwargs)

    def search_points(
        self,
        collection_name,
        **kwargs
    ):
        """Search points  # noqa: E501

        Retrieve closest points based on vector similarity and given filtering conditions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to search in

        Keyword Args:
            consistency (ReadConsistency): Define read consistency guarantees for the operation. [optional]
            timeout (int): If set, overrides global timeout for this request. Unit is seconds.. [optional]
            search_request (SearchRequest): Search request with optional filtering. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse20015
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.search_points_endpoint.call_with_http_info(**kwargs)

    def set_payload(
        self,
        collection_name,
        **kwargs
    ):
        """Set payload  # noqa: E501

        Set payload values for points  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_payload(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to set from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            set_payload (SetPayload): Set payload on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.set_payload_endpoint.call_with_http_info(**kwargs)

    def update_vectors(
        self,
        collection_name,
        **kwargs
    ):
        """Update vectors  # noqa: E501

        Update specified named vectors on points, keep unspecified vectors intact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vectors(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to update from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            update_vectors (UpdateVectors): Update named vectors on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.update_vectors_endpoint.call_with_http_info(**kwargs)

    def upsert_points(
        self,
        collection_name,
        **kwargs
    ):
        """Upsert points  # noqa: E501

        Perform insert + updates on points. If point with given ID already exists - it will be overwritten.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upsert_points(collection_name, async_req=True)
        >>> result = thread.get()

        Args:
            collection_name (str): Name of the collection to update from

        Keyword Args:
            wait (bool): If true, wait for changes to actually happen. [optional]
            ordering (WriteOrdering): define ordering guarantees for the operation. [optional]
            point_insert_operations (PointInsertOperations): Operation to perform on points. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InlineResponse2006
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['collection_name'] = \
            collection_name
        return self.upsert_points_endpoint.call_with_http_info(**kwargs)

