# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...core.request_options import RequestOptions
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.bad_request_error_body import BadRequestErrorBody
from ...types.blob_id import BlobId
from ...types.file_create_output import FileCreateOutput
from ...types.file_filter import FileFilter
from ...types.file_input import FileInput
from ...types.file_list import FileList
from ...types.file_resource import FileResource
from ...types.file_sort import FileSort
from ...types.file_update_output import FileUpdateOutput
from ...types.problem_forbidden import ProblemForbidden
from ...types.problem_internal_server_error import ProblemInternalServerError
from ...types.problem_unauthorized import ProblemUnauthorized
from ...types.resource_id import ResourceId
from ...types.revision import Revision
from ...types.upload_response import UploadResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class FilesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def file_create(
        self,
        *,
        blob_id: BlobId,
        request: FileInput,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileCreateOutput:
        """
        Create file's resource.

        Parameters:
            - blob_id: BlobId. Take a look to documentation about #/components/schemas/BlobID.

            - request: FileInput.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import File, FileInput
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_create(
            blob_id="blob_id",
            request=FileInput(
                data=File(),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileCreateOutput, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[FileFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[FileSort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all files matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[FileFilter]]. Filter for the files' resources.

            - sort: typing.Optional[typing.Sequence[FileSort]]. Sort of the files' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_upload(
        self, *, idempotency_key: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> UploadResponse:
        """
        Upload of file's blob.

        Parameters:
            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_upload()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files/upload"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UploadResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Read the latest revision of the file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_latest(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_update(
        self,
        id: ResourceId,
        *,
        blob_id: typing.Optional[BlobId] = None,
        request: FileInput,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileUpdateOutput:
        """
        Update file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - blob_id: typing.Optional[BlobId]. Take a look to documentation about #/components/schemas/BlobID.

            - request: FileInput.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import File, FileInput
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_update(
            id="id",
            if_match="If-Match",
            request=FileInput(
                data=File(),
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpdateOutput, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Restore file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}/restore"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileList:
        """
        History of the files' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_history(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}/revisions"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Read the specific version of the file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_revision(
            id="id",
            revision=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"files/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def file_download(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Download of file's blob.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.files.file_download(
            id="id",
            revision=1,
        )
        """
        with self._client_wrapper.httpx_client.stream(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"files/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}/download",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _chunk in _response.iter_bytes():
                    yield _chunk
                return
            _response.read()
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncFilesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def file_create(
        self,
        *,
        blob_id: BlobId,
        request: FileInput,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileCreateOutput:
        """
        Create file's resource.

        Parameters:
            - blob_id: BlobId. Take a look to documentation about #/components/schemas/BlobID.

            - request: FileInput.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import File, FileInput
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_create(
            blob_id="blob_id",
            request=FileInput(
                data=File(),
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileCreateOutput, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[FileFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[FileSort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all files matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[FileFilter]]. Filter for the files' resources.

            - sort: typing.Optional[typing.Sequence[FileSort]]. Sort of the files' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_upload(
        self, *, idempotency_key: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> UploadResponse:
        """
        Upload of file's blob.

        Parameters:
            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_upload()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "files/upload"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UploadResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Read the latest revision of the file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_latest(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_update(
        self,
        id: ResourceId,
        *,
        blob_id: typing.Optional[BlobId] = None,
        request: FileInput,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileUpdateOutput:
        """
        Update file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - blob_id: typing.Optional[BlobId]. Take a look to documentation about #/components/schemas/BlobID.

            - request: FileInput.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import File, FileInput
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_update(
            id="id",
            if_match="If-Match",
            request=FileInput(
                data=File(),
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileUpdateOutput, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Restore file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}/restore"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileList:
        """
        History of the files' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_history(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"files/{jsonable_encoder(id)}/revisions"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> FileResource:
        """
        Read the specific version of the file's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_revision(
            id="id",
            revision=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"files/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(FileResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def file_download(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Download of file's blob.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.files.file_download(
            id="id",
            revision=1,
        )
        """
        async with self._client_wrapper.httpx_client.stream(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"files/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}/download",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _chunk in _response.aiter_bytes():
                    yield _chunk
                return
            await _response.aread()
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)
