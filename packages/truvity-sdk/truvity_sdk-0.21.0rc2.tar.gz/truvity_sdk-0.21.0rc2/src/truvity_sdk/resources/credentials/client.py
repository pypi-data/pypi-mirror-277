# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...core.request_options import RequestOptions
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...types.annotations import Annotations
from ...types.bad_request_error_body import BadRequestErrorBody
from ...types.blob_id import BlobId
from ...types.credential_filter import CredentialFilter
from ...types.credential_issue import CredentialIssue
from ...types.credential_list import CredentialList
from ...types.credential_resource import CredentialResource
from ...types.credential_sort import CredentialSort
from ...types.labels import Labels
from ...types.problem_forbidden import ProblemForbidden
from ...types.problem_internal_server_error import ProblemInternalServerError
from ...types.problem_unauthorized import ProblemUnauthorized
from ...types.resource_id import ResourceId
from ...types.revision import Revision
from ...types.upload_response import UploadResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CredentialsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def credential_import(
        self,
        *,
        blob_id: BlobId,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Import credential's resource.

        Parameters:
            - blob_id: BlobId. Take a look to documentation about #/components/schemas/BlobID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_import(
            blob_id="blob_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/import"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[CredentialFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[CredentialSort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all credentials matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[CredentialFilter]]. Filter for the credentials' resources.

            - sort: typing.Optional[typing.Sequence[CredentialSort]]. Sort of the credentials' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_upload(
        self, *, idempotency_key: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> UploadResponse:
        """
        Upload of credential's blob.

        Parameters:
            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_upload()
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/upload"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UploadResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Read the latest revision of the credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_latest(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_update(
        self,
        id: ResourceId,
        *,
        blob_id: typing.Optional[BlobId] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Update credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - blob_id: typing.Optional[BlobId]. Take a look to documentation about #/components/schemas/BlobID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_update(
            id="id",
            if_match="If-Match",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_issue(
        self,
        id: ResourceId,
        *,
        data: CredentialIssue,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Issue credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - data: CredentialIssue.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import CredentialIssue, CryptoSuite
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_issue(
            id="id",
            if_match="If-Match",
            data=CredentialIssue(
                key_id="key_id",
                cryptosuite=CryptoSuite.ECDSA_SECP_256_K_1_SIGNATURE_2019,
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/issue"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Restore credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/restore"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialList:
        """
        History of the credentials' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_history(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/revisions"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Read the specific version of the credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_revision(
            id="id",
            revision=1,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"credentials/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def credential_download(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Download of credential's blob.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import TruvityApi

        client = TruvityApi(
            api_key="YOUR_API_KEY",
        )
        client.credentials.credential_download(
            id="id",
            revision=1,
        )
        """
        with self._client_wrapper.httpx_client.stream(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"credentials/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}/download",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _chunk in _response.iter_bytes():
                    yield _chunk
                return
            _response.read()
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCredentialsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def credential_import(
        self,
        *,
        blob_id: BlobId,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Import credential's resource.

        Parameters:
            - blob_id: BlobId. Take a look to documentation about #/components/schemas/BlobID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_import(
            blob_id="blob_id",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/import"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_search(
        self,
        *,
        filter: typing.Optional[typing.Sequence[CredentialFilter]] = OMIT,
        sort: typing.Optional[typing.Sequence[CredentialSort]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialList:
        """
        Take a look at [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body)

        - no resources created: Returns all credentials matching the query passed as request input payload.

        Parameters:
            - filter: typing.Optional[typing.Sequence[CredentialFilter]]. Filter for the credentials' resources.

            - sort: typing.Optional[typing.Sequence[CredentialSort]]. Sort of the credentials' resources.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_search()
        """
        _request: typing.Dict[str, typing.Any] = {}
        if filter is not OMIT:
            _request["filter"] = filter
        if sort is not OMIT:
            _request["sort"] = sort
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/search"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_upload(
        self, *, idempotency_key: typing.Optional[str] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> UploadResponse:
        """
        Upload of credential's blob.

        Parameters:
            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_upload()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "credentials/upload"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UploadResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_latest(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Read the latest revision of the credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_latest(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_update(
        self,
        id: ResourceId,
        *,
        blob_id: typing.Optional[BlobId] = None,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Update credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - blob_id: typing.Optional[BlobId]. Take a look to documentation about #/components/schemas/BlobID.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_update(
            id="id",
            if_match="If-Match",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "blob_id": blob_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_delete(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Delete credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_delete(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_issue(
        self,
        id: ResourceId,
        *,
        data: CredentialIssue,
        annotations: typing.Optional[Annotations] = OMIT,
        labels: typing.Optional[Labels] = OMIT,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Issue credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - data: CredentialIssue.

            - annotations: typing.Optional[Annotations].

            - labels: typing.Optional[Labels].

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk import CredentialIssue, CryptoSuite
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_issue(
            id="id",
            if_match="If-Match",
            data=CredentialIssue(
                key_id="key_id",
                cryptosuite=CryptoSuite.ECDSA_SECP_256_K_1_SIGNATURE_2019,
            ),
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if labels is not OMIT:
            _request["labels"] = labels
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/issue"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_restore(
        self,
        id: ResourceId,
        *,
        idempotency_key: typing.Optional[str] = None,
        if_match: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Restore credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - idempotency_key: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                     The **Idempotency-Key** is a free identifier created by the client to
                                                     identify a request. It is used by the service to identify repeated request
                                                     to ensure idempotent behavior by sending the same (or a similar) response
                                                     without executing the request a second time.

                                                     Clients should be careful as any subsequent requests with the same key may
                                                     return the same response without further check. Thus, it is recommended to
                                                     use a UUID version 4 (random) or any other random string with enough
                                                     entropy to avoid collisions.

                                                     Keys expire after 24 hours. Clients are responsible to stay within this
                                                     limit, if they require idempotent behavior.

                                                     See [API Guideline Rule #181][api-230] for further details.

                                                     [api-230]: <https://opensource.zalando.com/restful-api-guidelines/#230>.
            - if_match: str. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                             The **If-Match** header field is used to declare a list of identifiers that
                             are required to match the current resource version identifier in at least
                             one position as a pre-condition for executing the request on the server
                             side. This behavior is used to validate and reject optimistic updates, by
                             checking if the resource version a consumer has based his changes on is
                             outdated on arrival of the change request to prevent lost updates.

                             If the pre-condition fails the server will respond with status code **412**
                             (Precondition Failed). See [RFC 9110 Section 13.1.1][rfc-9110-13.1.1] as
                             well as [API Guideline Rule #182][api-182] for further details.

                             [rfc-9110-13.1.1]: https://tools.ietf.org/html/rfc9110#section-13.1.1

                             [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_restore(
            id="id",
            if_match="If-Match",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/restore"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "Idempotency-Key": idempotency_key,
                        "If-Match": if_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_history(
        self,
        id: ResourceId,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialList:
        """
        History of the credentials' resources.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_history(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"credentials/{jsonable_encoder(id)}/revisions"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialList, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_revision(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CredentialResource:
        """
        Read the specific version of the credential's resource.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_revision(
            id="id",
            revision=1,
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"credentials/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CredentialResource, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ProblemUnauthorized, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ProblemForbidden, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(
                pydantic.parse_obj_as(ProblemInternalServerError, _response.json())  # type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def credential_download(
        self,
        id: ResourceId,
        revision: Revision,
        *,
        if_none_match: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Download of credential's blob.

        Parameters:
            - id: ResourceId. Take a look to documentation about #/components/schemas/ResourceID.

            - revision: Revision. We could refer to the specific version of the resource.
                                  Take a look to documentation about #/components/schemas/Revision.
            - if_none_match: typing.Optional[str]. From [Zalando RESTful API Guidelines - models/headers-1.0.0.yaml](https://opensource.zalando.com/restful-api-guidelines/models/headers-1.0.0.yaml).
                                                   The **If-None-Match header** field is used to declare a list of identifiers
                                                   that are required to fail matching all the current resource version
                                                   identifiers as a pre-condition for executing the request on the server
                                                   side. This is especially used in conjunction with an **\*** (asterix) that
                                                   is matching all possible resource identifiers to ensure the initial
                                                   creation of a resource. Other use cases are possible but rare.

                                                   If the pre-condition fails the server will respond with status code **412**
                                                   (Precondition Failed). See [RFC 9110 Section 13.1.2][rfc-9110-13.1.2] as
                                                   well as [API Guideline Rule #182][api-182] for further details.

                                                   [rfc-9110-13.1.2]: https://tools.ietf.org/html/rfc9110#section-13.1.2

                                                   [api-182]: <https://opensource.zalando.com/restful-api-guidelines/#182>.
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from truvity_sdk.client import AsyncTruvityApi

        client = AsyncTruvityApi(
            api_key="YOUR_API_KEY",
        )
        await client.credentials.credential_download(
            id="id",
            revision=1,
        )
        """
        async with self._client_wrapper.httpx_client.stream(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"credentials/{jsonable_encoder(id)}/revisions/{jsonable_encoder(revision)}/download",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        "If-None-Match": if_none_match,
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _chunk in _response.aiter_bytes():
                    yield _chunk
                return
            await _response.aread()
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)
