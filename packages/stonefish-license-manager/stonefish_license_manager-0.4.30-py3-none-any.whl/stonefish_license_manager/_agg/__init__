def _yvlGR(f):
    def _uz26W(*args, **kwargs):
        return f(*args, **kwargs)
    _uz26W.__module__ = f.__module__
    _uz26W.__name__ = f.__name__
    _uz26W.__doc__ = f.__doc__
    _uz26W.__dict__.update(f.__dict__)
    f.__refcalls__ = 0
    return _uz26W

@_yvlGR
def _ZbVz8():
    global _OyNwR, _46nNn, _k8vYk, _ka33M, _DNnCn, _eAX2W, _m8JHi, _VQQHQ, _dUuKD, _MxVuE, _HxAZv, _WX2sO, _AFlxz, _LKnop, _09hCd, _1Xvnh, _1xo1X, _X0JV7, _adfSv, _rJwrL, _TRdaq, _ugW4a, _RymVL, _zqnYo, _2jtBr, _3oL23, _9RHmr, _30Xfn, _HAGwK, _MdzKM, _Br3bq, _q7lZz, _TtVVf, _qEtCA, _eaWss, _VuBrH, _m0LZZ, _1XXLn, _idr5P, _uvles, _h7L6l, _42NyU, _Cupmm, _X49Xh, _pS8bQ, _KS2xh, _yl8o3
    from __future__ import annotations
    from cryptography.exceptions import InvalidSignature
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from dataclasses import dataclass
    from datetime import datetime, timedelta, timezone
    from email.utils import parsedate_to_datetime
    from importlib import metadata
    from importlib.util import find_spec
    from pathlib import Path
    from requests import Request
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm, Prompt
    from rich.table import Table
    from rich.text import Text
    from rich_argparse import RichHelpFormatter
    from sys import version_info
    from typing import Any, Literal, Protocol, TYPE_CHECKING
    from urllib.parse import quote, urlsplit
    from wsgiref.handlers import format_date_time
    import argparse, base64, binascii, hashlib, hmac, json, logging, machineid, multiprocessing, os, platform, platformdirs, python_package_info, re, requests, requests_cache, shutil, socket, sys, time, uuid
    _2LXYU = Console(highlight=True)
    _2L2qe = Console(stderr=True, style='yellow', highlight=False)
    _Y3cvX = Console(stderr=True, style='red', highlight=False)

    def _OyNwR(msg='', **_CYzzV):
        _2LXYU.print(msg, **_CYzzV)

    def _d4mD0(msg):
        _2L2qe.print(f'Warning: {msg}')

    def _8HHq0(msg):
        _Y3cvX.print(f'\nError: {msg}')

    class _46nNn(Exception):

        def __init__(self, message, code):
            super().__init__(message)
            self.code = code

        def show(self):
            _8HHq0(f'{self} ({self.code})')

    class _k8vYk(Exception):
        pass

    class _NbVz9(Exception):
        pass
    _gz7U3 = platformdirs.user_data_path('slim')
    _Yb1rt = platformdirs.user_cache_path('slim')

    def _VyfsH(package, fallback='unknown'):
        try:
            return metadata.version(package)
        except metadata.PackageNotFoundError:
            return fallback

    def _bwg8W():
        return f'{version_info.major}.{version_info.minor}.{version_info.micro}'

    def _ka33M(dct, *_Yk7xS, default=None):
        for _MnNex in _Yk7xS:
            try:
                dct = dct[_MnNex]
            except (KeyError, TypeError, IndexError):
                return default
        return dct

    def _xy8Ze(obj, eps=timedelta(minutes=5)):
        if abs(obj - datetime.now(tz=timezone.utc)) > eps:
            _4t6lz = 'Error code E044'
            raise RuntimeError(_4t6lz)

    def _vas4G(obj, eps=timedelta(minutes=5)):
        if obj > datetime.now(tz=timezone.utc) + eps:
            _EH5xy = 'Error code E045'
            raise RuntimeError(_EH5xy)

    def _6iz6J(ts, **_A38yY):
        _vas4G(datetime.fromtimestamp(ts, tz=timezone.utc), **_A38yY)

    def _DNnCn(res):
        _h7O6L = parsedate_to_datetime(res.headers['Date'])
        if getattr(res, 'from_cache', False):
            _vas4G(_h7O6L)
        else:
            _xy8Ze(_h7O6L)

    def _k66BF(td):
        _3b01K = abs(td)
        if _3b01K < timedelta(seconds=1):
            return 'just now'
        _IyHSH = td > timedelta(0)
        for _p6uJX, _wYsAI, _qo0zH in [('second', _3b01K.seconds, timedelta(minutes=1)), ('minute', round(_3b01K.seconds / 60), timedelta(hours=1)), ('hour', round(_3b01K.seconds / 3600), timedelta(days=1))]:
            if _3b01K < _qo0zH:
                _BV1xb = '' if _wYsAI == 1 else 's'
                return f'in {_wYsAI} {_p6uJX}{_BV1xb}' if _IyHSH else f'{_wYsAI} {_p6uJX}{_BV1xb} ago'
        if _3b01K.days < 100:
            _wYsAI = _3b01K.days
            if _wYsAI == 0:
                return 'today'
            if _IyHSH:
                if _wYsAI == 1:
                    return 'tomorrow'
                return f'in {_wYsAI} days'
            if _wYsAI == 1:
                return 'yesterday'
            return f'{_wYsAI} days ago'
        if _3b01K.days < 365:
            _wYsAI = round(_3b01K.days / 30)
            _BV1xb = '' if _wYsAI == 1 else 's'
            if _IyHSH:
                return f'in {_wYsAI} month{_BV1xb}'
            return f'{_wYsAI} month{_BV1xb} ago'
        _wYsAI = round(_3b01K.days / 365)
        _BV1xb = '' if _wYsAI == 1 else 's'
        if _IyHSH:
            return f'in {_wYsAI} year{_BV1xb}'
        return f'{_wYsAI} year{_BV1xb} ago'

    def _wE5nc(var_names):
        assert isinstance(var_names, (list, tuple))
        for _l0I3f in var_names:
            assert isinstance(_l0I3f, str)
            assert _l0I3f != ''
        for _nA44U, _6wGOC in [('global', globals()), ('environment', os.environ)]:
            for _luIQx in var_names:
                if _luIQx in _6wGOC:
                    yield (_nA44U, _luIQx, _6wGOC[_luIQx])

    def _44asd(string, k):
        return '\n'.join((string[_9HfoK:_9HfoK + k] for _9HfoK in range(0, len(string), k)))

    def _eAX2W(string):
        if sys.version_info >= (3, 11):
            return datetime.fromisoformat(string)
        try:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S.%f%z')
        except ValueError:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S%z')

    def _pY1ZL(string, prefix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix)
        if string.startswith(prefix):
            return string[len(prefix):]
        return string

    def _1rHYr(*_tv7E6):
        for _2XYVP in _tv7E6:
            yield from _2XYVP

    def _VZVT3(function):

        def _5Ramh(*_f9fbp, **_aysL7):
            _f9fbp = [tuple(_GL8ob) if isinstance(_GL8ob, list) else _GL8ob for _GL8ob in _f9fbp]
            _aysL7 = {key: tuple(value) if isinstance(value, list) else value for key, value in _aysL7.items()}
            return function(*_f9fbp, **_aysL7)
        _5Ramh.cache_clear = function.cache_clear
        return _5Ramh

    def _YNQ5D(gen):
        cache = set()

        def _ZkhaU(*_RVVHL, **_hSvRP):
            for _SDLKS in gen(*_RVVHL, **_hSvRP):
                if _SDLKS in cache:
                    continue
                yield _SDLKS
                cache.add(_SDLKS)
        return _ZkhaU

    def _6CW9x(key):
        if key.startswith('DEMO'):
            return '1fddcec8-8dd3-4d8d-9b16-215cac0f9b52'
        return '109c23d2-6cdd-4faf-bd8a-96c242733638'
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @cache
    def _m8JHi():
        if _B4BLn():
            return 'google.colab'
        _SpnbS = _zkwwE()
        if _SpnbS:
            return f'github-actions/{_SpnbS}'
        _fHC87 = _QCxgm()
        if _fHC87:
            return f'travis-ci/{_fHC87}'
        _J8yq2 = _xT1rS()
        if _J8yq2:
            return f'circle-ci/{_J8yq2}'
        _7Y3ZD = _jGomw()
        if _7Y3ZD:
            return 'gitlab-ci/{gitlab_project_namespace}'
        if _dXOLK():
            return 'jenkins'
        if _z85zk():
            return 'docker'
        return machineid.id().strip()

    def _z85zk():
        _lqwVC = Path('/proc/self/cgroup')
        return Path('/.dockerenv').is_file() or (_lqwVC.is_file() and 'docker' in _lqwVC.read_text())

    def _B4BLn():
        try:
            _OedFK = find_spec('google.colab')
        except ModuleNotFoundError:
            return False
        return _OedFK is not None

    def _zkwwE():
        if _yCzpZ([('CI', 'true'), ('GITHUB_ACTIONS', 'true'), 'GITHUB_ACTION', 'GITHUB_ACTION_REPOSITORY', 'GITHUB_ACTOR', 'GITHUB_ACTOR_ID', 'GITHUB_API_URL', 'GITHUB_BASE_REF', 'GITHUB_ENV', 'GITHUB_EVENT_NAME', 'GITHUB_EVENT_PATH', 'GITHUB_GRAPHQL_URL', 'GITHUB_HEAD_REF', 'GITHUB_JOB', 'GITHUB_PATH', 'GITHUB_REF', 'GITHUB_REF_NAME', 'GITHUB_REF_PROTECTED', 'GITHUB_REF_TYPE', 'GITHUB_REPOSITORY', 'GITHUB_REPOSITORY_ID', 'GITHUB_REPOSITORY_OWNER', 'GITHUB_REPOSITORY_OWNER_ID', 'GITHUB_RETENTION_DAYS', 'GITHUB_RUN_ATTEMPT', 'GITHUB_RUN_ID', 'GITHUB_RUN_NUMBER', 'GITHUB_SERVER_URL', 'GITHUB_SHA', 'GITHUB_STEP_SUMMARY', 'GITHUB_WORKFLOW', 'GITHUB_WORKFLOW_REF', 'GITHUB_WORKFLOW_SHA', 'GITHUB_WORKSPACE', 'RUNNER_ARCH', 'RUNNER_NAME', 'RUNNER_OS', 'RUNNER_TEMP', 'RUNNER_TOOL_CACHE']):
            return os.environ['GITHUB_REPOSITORY_OWNER']
        return None

    def _QCxgm():
        if _yCzpZ([('CI', 'true'), ('TRAVIS', 'true'), ('CONTINUOUS_INTEGRATION', 'true'), ('HAS_JOSH_K_SEAL_OF_APPROVAL', 'true'), ('USER', 'travis'), ('RAILS_ENV', 'test'), ('RACK_ENV', 'test'), ('MERB_ENV', 'test'), 'TRAVIS_ALLOW_FAILURE', 'TRAVIS_APP_HOST', 'TRAVIS_BRANCH', 'TRAVIS_BUILD_DIR', 'TRAVIS_BUILD_ID', 'TRAVIS_BUILD_NUMBER', 'TRAVIS_BUILD_WEB_URL', 'TRAVIS_COMMIT', 'TRAVIS_COMMIT_MESSAGE', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_COMPILER', 'TRAVIS_DEBUG_MODE', 'TRAVIS_DIST', 'TRAVIS_REPO_SLUG']):
            _nFjqQ, _EOcwH = os.environ['TRAVIS_REPO_SLUG'].split('/')
            return _nFjqQ
        return None

    def _xT1rS():
        if _yCzpZ([('CI', 'true'), ('CIRCLE', 'true'), 'CIRCLE_BRANCH', 'CIRCLE_BUILD_NUM', 'CIRCLE_BUILD_URL', 'CIRCLE_JOB', 'CIRCLE_NODE_INDEX', 'CIRCLE_NODE_TOTAL', 'CIRCLE_OIDC_TOKEN', 'CIRCLE_OIDC_TOKEN_V2', 'CIRCLE_PR_NUMBER', 'CIRCLE_PR_REPONAME', 'CIRCLE_PR_USERNAME', 'CIRCLE_PROJECT_REPONAME', 'CIRCLE_PROJECT_USERNAME', 'CIRCLE_PULL_REQUEST', 'CIRCLE_PULL_REQUESTS', 'CIRCLE_REPOSITORY_URL', 'CIRCLE_SHA1', 'CIRCLE_TAG', 'CIRCLE_WORKFLOW_ID', 'CIRCLE_WORKFLOW_JOB_ID', 'CIRCLE_WORKFLOW_WORKSPACE_ID', 'CIRCLE_WORKING_DIRECTORY', 'CIRCLE_INTERNAL_TASK_DATA']):
            return os.environ['CIRCLE_PROJECT_USERNAME']
        return None

    def _jGomw():
        if _yCzpZ(['CHAT_CHANNEL', 'CHAT_INPUT', 'CHAT_USER_ID', 'CI', 'CI_API_V4_URL', 'CI_API_GRAPHQL_URL', 'CI_BUILDS_DIR', 'CI_COMMIT_AUTHOR', 'CI_COMMIT_BEFORE_SHA', 'CI_COMMIT_BRANCH', 'CI_COMMIT_DESCRIPTION', 'CI_COMMIT_MESSAGE', 'CI_COMMIT_REF_NAME', 'CI_COMMIT_REF_PROTECTED', 'CI_COMMIT_REF_SLUG', 'CI_COMMIT_SHA', 'CI_COMMIT_SHORT_SHA', 'CI_COMMIT_TIMESTAMP', 'CI_COMMIT_TITLE', 'CI_CONCURRENT_ID', 'CI_CONCURRENT_PROJECT_ID', 'CI_CONFIG_PATH', 'CI_DEBUG_TRACE', 'CI_DEBUG_SERVICES', 'CI_DEFAULT_BRANCH', 'CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_PASSWORD', 'CI_DEPENDENCY_PROXY_SERVER', 'CI_DEPENDENCY_PROXY_USER', 'CI_DEPLOY_FREEZE', ('GITLAB_CI', 'true'), 'GITLAB_FEATURES', 'GITLAB_USER_EMAIL', 'GITLAB_USER_ID', 'GITLAB_USER_LOGIN', 'GITLAB_USER_NAME']):
            return os.environ['CI_PROJECT_NAMESPACE']
        return None

    def _dXOLK():
        return _yCzpZ(['BUILD_NUMBER', 'BUILD_ID', 'BUILD_DISPLAY_NAME', 'JOB_NAME', 'BUILD_TAG', 'EXECUTOR_NUMBER', 'NODE_NAME', 'NODE_LABELS', 'WORKSPACE', 'JENKINS_HOME', 'JENKINS_URL', 'BUILD_URL', 'JOB_URL'])

    def _yCzpZ(keys):
        for _FM6c6 in keys:
            if isinstance(_FM6c6, str):
                if _FM6c6 not in os.environ:
                    return False
            else:
                assert isinstance(_FM6c6, tuple)
                _genA6, _gUbFf = _FM6c6
                if _ka33M(os.environ, _genA6) != _gUbFf:
                    return False
        return True

    def _VQQHQ():
        _owaFX = requests.get('https://ipinfo.io/json', timeout=10)
        _owaFX.raise_for_status()
        return _owaFX.json()

    class _dUuKD(Protocol):
        key_type: str

        @property
        def data(self):
            ...

        @property
        def key(self):
            ...

        @property
        def product_name(self):
            ...

        @property
        def product_id(self):
            ...

        @property
        def vendor_name(self):
            ...

        @property
        def license_id(self):
            ...

        @property
        def user(self):
            ...

        @property
        def created(self):
            ...

        @property
        def expiry(self):
            ...

        @property
        def max_machines(self):
            ...

        @property
        def num_machines(self):
            ...

        @property
        def usage_type(self):
            return None

        @property
        def activations(self):
            return (None, None)

        def list_machines(self):
            ...

        def prettyprint(self, show_key=False):
            ...

        def _prettyprint(self, is_valid, validation_code=None, show_key=False):
            _Gwi4n = Table(box=None, padding=(0, 4, 0, 0), show_header=False)
            if self.product_name:
                _Gwi4n.add_row('Product', Text(self.product_name, style='cyan'))
            else:
                _Gwi4n.add_row('Product ID', str(self.product_id))
            if self.vendor_name:
                _Gwi4n.add_row('Vendor', self.vendor_name)
            if self.license_id:
                _Gwi4n.add_row('License ID', str(self.license_id))
            if show_key and self.key:
                _Gwi4n.add_row('Key', self.key)
            if self.usage_type:
                _Gwi4n.add_row('Usage type', Text(self.usage_type.title(), style='blue'))
            _zD4BP = None
            if is_valid is True:
                _Gwi4n.add_row('Valid', Text('True', style='green'))
                _zD4BP = 'green'
            elif is_valid is False:
                _b4TjD = 'False'
                if validation_code:
                    _b4TjD += f' ({validation_code})'
                _Gwi4n.add_row('Valid', Text(_b4TjD, style='red'))
                _zD4BP = 'red'
            else:
                assert is_valid == 'unknown'
                _b4TjD = 'Unknown'
                if validation_code:
                    _b4TjD += f' ({validation_code})'
                _Gwi4n.add_row('Valid', Text(_b4TjD, style='yellow'))
                _zD4BP = 'bright_black'
            if (email := _ka33M(self.user, 'email')):
                _Gwi4n.add_row('User', email)
            if self.created:
                _Gwi4n.add_row('Created', self.created.strftime('%Y-%m-%d'))
            _rWtSE = datetime.now(tz=timezone.utc)
            if self.expiry:
                _BFrhh = self.expiry - _rWtSE
                if _BFrhh < timedelta(0):
                    _XP9Sv = 'red'
                    _zD4BP = 'red'
                elif _BFrhh.days < 30:
                    _XP9Sv = 'yellow'
                    if _zD4BP != 'red':
                        _zD4BP = 'yellow'
                else:
                    _XP9Sv = None
                _Gwi4n.add_row('Expiry', Text(f"{self.expiry.strftime('%Y-%m-%d')} ({_k66BF(_BFrhh)})", style=_XP9Sv))
            _e89tC, _MjCLT = self.activations
            if _e89tC is not None:
                _3KMc1 = None
                _b4TjD = str(_e89tC)
                if _MjCLT is not None:
                    if _e89tC >= _MjCLT:
                        _3KMc1 = 'yellow'
                    _b4TjD += f'/{_MjCLT}'
                _Gwi4n.add_row('Activations', Text(_b4TjD, style=_3KMc1))
            if self.num_machines is not None:
                _b4TjD = str(self.num_machines)
                if self.max_machines is not None:
                    _b4TjD += f'/{self.max_machines}'
                _Gwi4n.add_row('Seats used', _b4TjD)
            for _aZChE, _aOjqk in enumerate(self.list_machines()):
                assert isinstance(_aOjqk, dict)
                _PDE0J = _ka33M(_aOjqk, 'hostname') or f'machine {_aZChE}'
                _eLCk2 = []
                _cOqc3 = False
                if (fp := _ka33M(_aOjqk, 'fingerprint')):
                    _eLCk2.append(fp)
                    _cOqc3 = fp == _m8JHi()
                _mhHpN = _PDE0J
                if _cOqc3:
                    _mhHpN = f'[bold]{_mhHpN}[/]'
                if _eLCk2:
                    _mhHpN += f" ({', '.join(_eLCk2)})"
                _Gwi4n.add_row('Machines' if _aZChE == 0 else '', _mhHpN)
            _MHvVV = Panel(_Gwi4n, title_align='left', border_style=_zD4BP)
            _OyNwR(_MHvVV)

    def _MxVuE(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _2kQnB(serialization.load_pem_public_key(key_bytes))

    def _HxAZv(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _2kQnB(serialization.load_der_public_key(key_bytes))

    def _76CJP(key_bytes):
        _VkDf9 = _HxAZv(key_bytes)
        assert isinstance(_VkDf9, _AFlxz)
        return _VkDf9

    def _2kQnB(key):
        if isinstance(key, Ed25519PublicKey):
            return _WX2sO(key)
        if isinstance(key, RSAPublicKey):
            return _AFlxz(key)
        _ANIw9 = 'Unknown key'
        raise ValueError(_ANIw9)

    class _Y03ee:
        pass

    class _WX2sO(_Y03ee):
        alg = 'ed25519'

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(Ed25519PublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, Ed25519PublicKey)
            self.key = key

        def verify(self, sig_bytes, msg_bytes):
            try:
                self.key.verify(sig_bytes, msg_bytes)
            except InvalidSignature:
                _dmUiZ = 'SLiM: Ed25519 signature verification error. (Wrong key?)'
                raise _k8vYk(_dmUiZ) from None

        def verify_response(self, res):
            try:
                _ACvLl = res.created_at.replace(tzinfo=timezone.utc)
            except AttributeError:
                _ACvLl = datetime.now(tz=timezone.utc)
            if _ACvLl < datetime(2024, 2, 7, 0, 0, tzinfo=timezone.utc):
                return
            alg, _1I9Bx, _gEcpE = _9oF2s(res)
            if alg.lower() != self.alg:
                _1I9Bx = f'Expected alg {self.alg}, got {alg}'
                raise ValueError(_1I9Bx)
            self.verify(_gEcpE, _1I9Bx)

    class _AFlxz(_Y03ee):

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(RSAPublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, RSAPublicKey)
            self.key = key
            self.pad_pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH)
            self.pad_pkcs1v15 = padding.PKCS1v15()

        def verify(self, sig_bytes, msg_bytes, padding):
            if padding.lower() == 'pss':
                _s7alC = self.pad_pss
            elif padding.lower() == 'pkcs1v15':
                _s7alC = self.pad_pkcs1v15
            else:
                _neNvQ = f'Unknown padding {padding}'
                raise ValueError(_neNvQ)
            try:
                self.key.verify(sig_bytes, msg_bytes, _s7alC, hashes.SHA256())
            except InvalidSignature:
                _neNvQ = 'SLiM: RSA signature verification error. (Wrong key?)'
                raise _k8vYk(_neNvQ) from None

        def verify_response(self, *_vrjEI, **_4VdrC):
            _kePte, _UxHZl, _KyRDP = _9oF2s(*_vrjEI, **_4VdrC)
            if _kePte.lower() == 'rsa-pss-sha256':
                self.verify(_KyRDP, _UxHZl, padding='pss')
                return
            if _kePte.lower() == 'rsa-sha256':
                self.verify(_KyRDP, _UxHZl, padding='pkcs1v15')
                return
            _UxHZl = f'Unknown RSA alg {_kePte}'
            raise ValueError(_UxHZl)

    def _9oF2s(res):
        _1zFAJ = hashlib.sha256(res.content).digest()
        _EMbjZ = base64.b64encode(_1zFAJ).decode()
        if f'sha-256={_EMbjZ}' != res.headers['Digest']:
            _V9LQ8 = 'SLiM: Invalid response digest'
            raise RuntimeError(_V9LQ8)
        _LFhj6 = urlsplit(res.request.url)
        _cK0ei = '\n'.join([f'(request-target): {res.request.method.lower()} {res.request.path_url}', f'host: {_LFhj6.netloc}', f"date: {res.headers['Date']}", f'digest: sha-256={_EMbjZ}']).encode()
        _T8lDg = _4dCWK(res.headers['Keygen-Signature'])
        return (_T8lDg['algorithm'], _cK0ei, base64.b64decode(_T8lDg['signature']))

    def _4dCWK(string):
        _3ciWX = {}
        for _EadrJ in re.split(',\\s*', string):
            _pBsHQ = re.match('([^=]+)="([^"]+)"', _EadrJ)
            assert _pBsHQ
            _3ciWX[_pBsHQ.group(1)] = _pBsHQ.group(2)
        return _3ciWX

    @dataclass
    class _LKnop:
        name: str
        email: str | None
        account_id: str
        verify_key: Ed25519
    _6nzDs = _LKnop(name='Monday Tech', email='support@mondaytech.com', account_id='109c23d2-6cdd-4faf-bd8a-96c242733638', verify_key=_WX2sO.from_hex('cee3f0572684018bd7e4c77ed82c91b6631ebd110ed8cdcf8ecfc8e2d4cf41e1'))
    _kl6Sp = _LKnop(name='Keygen demo', email=None, account_id='1fddcec8-8dd3-4d8d-9b16-215cac0f9b52', verify_key=_WX2sO.from_hex('e8601e48b69383ba520245fd07971e983d06d22c4257cfd82304601479cee788'))
    _XTGpL = {vendor.account_id: vendor for vendor in [_6nzDs, _kl6Sp]}

    def _09hCd(account_id):
        try:
            return _XTGpL[account_id]
        except KeyError:
            _TuV1m = f"Cannot use SLiM with Keygen account_id {account_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _46nNn(_TuV1m, 'KG_VENDOR_ERROR') from None
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _VnnPH = '1.3'
    _U9XS1 = requests_cache.CachedSession(cache_name=_Yb1rt / 'keygen', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4), allowable_methods=['GET', 'HEAD', 'POST'])

    class _1Xvnh(_dUuKD):
        key_type = 'Keygen online'

        @classmethod
        def from_key(cls, account_id, key):
            assert account_id
            assert isinstance(key, str)
            assert not key.startswith('key/')
            return cls({'attributes': {'key': key}, 'relationships': {'account': {'data': {'id': account_id}}}})

        def __init__(self, data):
            assert isinstance(data, dict)
            assert 'data' not in data
            self._data = data
            _NN1aF = data['relationships']['account']['data']['id']
            self.base_url = f'https://api.keygen.sh/v1/accounts/{_NN1aF}'
            self.vendor = _09hCd(_NN1aF)
            self.verify_response = self.vendor.verify_key.verify_response
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['attributes']['key']

        @property
        def auth(self):
            return f'License {self.key}'

        @property
        def license_id(self):
            return _ka33M(self.data, 'id')

        @property
        def license_key(self):
            return self.data['attributes']['key']

        @property
        def account_id(self):
            return _ka33M(self.data, 'relationships', 'account', 'data', 'id')

        @property
        def product_id(self):
            return _ka33M(self.data, 'relationships', 'product', 'data', 'id')

        @property
        def product_name(self):
            return _ka33M(self.data, 'attributes', 'metadata', 'productName')

        @property
        def usage_type(self):
            return _ka33M(self.data, 'attributes', 'metadata', 'usageType')

        @property
        def activations(self):
            _mtGVj = _ka33M(self.data, 'attributes', 'metadata', 'tokenId')
            if not _mtGVj:
                return (None, None)
            _7fkiu = _U9XS1.get(f'{self.base_url}/tokens/{_mtGVj}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _VnnPH}, timeout=10)
            _7fkiu.raise_for_status()
            data = _7fkiu.json()
            _ldWEt = data['data']['attributes']
            return (_ldWEt['activations'], _ldWEt['maxActivations'])

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            if (created := _ka33M(self.data, 'attributes', 'created')):
                return _eAX2W(created)
            return None

        @property
        def expiry(self):
            if (expiry := _ka33M(self.data, 'attributes', 'expiry')):
                return _eAX2W(expiry)
            return None

        @property
        def num_machines(self):
            return _ka33M(self.data, 'relationships', 'machines', 'meta', 'count')

        @property
        def max_machines(self):
            return _ka33M(self.data, 'attributes', 'maxMachines')

        def list_machines(self):
            try:
                _qDmUJ = self.get_machines()
            except requests.exceptions.ReadTimeout:
                return []
            _I5qdo = []
            for _8qH7d in _qDmUJ:
                _SIN2f = _ka33M(_8qH7d, 'attributes', 'fingerprint')
                _TVr7h = {'hostname': _ka33M(_8qH7d, 'attributes', 'hostname'), 'requireHeartbeat': _ka33M(_8qH7d, 'attributes', 'requireHeartbeat'), 'heartbeatStatus': _ka33M(_8qH7d, 'attributes', 'heartbeatStatus'), 'fingerprint': _SIN2f}
                if (lhb := _ka33M(_8qH7d, 'attributes', 'lastHeartbeat')):
                    _TVr7h['lastHeartbeat'] = _eAX2W(lhb)
                if (created := _ka33M(_8qH7d, 'attributes', 'created')):
                    _TVr7h['created'] = _eAX2W(created)
                _I5qdo.append(_TVr7h)
            return _I5qdo

        @property
        def user(self):
            metadata = self.data['attributes']['metadata']
            _9WRsF = _ka33M(metadata, 'email') or _ka33M(metadata, 'user')
            if _9WRsF and _9WRsF not in {'sigma@mondaytech.com', 'meshpro@mondaytech.com', 'texworld@mondaytech.com'}:
                return {'email': _9WRsF}
            return {}

        def validate(self, activate_if_required=False, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None, require_product_id=None):
            if _ka33M(self.data, 'attributes', 'metadata', 'requireFingerprintScope') is True:
                return self._validate_fingerprinted(activate_if_required, require_product_id=require_product_id, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            _AnCFM = self._validate_cached(with_fingerprint=False, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _FcrP4 = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _46nNn(_FcrP4, 'KG_WRONG_PRODUCT_ID')
            if _ka33M(_AnCFM, 'valid'):
                return _AnCFM
            _tyJmk = _ka33M(_AnCFM, 'code')
            if _tyJmk == 'FINGERPRINT_SCOPE_REQUIRED':
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if raise_on_error:
                _FcrP4 = f'License {self.license_id}: Key validation failed'
                raise _46nNn(_FcrP4, _tyJmk)
            return _AnCFM

        def _validate_fingerprinted(self, activate_if_required, require_product_id=None, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _hvkJr = self._validate_cached(with_fingerprint=True, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _BBZ59 = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _46nNn(_BBZ59, 'KG_WRONG_PRODUCT_ID')
            if _ka33M(_hvkJr, 'valid'):
                return _hvkJr
            _u2iM0 = _ka33M(_hvkJr, 'code')
            if _u2iM0 == 'HEARTBEAT_NOT_STARTED':
                self._ping_heartbeat_cached(raise_on_error=True, cache_force_refresh=True)
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error)
            if activate_if_required and _u2iM0 in {'NO_MACHINE', 'NO_MACHINES', 'FINGERPRINT_SCOPE_MISMATCH', 'HEARTBEAT_DEAD'}:
                self.activate(raise_on_error=True)
                return self._validate_fingerprinted(activate_if_required, cache_force_refresh=True, cache_expire_after=cache_expire_after, raise_on_error=raise_on_error)
            if raise_on_error:
                _pqZWe = []
                _nzWGQ = _ka33M(_hvkJr, 'detail')
                _kOq5G = _ka33M(_hvkJr, 'code')
                if _u2iM0 and _nzWGQ:
                    _pqZWe.append(f'Validation error {_u2iM0}: {_nzWGQ}')
                if _u2iM0 == 'NOT_FOUND':
                    _pqZWe.append('Did you provide the license ID instead of the key?')
                raise _46nNn('\n'.join(_pqZWe), f'KG_{_kOq5G}')
            return _hvkJr

        def _validate_cached(self, with_fingerprint, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _AOV2z: dict[str, Any] = {'key': self.key}
            if with_fingerprint:
                _AOV2z['scope'] = {'fingerprint': _m8JHi()}
            _jOzAM = _U9XS1.post(f'{self.base_url}/licenses/actions/validate-key', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _VnnPH}, json={'meta': _AOV2z}, timeout=10, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            try:
                self.verify_response(_jOzAM)
            except _k8vYk:
                _U9XS1.cache.delete(requests=[_jOzAM.request])
                raise
            _DNnCn(_jOzAM)
            json = _jOzAM.json()
            if not _jOzAM.ok:
                _EXT5Q = _ka33M(json, 'errors', 0)
                _m08AC = f'Validation failed for license {self.license_id}: '
                if _EXT5Q:
                    if _EXT5Q.get('title') == 'Daily API request limit reached':
                        _bxRsU = 'KG_RATE_LIMIT'
                        _m08AC += 'Daily API rate limit has been reached. Limit will be reset at midnight UTC.'
                    else:
                        _bxRsU = _ka33M(_EXT5Q, 'code')
                        _m08AC += _ka33M(_EXT5Q, 'detail')
                else:
                    _bxRsU = 'KG_VALIDATION_FAILED'
                    _m08AC += 'unknown'
                raise _46nNn(_m08AC, _bxRsU)
            data = json['data']
            _AOV2z = json['meta']
            if not _ka33M(_AOV2z, 'valid') and raise_on_error:
                _tJfcj = _ka33M(_AOV2z, 'code')
                _2qQ42 = _ka33M(_AOV2z, 'detail')
                _CTZZp = []
                if _tJfcj and _2qQ42:
                    _CTZZp.append(f'Validation error {_tJfcj}: {_2qQ42}')
                if _tJfcj == 'NOT_FOUND':
                    _CTZZp.append('Did you provide the license ID instead of the key?')
                raise _46nNn('\n'.join(_CTZZp), _tJfcj)
            if _ka33M(_AOV2z, 'valid') and _ka33M(data, 'attributes', 'requireHeartbeat'):
                self._ping_heartbeat_cached(raise_on_error=True)
            if data:
                self._data = data
            return _AOV2z

        def activate(self, raise_on_error=True):
            _OyNwR('Activating machine for license...', highlight=False, end='', style='green')
            _zzuzg = _ka33M(self.data, 'attributes', 'metadata', 'token')
            _VqrUZ = _ka33M(self.data, 'attributes', 'metadata', 'tokenId')
            _buHxB = _zzuzg and _VqrUZ
            auth = f'Bearer {_zzuzg}' if _buHxB else f'License {self.key}'
            _vcRTj = _VQQHQ()
            _Mross = requests.post(f'{self.base_url}/machines', headers={'Authorization': auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _VnnPH}, json={'data': {'type': 'machines', 'attributes': {'ip': _vcRTj.get('ip'), 'cores': multiprocessing.cpu_count(), 'fingerprint': _m8JHi(), 'platform': platform.platform(), 'hostname': socket.gethostname(), 'metadata': {'country': _vcRTj.get('country'), 'python-version': _bwg8W(), 'slim-version': _VyfsH('stonefish-license-manager')}}, 'relationships': {'license': {'data': {'type': 'licenses', 'id': self.license_id}}}}}, timeout=10)
            self.verify_response(_Mross)
            _DNnCn(_Mross)
            _53GiK = _Mross.json()
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _buHxB:
                self._clear_tokens_cache(_VqrUZ)
            if raise_on_error and 'errors' in _53GiK:
                _OyNwR(_53GiK)
                _SbrAI = f'Activation errors with license {self.license_id}:\n' + '\n'.join((f"    {_A5kmd['title']}: {_A5kmd['detail']}" for _A5kmd in _53GiK['errors']))
                raise _46nNn(_SbrAI, 'KG_ACTIVATION_ERROR')
            _OyNwR('done.', style='green')

        def deactivate(self, fingerprints=None):
            _OyNwR('Deactivating machine for license...', highlight=False, end='', style='green')
            _fMzZ8 = _ka33M(self.data, 'attributes', 'metadata', 'token')
            _Lbsx5 = _ka33M(self.data, 'attributes', 'metadata', 'tokenId')
            _yUgaO = _fMzZ8 and _Lbsx5
            auth = f'Bearer {_fMzZ8}' if _yUgaO else f'License {self.key}'
            if not fingerprints:
                fingerprints = {_m8JHi()}
            for _xE7Dm in fingerprints:
                _BVLkZ = self._get_machine_by_fingerprint_cached(_xE7Dm, cache_force_refresh=True)
                _8oIQJ = _ka33M(_BVLkZ, 'data', 0, 'id')
                if not _8oIQJ:
                    _NFgvC = f"Couldn't get machine ID for machine {_xE7Dm}. Not activated?"
                    raise _46nNn(_NFgvC, 'KG_MACHINE_NOT_FOUND')
                _HxxYs = requests.delete(f'{self.base_url}/machines/{_8oIQJ}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': _VnnPH}, timeout=10)
                if not _HxxYs.ok:
                    _RfF6V = _ka33M(_HxxYs.json(), 'errors', 0)
                    if _RfF6V:
                        _cj4oN = _ka33M(_RfF6V, 'code')
                        _NFgvC = f"Machined deactivation failed: {_RfF6V['detail']}"
                    elif _HxxYs.status_code == 404:
                        _cj4oN = 'KG_MACHINE_NOT_FOUND'
                        _NFgvC = 'Machine deactivation failed (not found)'
                    else:
                        _cj4oN = 'KG_DEACTIVATION_FAILED'
                        _NFgvC = 'Unsuccessful deactivation request'
                    raise _46nNn(_NFgvC, _cj4oN)
                self.verify_response(_HxxYs)
                _DNnCn(_HxxYs)
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _yUgaO:
                self._clear_tokens_cache(_Lbsx5)
            _OyNwR('done.', style='green')

        def _clear_validation_cache(self):
            _U9XS1.cache.delete(requests=[Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key}}), Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key, 'scope': {'fingerprint': _m8JHi()}}})])

        def _clear_machines_cache(self):
            _U9XS1.cache.delete(urls=[f'{self.base_url}/licenses/{self.license_id}/machines'])

        def _clear_tokens_cache(self, token_id):
            _U9XS1.cache.delete(urls=[f'{self.base_url}/tokens/{token_id}'])

        def get_machines(self, cache_force_refresh=False):
            _5GmVc = _U9XS1.get(f'{self.base_url}/licenses/{self.license_id}/machines', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _VnnPH}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_5GmVc)
            except _k8vYk:
                _U9XS1.cache.delete(requests=[_5GmVc.request])
                raise
            _DNnCn(_5GmVc)
            json = _5GmVc.json()
            return _ka33M(json, 'data', default=[])

        def prettyprint(self, show_key=False):
            _vTLGX: bool | Literal['unknown']
            try:
                _kaS9r = self.validate(raise_on_error=False)
            except requests.exceptions.ReadTimeout:
                _vTLGX = 'unknown'
                _QV9p8 = 'timeout'
            else:
                _vTLGX = _kaS9r['valid']
                assert isinstance(_vTLGX, bool)
                _QV9p8 = _ka33M(_kaS9r, 'code')
            super()._prettyprint(show_key=show_key, is_valid=_vTLGX, validation_code=_QV9p8)

        def _get_machine_by_fingerprint_cached(self, fingerprint, cache_force_refresh=False, raise_on_error=False):
            _K0ZVV = _U9XS1.get(url=f'{self.base_url}/machines', params={'fingerprint': quote(fingerprint)}, headers={'Authorization': self.auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _VnnPH}, timeout=10, force_refresh=cache_force_refresh)
            self.verify_response(_K0ZVV)
            _DNnCn(_K0ZVV)
            _D3hPy = _K0ZVV.json()
            _Ie5wg = _ka33M(_D3hPy, 'errors')
            if raise_on_error and _Ie5wg:
                _83z9a = 'Get-Machine errors:\n' + '\n'.join((f"    {_wk1Kf['title']}: {_wk1Kf['detail']}" for _wk1Kf in _Ie5wg))
                raise _46nNn(_83z9a, 'KG_MACHINE_ERROR')
            return _D3hPy

        def _ping_heartbeat_cached(self, raise_on_error, cache_force_refresh=False):
            _WwhGt = _m8JHi()
            _s6niI = self._get_machine_by_fingerprint_cached(_WwhGt, cache_force_refresh=cache_force_refresh)
            _VpeRg = _ka33M(_s6niI, 'data', 0, 'id')
            if _VpeRg is None:
                _ZAYBX = f'Machine with fingerprint {_WwhGt} not found'
                raise _46nNn(_ZAYBX, 'KG_MACHINE_NOT_FOUND')
            _6zdse = _U9XS1.post(f'{self.base_url}/machines/{_VpeRg}/actions/ping-heartbeat', headers={'Authorization': self.auth, 'Accept': 'application/vnd.api+json', 'Keygen-Version': _VnnPH}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_6zdse)
            except _k8vYk:
                _U9XS1.cache.delete(requests=[_6zdse.request])
                raise
            _DNnCn(_6zdse)
            _N9grw = _6zdse.json()
            _jWiDe = _ka33M(_N9grw, 'errors')
            if _jWiDe and _ka33M(_jWiDe[0], 'code') == 'NOT_FOUND' and (not cache_force_refresh):
                return self._ping_heartbeat_cached(raise_on_error, cache_force_refresh=True)
            if raise_on_error and _jWiDe:
                _ZAYBX = f'License {self.license_id}: Heartbeat errors:\n' + '\n'.join((f"    {_08nW5['title']}: {_08nW5['detail']}" for _08nW5 in _jWiDe))
                raise _46nNn(_ZAYBX, 'KG_HEARTBEAT_ERROR')
            return _N9grw

    def _1xo1X():
        _U9XS1.cache.clear()

    class _X0JV7(_dUuKD):
        key_type = 'Keygen offline'

        @classmethod
        def from_file(cls, path):
            assert isinstance(path, (str, Path))
            path = Path(path)
            with path.open() as _xHn11:
                _cnEfm = _xHn11.read().strip().replace('\n', '')
            assert _cnEfm, f'Empty license file {path}'
            return cls(_cnEfm)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _Pxb5d = 'key/'
            if not key.startswith(_Pxb5d):
                _OCk0I = f'Expected prefix key/, got {key[:len(_Pxb5d)]}...'
                raise ValueError(_OCk0I)
            self._key = key
            _dhJTk, _6mqMu = self._key.split('.')
            _t1YUV = base64.urlsafe_b64decode(_6mqMu)
            self._data = json.loads(base64.urlsafe_b64decode(_dhJTk[len(_Pxb5d):]))
            _o9xPX = _ka33M(self._data, 'account', 'id')
            if not _o9xPX:
                _OCk0I = 'Key lacks account ID'
                raise _46nNn(_OCk0I, 'KG_MISSING_ACCOUNT_ID')
            self.vendor: Vendor = _09hCd(_o9xPX)
            _qAkAK = self.vendor.verify_key
            if isinstance(_qAkAK, _AFlxz):
                _qAkAK.verify(_t1YUV, _dhJTk.encode(), padding='pss')
            else:
                _qAkAK.verify(_t1YUV, _dhJTk.encode())

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def account_id(self):
            return _ka33M(self.data, 'account', 'id')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def product_name(self):
            return None

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def created(self):
            return _eAX2W(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _ka33M(self.data, 'license', 'expiry')):
                return _eAX2W(expiry)
            return None

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def user(self):
            if (user := _ka33M(self.data, 'user')):
                return {'id': _ka33M(user, 'id'), 'email': _ka33M(user, 'email')}
            return {}

        def list_machines(self):
            return []

        def validate(self, raise_on_error=True):
            _gJkvq = datetime.now(tz=timezone.utc)
            created = _ka33M(self.data, 'license', 'created')
            if created and _gJkvq < _eAX2W(created) - timedelta(minutes=5):
                if raise_on_error:
                    _e4T5l = 'Invalid license'
                    raise _46nNn(_e4T5l, 'KG_E043')
                return {'valid': False, 'code': 'KG_E043', 'detail': 'Unknown error E043'}
            expiry = _ka33M(self.data, 'license', 'expiry')
            if expiry and _gJkvq > _eAX2W(expiry) + timedelta(minutes=5):
                if raise_on_error:
                    _e4T5l = f'License has expired on {expiry}'
                    raise _46nNn(_e4T5l, 'KG_EXPIRED')
                return {'valid': False, 'code': 'KG_EXPIRED', 'detail': 'License has expired'}
            return {'valid': True, 'code': 'VALID', 'detail': 'is valid'}

        def prettyprint(self, show_key=False):
            _sZe0T = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_sZe0T['valid'], validation_code=_sZe0T['code'])

    def _zlxQI(license_string):
        assert not license_string.startswith('key/')
        if license_string.startswith('fp/'):
            return (license_string[3:], True)
        return (license_string, False)

    def _adfSv(string, prefix, suffix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix).removesuffix(suffix)
        if string.startswith(prefix):
            string = string[len(prefix):]
        if string.endswith(suffix):
            string = string[:-len(suffix)]
        return string

    def _rJwrL(cert_data_or_path, update_if_expired=True, override_original=True):
        _iSemr = None
        if isinstance(cert_data_or_path, Path):
            _iSemr = cert_data_or_path
            with _iSemr.open() as _sDPZP:
                _WPI9C = _sDPZP.read()
        else:
            assert isinstance(cert_data_or_path, str)
            _WPI9C = cert_data_or_path
        _J7LH8, _EV5FH = _ugW4a(_WPI9C)
        _rE2Oc = datetime.now(tz=timezone.utc)
        if _eAX2W(_EV5FH['issued']) > _rE2Oc + timedelta(minutes=5):
            _61CSX = 'License error'
            raise _46nNn(_61CSX, 'KG_E058')
        if _iSemr and update_if_expired and (_rE2Oc > _eAX2W(_EV5FH['expiry'])):
            _WPI9C = _RymVL(_J7LH8['relationships']['account']['data']['id'], _J7LH8['id'], auth=f"License {_J7LH8['attributes']['key']}")
            _J7LH8, _EV5FH = _ugW4a(_WPI9C)
            if override_original:
                with _iSemr.open('w') as _epCcM:
                    _epCcM.write(_WPI9C)
        _1SW02 = _J7LH8['attributes']['key']
        if _1SW02.startswith('key/'):
            return _X0JV7(_1SW02)
        return _1Xvnh(_J7LH8)

    def _TRdaq(path):
        with path.open() as _hBzW8:
            _sGddm = _hBzW8.read()
        _3ZY4p, _aVxlG = _ugW4a(_sGddm)
        _tSmxQ = _3ZY4p['attributes']['key']
        _sGddm = _RymVL(_3ZY4p['relationships']['account']['data']['id'], _3ZY4p['id'], auth=f'License {_tSmxQ}')
        with path.open('w') as _LfBoT:
            _LfBoT.write(_sGddm)

    def _ugW4a(content):
        assert isinstance(content, str)
        _KxOQI = '-----BEGIN LICENSE FILE-----\n'
        _ePf2W = '-----END LICENSE FILE-----'
        content = content.strip()
        if not content.startswith(_KxOQI) or not content.endswith(_ePf2W):
            _goTy4 = f'Error in license file. Expected\n```{_KxOQI}...\n{_ePf2W}\n```\ngot\n```\n{content}\n```\nTry refreshing the the license file with `slim refresh`.\n'
            raise ValueError(_goTy4)
        _RDgm4 = base64.b64decode(_adfSv(content, _KxOQI, _ePf2W))
        try:
            _KkzEW = json.loads(_RDgm4)
        except UnicodeDecodeError:
            _goTy4 = 'Unexpected license data'
            raise RuntimeError(_goTy4) from None
        _qSMYJ = json.loads(base64.b64decode(_KkzEW['enc']))
        _wKsoJ = _ka33M(_qSMYJ, 'data', 'relationships', 'account', 'data', 'id')
        _2VCJq = _09hCd(_wKsoJ).verify_key
        _600Y4 = ('license/' + _KkzEW['enc']).encode()
        _IC8T9, _WjnbT = _KkzEW['alg'].split('+')
        assert _IC8T9 == 'base64'
        _PzUtg = base64.b64decode(_KkzEW['sig'])
        if _2VCJq.alg != _WjnbT:
            _goTy4 = f'Requested {_WjnbT} key, but got {_2VCJq.alg} verify_key'
            raise RuntimeError(_goTy4)
        _2VCJq.verify(_PzUtg, _600Y4)
        return (_qSMYJ['data'], _qSMYJ['meta'])

    def _RymVL(account_id, license_id_or_key, auth, host='api.keygen.sh'):
        _JZ8t1 = requests.get(f'https://{host}/v1/accounts/{account_id}/licenses/{quote(license_id_or_key)}/actions/check-out', headers={'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': '1.3'}, timeout=10)
        _JZ8t1.raise_for_status()
        _09hCd(account_id).verify_key.verify_response(_JZ8t1)
        _DNnCn(_JZ8t1)
        return _JZ8t1.text
    try:
        import tomllib
    except ImportError:
        import tomli as tomllib
    _gNscB = _gz7U3 / 'keygen'

    def _zqnYo(file_or_cert):
        _86HoT = _rJwrL(file_or_cert, update_if_expired=True, override_original=False)
        if isinstance(_86HoT, _1Xvnh):
            _86HoT.validate(activate_if_required=True)
            return _2jtBr(_86HoT, file_or_cert)
        assert isinstance(_86HoT, _X0JV7)
        _3oL23(_86HoT)
        return _86HoT

    def _2jtBr(lic, cert=None):
        _OyNwR('Installing license...', end='', style='green', highlight=False)
        if cert is None:
            cert = _RymVL(lic.account_id, lic.license_key, auth=f'License {lic.license_key}')
        elif isinstance(cert, Path):
            with cert.open() as _mIBVo:
                cert = _mIBVo.read()
        assert isinstance(cert, str)
        assert cert.startswith('-----BEGIN LICENSE FILE-----')
        assert lic.product_id, 'Missing product ID'
        assert lic.license_id, 'Missing license ID'
        _dNFqB = _gNscB / lic.product_id / (lic.license_id + '.lic')
        _dNFqB.parent.mkdir(parents=True, exist_ok=True)
        with _dNFqB.open('w') as _Rneib:
            _Rneib.write(cert)
        _OyNwR('done.', style='green')
        return lic

    def _3oL23(lic):
        _heS0B = _gNscB / lic.product_id / (lic.license_id + '.key')
        _heS0B.parent.mkdir(parents=True, exist_ok=True)
        _F2Xrp, _mDr3o = lic.key.split('/')
        _bvEcE, _AtMBT = _mDr3o.split('.')
        with _heS0B.open('w') as _YU7LT:
            _YU7LT.write(_F2Xrp + '/\n' + _44asd(_bvEcE, 60) + '\n.\n' + _44asd(_AtMBT, 60))

    def _9RHmr(toml_file):
        _LZ7dX = _30Xfn(toml_file)
        if _LZ7dX.startswith('key/'):
            _Wy5ja = _X0JV7(_LZ7dX)
            _3oL23(_Wy5ja)
            return _Wy5ja
        _LZ7dX = _pY1ZL(_LZ7dX, 'fp/')
        _CCkOq = _1Xvnh.from_key(_6CW9x(_LZ7dX), _LZ7dX)
        _CCkOq.validate(activate_if_required=True)
        _2jtBr(_CCkOq)
        return _CCkOq

    def _30Xfn(toml_file):
        with Path(toml_file).open('rb') as _nGSlc:
            _TPRGh = tomllib.load(_nGSlc)
        assert _TPRGh, f'Empty license file {toml_file}'
        return _TPRGh['license_key']

    @_YNQ5D
    def _HAGwK(product_id=None, license_keys_or_ids=None):
        _IFBQd = _gNscB
        if product_id:
            _IFBQd /= product_id
        for _M9Ybv in _IFBQd.rglob('*.key'):
            _R3IkJ = _X0JV7.from_file(_M9Ybv)
            if license_keys_or_ids is None:
                yield (_M9Ybv, _R3IkJ)
            else:
                _t2zvG = _ka33M(_R3IkJ.data, 'license', 'id')
                if _t2zvG in license_keys_or_ids:
                    license_keys_or_ids.remove(_t2zvG)
                    yield (_M9Ybv, _R3IkJ)
                    continue
                if _R3IkJ.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_R3IkJ.key)
                    yield (_M9Ybv, _R3IkJ)
                    continue

    @_YNQ5D
    def _MdzKM(product_id=None, license_keys_or_ids=None):
        _54HSX = _gNscB
        if product_id:
            _54HSX /= product_id
        for _Q8bk4 in _54HSX.rglob('*.toml'):
            _9RHmr(_Q8bk4)
            _Q8bk4.unlink()
        for _EW7vM in _54HSX.rglob('*.lic'):
            _ongAx = _rJwrL(_EW7vM)
            if license_keys_or_ids is None:
                yield (_EW7vM, _ongAx)
            else:
                _RMr8L = _ka33M(_ongAx.data, 'id')
                if _RMr8L in license_keys_or_ids:
                    license_keys_or_ids.remove(_RMr8L)
                    yield (_EW7vM, _ongAx)
                    continue
                _Y8zKU = _ka33M(_ongAx.data, 'attributes', 'key')
                if _Y8zKU in license_keys_or_ids:
                    license_keys_or_ids.remove(_Y8zKU)
                    yield (_EW7vM, _ongAx)
                    continue

    def _Br3bq():
        _XL56V = 0
        for _ldCsx in _gNscB.rglob('*.lic'):
            _TRdaq(_ldCsx)
            _XL56V += 1
        return _XL56V
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_VZVT3
    @cache
    def _q7lZz(account_id, product_id, variable_names=(), allow_user_input=True, cache_force_refresh=False, cache_expire_after=None):
        assert isinstance(product_id, str)
        _09hCd(account_id)
        for _2LrYK in _1rHYr(_0lHWn(account_id, list(variable_names)), _NRhYO(product_id), _j2OYu(product_id)):
            if isinstance(_2LrYK, _1Xvnh):
                try:
                    _CrcK3 = _2LrYK.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                except _46nNn as e:
                    _d4mD0(str(e))
                    continue
            elif isinstance(_2LrYK, _X0JV7):
                try:
                    _CrcK3 = _2LrYK.validate()
                except _46nNn as e:
                    _d4mD0(str(e))
                    continue
            else:
                continue
            if _2LrYK.account_id != account_id or _2LrYK.product_id != product_id:
                continue
            return (_2LrYK.data, _CrcK3)
        _g7HZ6 = f'Unable to find valid license for product ID {product_id}.'
        if allow_user_input:
            _d4mD0(_g7HZ6)
            _u97nJ = Prompt.ask('Enter license key')
            _2LrYK = _dRMcm(_u97nJ, account_id)
            if _2LrYK is None:
                _PJgow = f'Illegal license key `{_u97nJ}`. Typo?'
                raise _46nNn(_PJgow, 'ILLEGAL_KEY')
            if isinstance(_2LrYK, _1Xvnh):
                _CrcK3 = _2LrYK.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                _2jtBr(_2LrYK)
                return (_2LrYK.data, _CrcK3)
            if isinstance(_2LrYK, _X0JV7):
                _CrcK3 = _2LrYK.validate()
                if _2LrYK.product_id != product_id:
                    _PJgow = f'Require product ID {product_id}, but license has product ID {_2LrYK.product_id}'
                    raise _46nNn(_PJgow, 'KG_WRONG_PRODUCT_ID')
                _3oL23(_2LrYK)
                return (_2LrYK.data, _CrcK3)
        raise _46nNn(_g7HZ6, 'KG_NOT_FOUND')

    def _0lHWn(account_id, var_names):
        for _MnphE, _uoYDb, _x6Daf in _wE5nc(var_names):
            if _x6Daf.strip() == '':
                _d4mD0(f'{_MnphE.title()} variable `{_uoYDb}` is empty.')
                continue
            _KJSSO = _dRMcm(_x6Daf, account_id)
            if _KJSSO is None:
                _d4mD0(f'{_MnphE.title()} variable `{_uoYDb}` contains value that cannot be converted to a KG license:\n{_x6Daf}')
                continue
            yield _KJSSO

    def _dRMcm(value, account_id):
        if value.endswith('-V3'):
            _lK8pe = _pY1ZL(value, 'fp/')
            return _1Xvnh.from_key(account_id, _lK8pe)
        if value.startswith('key/'):
            return _X0JV7(value)
        if value.startswith('-----BEGIN LICENSE FILE-----'):
            return _rJwrL(value, update_if_expired=True, override_original=False)
        _8MGlD = Path(value)
        if _8MGlD.is_file():
            with _8MGlD.open() as _LekMR:
                _o7iX6 = _LekMR.read()
            return _dRMcm(_o7iX6, account_id)
        return None

    def _NRhYO(product_id):
        for _N13sP, _8Ug4I in _HAGwK(product_id=product_id):
            yield _8Ug4I

    def _j2OYu(product_id):
        for _quPUX, _CflVo in _MdzKM(product_id=product_id):
            try:
                yield _CflVo
            except _k8vYk:
                _d4mD0(f'Invalid signature in {_quPUX}. Skipping.')

    class _dbF1J:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        vendor_id = '6697c7f2-ad29-42c6-8b78-8ddb2a56bc0b'
        verify_key = _WX2sO.from_hex('43157566ccbbe4f46fe5f02d6c1d363a3a502c3dbee36c22cf266e4015bdc23e')
    _bWVbE = {vendor.vendor_id: vendor for vendor in [_dbF1J]}

    def _hMSJU(vendor_id):
        try:
            return _bWVbE[vendor_id]
        except KeyError:
            _B7uPv = f"Cannot use SLiM with vendor ID {vendor_id}. If you're a vendor and like to use the Stonefish, contact <support@mondaytech.com>."
            raise _46nNn(_B7uPv, 'KG_VENDOR_ERROR') from None

    class _TtVVf(_dUuKD):
        key_type = 'Stonefish License Creator'

        @classmethod
        def from_file(cls, path, *_n2MRJ, **_p0mYl):
            path = Path(path)
            with path.open() as _MqZA2:
                _Hvvdx = _MqZA2.read().strip().replace('\n', '')
            return cls(_Hvvdx, *_n2MRJ, **_p0mYl)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _RTWS1 = 'slicv1/'
            if not key.startswith(_RTWS1):
                _Ki5OO = f'Expected prefix {_RTWS1!r}, got {key[:len(_RTWS1)]!r}...'
                raise ValueError(_Ki5OO)
            self._key = key
            self.signing_data, _My4mf = self._key.split('.')
            self.enc_sig = base64.urlsafe_b64decode(_My4mf)
            _nd5Ed = self.signing_data[len(_RTWS1):]
            self._data = json.loads(base64.urlsafe_b64decode(_nd5Ed))
            _bxFSN = _ka33M(self._data, 'vendor', 'id')
            if not _bxFSN:
                _Ki5OO = 'Key lacks vendor ID'
                raise _46nNn(_Ki5OO, 'SLIC_MISSING_VENDOR_ID')
            self.vendor = _hMSJU(_bxFSN)
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            return _eAX2W(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _ka33M(self.data, 'license', 'expiry')):
                return _eAX2W(expiry)
            return None

        def list_machines(self):
            return _ka33M(self.data, 'machines', default=[])

        @property
        def product_name(self):
            return _ka33M(self.data, 'product', 'name')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def user(self):
            return _ka33M(self.data, 'user', default={})

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        def validate(self, raise_on_error=True):
            try:
                self.vendor.verify_key.verify(self.enc_sig, self.signing_data.encode())
            except _k8vYk:
                if raise_on_error:
                    raise
                return {'valid': False, 'code': 'SIGNATURE_ERROR', 'detail': 'Signature could not be verified'}
            _FgOtM = datetime.now(tz=timezone.utc)
            _ZweOT = _eAX2W(self.data['license']['created'])
            if _ZweOT > _FgOtM:
                _0ySUD = 'SLIC_E043'
                _Wd6n0 = 'Unknown license error'
                if raise_on_error:
                    raise _46nNn(_Wd6n0, _0ySUD)
                return {'valid': False, 'code': _0ySUD, 'detail': _Wd6n0}
            _Qz6zw = _eAX2W(expiry) if (expiry := _ka33M(self.data, 'license', 'expiry')) else None
            if _Qz6zw:
                if _ZweOT > _Qz6zw:
                    _0ySUD = 'SLIC_E044'
                    _Wd6n0 = 'Unknown license error'
                    if raise_on_error:
                        raise _46nNn(_Wd6n0, _0ySUD)
                    return {'valid': False, 'code': _0ySUD, 'detail': _Wd6n0}
                if _FgOtM > _Qz6zw:
                    _0ySUD = 'SLIC_EXPIRED'
                    _Wd6n0 = f'License has expired on {_Qz6zw}'
                    if raise_on_error:
                        raise _46nNn(_Wd6n0, _0ySUD)
                    return {'valid': False, 'code': _0ySUD, 'detail': _Wd6n0}
            _mpp6v = _ka33M(self.data, 'machines')
            if _mpp6v:
                _wMyVp = _m8JHi()
                if _wMyVp not in _mpp6v:
                    _0ySUD = 'SLIC_MACHINE_ERROR'
                    _Wd6n0 = f'License not valid on this machine (fingerprint {_wMyVp})'
                    if raise_on_error:
                        raise _46nNn(_Wd6n0, _0ySUD)
                    return {'valid': False, 'code': _0ySUD, 'detail': _Wd6n0}
            return {'valid': True, 'code': None, 'detail': ''}

        def prettyprint(self, show_key=False):
            _6WIHc = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_ka33M(_6WIHc, 'valid'), validation_code=_ka33M(_6WIHc, 'code'))
    _dl1IK = _gz7U3 / 'slic'

    def _qEtCA(data):
        _loSUa = _TtVVf(data)
        _fw8R9 = _loSUa.data['product']['id']
        _aOTeX = _loSUa.data['license']['id']
        _mY4Qa = _dl1IK / _fw8R9 / (_aOTeX + '.key')
        _mY4Qa.parent.mkdir(parents=True, exist_ok=True)
        _6fZAW, _tukhS = _loSUa.key.split('/')
        data, _hqIkf = _tukhS.split('.')
        with _mY4Qa.open('w') as _LVLn7:
            _LVLn7.write(_6fZAW + '/\n' + _44asd(data, 60) + '\n.\n' + _44asd(_hqIkf, 60))
        return _loSUa

    @_YNQ5D
    def _eaWss(license_keys_or_ids=None, product_id=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _yZ7BS = _dl1IK
        if product_id:
            _yZ7BS /= product_id
        for _2ERLy in _yZ7BS.rglob('*.key'):
            _UzLUD = _TtVVf.from_file(_2ERLy)
            if license_keys_or_ids is None:
                yield (_2ERLy, _UzLUD)
            else:
                _edjPS = _ka33M(_UzLUD.data, 'license', 'id')
                if _edjPS in license_keys_or_ids:
                    license_keys_or_ids.remove(_edjPS)
                    yield (_2ERLy, _UzLUD)
                    continue
                if _UzLUD.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_UzLUD.key)
                    yield (_2ERLy, _UzLUD)
                    continue

    @dataclass
    class _6W17T:
        name: str
        email: str | None
        product_ids: tuple[int]
        verify_key: VerifyKey
    _bQ6el = _6W17T('Monday Tech', 'support@mondaytech.com', (21778,), _HxAZv(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfz7XiRe459sYB/PxgoMR0VKX0aA0rC+FPV8G7h02DHiYYKmtsI3o1kq7w3I6JKHpU8VnCEy2P6+W+8A0fdgTIQZJiKTsuJ7ymtX3hT/TyuIVveOsLBd5OHr0Prh/sshv4kFJTUYAROGtRVR/p/Ut2XTSaQIj02Zv9Yd8v1gMF8BsRgShG3Omyo+TfxA2OvXnlqCcSumyk2pfLtdkuGX0a5gTsG7kqY1e0RWB8LN0Ko7fCPCXuy1i/auwtGt/YALh+vL02RWb7CZSMvPEWJGh6WPwhcvywyRlEgFnKB3Ec1j3DcgUNXVQXHSYrbmveXfMkjpxokDIGWcbD3HY0agGwIDAQAB')))
    _YAW4q = _6W17T('Deecie', None, (23488,), _HxAZv(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArCITfOmahfX98LErjl8C22YRDpJjeQPJACSxBjEOAwjOwFoUNeEwVZyif0thbZVjZh4/Zp/413RoxQgSeWfoaZqsnvTV5iWBk3tN8wILmR4305fpjJHnrobJDyKoz9VUQRzwVtOkT3pbIeP/WrIz+937FO5Z2F76tMmMMlNtWgMCIEc8BT97yZPB5wXSWYozQ6WfNlm9/L2ajMce4P6kX1nKwBYkxY+MBG+7YyF66on7mG3LJUa/H1ZGVLpPNVpbd5WOL7f/vXE/RGYcwfSeQGiLEUxcwtsFhtfbjBivwxMSshOW7WLIgaC3lFKNWnT5sIeRGTeSvbFpVR5ERaiwhwIDAQAB')))
    _nMOmF = {product_id: vendor for vendor in [_bQ6el, _YAW4q] for product_id in vendor.product_ids}

    def _OP5Cf(product_id):
        assert isinstance(product_id, int)
        try:
            return _nMOmF[product_id]
        except KeyError:
            _NPqPj = f"Cannot use SLiM with Cryptolens product ID {product_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _46nNn(_NPqPj, 'CL_VENDOR_ERROR') from None

    class _ckEz0:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        products_codes = ('stp01',)
    _MeYC6 = {product_code: vendor for vendor in [_ckEz0] for product_code in vendor.products_codes}

    def _RVTFQ(product_code):
        try:
            return _MeYC6[product_code]
        except KeyError:
            _tYHaM = f"Cannot use SLiM with LicenseSpring product code {product_code}... If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _46nNn(_tYHaM, 'CL_VENDOR_ERROR') from None
    _yw6e4 = platformdirs.user_data_path('slim', 'MondayTech') / 'license_spring'
    _Eb9Gj = _76CJP(base64.b64decode('MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwEt7ZQWSzeBYNBwyi3KW+XU/6I+ju90R5ZpTvSE4VWL8KSgVJ6bWKIhaKTL2hbUpIQQgS5ZKfa4SEEMdIm5kxe0u2F64JFAVQunx/1O/UXsD7ADVt93Q/hxA9Npa16tKepZoyhi79sxpaxyy/WTdsZKuTLApX7bWX6/XPhaPjNyiWeeK2Naka44B+F+PwN/ey3rZUra3pBltShwy2dmKIxJVmprf5ttMYBB+ouqPin3VgDw5Jq1FZwpLBiOe+ogR+sHu7QYWwLq6AgC4e3JqgryEvqfJr/XkvOnAdcAIZm6tK6DdnLWCy6Onrk7t0VQK5nnGF1CKE+jcAByWopcIVCwfYrs1UCSY1YibKXNJoyvEhgLyCC+KAgXKf8omcg1Q18XKu5XSrvrCzXLnRnaFNpFDjcg5AJJab78hX7qGPC+e8PjuBYwh2vtx5mFj7/c+T59JM/vXwwvW9DsnDztDWEDFhzGanU71NgwrZbRoNSyTW0UjbZsyJVSIX6233Ng0y5L9mDe8p8P+u1B0sXAAozEKL/yG4Qu5r4LIw4iv6JVPT1xbWlH4Vc4KaN3toaf4+G0EkFy6ncvBncWifLARSoWpQ5YsygDdQNVYdmMsoQ76UTuNxo3eZ0sQJjbQVBqlkcXrAdtUCpuojPRsl/Xs9zVOJrzZPG0I98E5quNbRkMCAwEAAQ=='))
    _fkukg = 'https://api.licensespring.com/api/v4'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _VfLkm = requests_cache.CachedSession(cache_name=_Yb1rt / 'license_spring', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _VuBrH(_dUuKD):
        key_type = 'License Spring'

        @classmethod
        def from_file(cls, path):
            with Path(path).open() as _ARzu0:
                _hNkI3 = _ARzu0.read()
            try:
                _oFyA4 = base64.b64decode(_hNkI3)
            except binascii.Error:
                _2Q35d = f'Invalid license file {path}'
                raise _46nNn(_2Q35d, 'LS_INVALID_FILE') from None
            _yEy2e = json.loads(_oFyA4)
            _LJQWB = base64.b64decode(_yEy2e.pop('license_signature_v2'))
            _AZpCg = json.dumps(_yEy2e, separators=(',', ':')).encode()
            _Eb9Gj.verify(_LJQWB, _AZpCg, padding='pkcs1v15')
            _vas4G(datetime.strptime(_yEy2e['date'], '%a %b %d %Y %H:%M:%S GMT%z'))
            return cls(_yEy2e)

        @classmethod
        def from_key(cls, product_code, license_key):
            _1hSf1 = {'product_details': {'short_code': product_code}, 'license_key': license_key}
            return cls(_1hSf1)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert _ka33M(data, 'license_key')
            _wr6IE = _ka33M(data, 'product_details', 'short_code')
            assert _wr6IE
            self.vendor = _RVTFQ(_wr6IE)
            self._data = data

        @property
        def data(self):
            return self._data

        @property
        def license_id(self):
            return _ka33M(self.data, 'id')

        @property
        def product_id(self):
            return _ka33M(self.data, 'product_details', 'product_id')

        @property
        def product_code(self):
            return self.data['product_details']['short_code']

        @property
        def product_name(self):
            return _ka33M(self.data, 'product_details', 'product_name')

        @property
        def key(self):
            return self.data['license_key']

        @property
        def created(self):
            if (date := _ka33M(self.data, 'date')):
                return datetime.strptime(date, '%a %b %d %Y %H:%M:%S GMT%z')
            return None

        @property
        def expiry(self):
            if (vp := self.data.get('validity_period')):
                return _eAX2W(vp)
            return None

        @property
        def user(self):
            user = _ka33M(self.data, 'customer')
            if not user:
                return {}
            _VP2je = []
            if (fn := user['first_name']):
                _VP2je.append(fn)
            if (ln := user['last_name']):
                _VP2je.append(ln)
            return {'name': ' '.join(_VP2je) if _VP2je else None, 'email': user['email'] or None}

        @property
        def vendor_name(self):
            return self.vendor.name

        def list_machines(self):
            return []

        def validate(self, shared_key, api_key, activate_if_required=True, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _6awpq = _VfLkm.get(url=f'{_fkukg}/check_license', headers=_tRwUm(shared_key, api_key), params={'product': self.product_code, 'hardware_id': _m8JHi(), 'license_key': self.key}, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            _AfXww(_6awpq)
            _DNnCn(_6awpq)
            data = _6awpq.json()
            if data.get('code') in {'license_not_active', 'device_not_found'} and activate_if_required:
                self.activate(shared_key, api_key)
                _Mu4Rh()
                return self.validate(shared_key, api_key, activate_if_required=activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=True)
            if not _6awpq.ok and raise_on_error:
                raise _46nNn(data['message'], 'LS_VALIDATION_ERROR')
            self._data = data
            return data

        def activate(self, shared_key, api_key, app_version=None):
            data = {'product': self.product_code, 'hardware_id': _m8JHi(), 'license_key': self.key, 'os_ver': platform.platform(), 'hostname': socket.gethostname(), 'mac_address': ':'.join((f'{_Ls638:02x}' for _Ls638 in uuid.getnode().to_bytes(6, byteorder='big')))}
            _9WSQm = _VyfsH('stonefish-license-manager')
            data['sdk_ver'] = f'Stonefish License Manager {_9WSQm}'
            if app_version:
                data['app_ver'] = app_version
            _Kcf3r = requests.post(url=f'{_fkukg}/activate_license', headers=_tRwUm(shared_key, api_key), json=data, timeout=10)
            _AfXww(_Kcf3r)
            _DNnCn(_Kcf3r)
            json = _Kcf3r.json()
            if not _Kcf3r.ok:
                raise _46nNn(json['message'], 'LS_ACTIVATION_ERROR')
            return json

        def deactivate(self, shared_key, api_key):
            _bGObu = requests.post(url=f'{_fkukg}/deactivate_license', headers=_tRwUm(shared_key, api_key), json={'product': self.product_code, 'hardware_id': _m8JHi(), 'license_key': self.key}, timeout=10)
            _DNnCn(_bGObu)
            if not _bGObu.ok:
                json = _bGObu.json()
                raise _46nNn(json['message'], 'LS_DEACTIVATION_ERROR')
            return

        def prettyprint(self, show_key=False):
            super()._prettyprint(show_key=show_key, is_valid='unknown', validation_code=None)

    def _m0LZZ():
        _VfLkm.cache.clear()

    def _Mu4Rh():
        for _ZahCo in _VfLkm.cache.responses.values():
            if _ZahCo.url == f'{_fkukg}/check_license':
                _VfLkm.cache.delete(_ZahCo.cache_key)

    def _tRwUm(shared_key, api_key):
        _Ddp0T = format_date_time(time.time())
        _4vypX = hmac.new(bytes(shared_key, 'utf-8'), f'licenseSpring\ndate: {_Ddp0T}'.encode(), hashlib.sha256).digest()
        _ERrMK = base64.b64encode(_4vypX).decode()
        _iejNs = ','.join(['algorithm="hmac-sha256"', 'headers="date"', f'signature="{_ERrMK}"', f'apiKey="{api_key}"'])
        return {'Content-Type': 'application/json', 'Date': _Ddp0T, 'Authorization': _iejNs}

    def _MkLyb(product_code, shared_key, api_key):
        _cy8bX = _VfLkm.get(url=f'{_fkukg}/product_details', params={'product': product_code}, headers=_tRwUm(shared_key, api_key), timeout=10)
        _AfXww(_cy8bX)
        _DNnCn(_cy8bX)
        _3PWoW = _cy8bX.json()
        if not _cy8bX.ok:
            raise _46nNn(_3PWoW['message'], 'LS_PRODUCT_ERROR')
        return _3PWoW

    def _AfXww(res):
        if (sig := res.headers.get('LicenseSignature')):
            _Eb9Gj.verify(base64.b64decode(sig), res.content, padding='pkcs1v15')
    if TYPE_CHECKING:
        from pathlib import Path
    _wzi3f = _gz7U3 / 'license_spring'

    def _1XXLn(path):
        _755a0 = _VuBrH.from_file(path)
        _MX2rF = _755a0.data['product_details']['short_code']
        _5bsQo = _755a0.data['id']
        _GoSVU = _wzi3f / _MX2rF / (str(_5bsQo) + '.lic')
        _GoSVU.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(path, _GoSVU)
        return _755a0

    @_YNQ5D
    def _idr5P(license_keys_or_ids=None, product_code=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _1Q4WH = _wzi3f
        if product_code:
            _1Q4WH /= product_code
        for _lnGw4 in _1Q4WH.rglob('*.lic'):
            _wMK65 = _VuBrH.from_file(_lnGw4)
            if license_keys_or_ids is None:
                yield (_lnGw4, _wMK65)
            else:
                _L0WoY = str(_ka33M(_wMK65.data, 'id'))
                if _L0WoY in license_keys_or_ids:
                    license_keys_or_ids.remove(_L0WoY)
                    yield (_lnGw4, _wMK65)
                    continue
                _rd68d = _ka33M(_wMK65.data, 'license_key')
                if _rd68d in license_keys_or_ids:
                    license_keys_or_ids.remove(_rd68d)
                    yield (_lnGw4, _wMK65)
                    continue
    _vlF9j = 'https://api.cryptolens.io/api'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _2lqPu = requests_cache.CachedSession(cache_name=_Yb1rt / 'cryptolens', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _uvles(_dUuKD):
        key_type = 'Cryptolens'

        @classmethod
        def from_key(cls, product_id, key):
            assert isinstance(product_id, int)
            return cls({'ProductId': product_id, 'Key': key})

        @classmethod
        def from_file(cls, path, token, update_if_older_than=timedelta(days=30)):
            path = Path(path)
            assert path.suffix == '.skm'
            with path.open() as _ckbG9:
                _8g25a = json.load(_ckbG9)
            _F2M2c = base64.b64decode(_8g25a['signature'])
            _WFtdw = base64.b64decode(_8g25a['licenseKey'])
            _xIaJT = json.loads(_WFtdw)
            _Q1plm = _OP5Cf(_xIaJT['ProductId'])
            _Q1plm.verify_key.verify(sig_bytes=_F2M2c, msg_bytes=_WFtdw, padding='pkcs1v15')
            _6iz6J(_xIaJT['SignDate'])
            _6iz6J(_xIaJT['Created'])
            if not token:
                for _mCsOv in _xIaJT['DataObjects']:
                    if _mCsOv['Name'] == 'token':
                        token = _mCsOv['StringValue']
                        break
            _LCQF8 = datetime.now(tz=timezone.utc)
            _hN3se = datetime.fromtimestamp(_xIaJT['SignDate'], tz=timezone.utc)
            if token is not None and update_if_older_than and (_LCQF8 > _hN3se + update_if_older_than):
                _8g25a, _xIaJT = _OA7SF(_xIaJT['ProductId'], _xIaJT['Key'], token, activate=False)
                _6iz6J(_xIaJT['SignDate'])
                _6iz6J(_xIaJT['Created'])
                with path.open('w') as _2NUgv:
                    json.dump(_8g25a, _2NUgv)
            return cls(_xIaJT)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert isinstance(_ka33M(data, 'ProductId'), int)
            assert isinstance(_ka33M(data, 'Key'), str)
            self._data = data
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['Key']

        @property
        def license_id(self):
            return self.data['GlobalId']

        @property
        def product_id(self):
            return self.data['ProductId']

        @property
        def created(self):
            return datetime.fromtimestamp(self.data['Created'], tz=timezone.utc)

        @property
        def product_name(self):
            for _FKplw in self.data['DataObjects']:
                if _FKplw['Name'] == 'productName':
                    return _FKplw['StringValue']
            return None

        def get_token(self):
            for _DHj2c in self.data['DataObjects']:
                if _DHj2c['Name'] == 'token':
                    return _DHj2c['StringValue']
            return None

        @property
        def expiry(self):
            if not self.data['F1']:
                return None
            if (expiry := _ka33M(self.data, 'Expires')):
                return datetime.fromtimestamp(expiry, tz=timezone.utc)
            return None

        @property
        def user(self):
            return {'email': _ka33M(self.data, 'Customer', 'email')}

        @property
        def max_machines(self):
            return self.data['MaxNoOfMachines']

        @property
        def num_machines(self):
            return len(self.data['ActivatedMachines'])

        def list_machines(self):
            return self.data['ActivatedMachines']

        def validate(self, token, activate=True, raise_on_error=True):
            assert isinstance(token, str)
            _VHkN9, data = _OA7SF(self.product_id, self.key, token, activate=activate, raise_on_error=raise_on_error)
            _kGeKf = _VHkN9['metadata']['licenseStatus']
            if _VHkN9['result'] != 0:
                raise _46nNn(_VHkN9['message'], 'CL_RESULT_ERROR')
            if raise_on_error:
                if not _kGeKf['isValid']:
                    raise _46nNn(*_Pnys3(_kGeKf['reasonForInvalidity']))
                expiry = datetime.fromtimestamp(data['Expires'], tz=timezone.utc)
                if datetime.now(tz=timezone.utc) > expiry + timedelta(minutes=5):
                    _M3QI0 = f'License has expired on {expiry}'
                    raise _46nNn(_M3QI0, 'CL_EXPIRED')
            _6iz6J(data['SignDate'])
            _6iz6J(data['Created'])
            self._data = data
            return _kGeKf

        def prettyprint(self, show_key=False):
            _xDOPB: bool | Literal['unknown'] = 'unknown'
            _YfAee: str | None = None
            if (token := self.get_token()):
                _SfR0J = self.validate(token, activate=False, raise_on_error=False)
                _xDOPB = _ka33M(_SfR0J, 'isValid')
                assert isinstance(_xDOPB, bool)
                if _xDOPB is False:
                    _9ylQq, _YfAee = _Pnys3(_SfR0J['reasonForInvalidity'])
            super()._prettyprint(show_key=show_key, is_valid=_xDOPB, validation_code=_YfAee)

    def _OA7SF(product_id, key, token, activate=True, raise_on_error=True):
        _bvmep = {'token': token, 'ProductId': product_id, 'Key': key, 'Metadata': True, 'ModelVersion': 3, 'Sign': True, 'SignMethod': 1}
        if activate:
            _TjMzq = f'{_vlF9j}/key/Activate'
            _bvmep['MachineCode'] = _m8JHi()
        else:
            _TjMzq = f'{_vlF9j}/key/GetKey'
        _bCqOA = _2lqPu.get(_TjMzq, params=_bvmep)
        _3PNXX = _bCqOA.json()
        if not _bCqOA.ok:
            _B7bJY = f"CryptoLens: {_3PNXX['message']}"
            raise _46nNn(_B7bJY, 'CL_REQUEST_ERROR')
        if raise_on_error:
            if _3PNXX['result'] != 0:
                raise _46nNn(_3PNXX['message'], 'CL_RESULT_ERROR')
            _SizqH = _3PNXX['metadata']['licenseStatus']
            if not _SizqH['isValid']:
                raise _46nNn(*_Pnys3(_SizqH['reasonForInvalidity']))
        _wdf18 = base64.b64decode(_3PNXX['signature'])
        _ZGlfh = base64.b64decode(_3PNXX['licenseKey'])
        _OP5Cf(product_id).verify_key.verify(sig_bytes=_wdf18, msg_bytes=_ZGlfh, padding='pkcs1v15')
        _DNnCn(_bCqOA)
        return (_3PNXX, json.loads(_ZGlfh))

    def _Pnys3(reason_for_invalidity):
        if reason_for_invalidity == 1:
            return ('License expired', 'CL_EXPIRED')
        if reason_for_invalidity == 2:
            return ('License blocked', 'CL_BLOCKED')
        return ('License validation failed', 'CL_FAILED_VALIDATION')

    def _h7L6l():
        _2lqPu.cache.clear()
    if TYPE_CHECKING:
        from datetime import timedelta
        from pathlib import Path
    _dqIWI = _gz7U3 / 'cryptolens'

    def _42NyU(file):
        _66LRd = _uvles.from_file(file, update_if_older_than=None, token=None)
        _olH45 = _66LRd.data['ProductId']
        _daQm3 = _66LRd.data['GlobalId']
        _1lzpb = _dqIWI / str(_olH45) / (str(_daQm3) + '.skm')
        _1lzpb.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(file, _1lzpb)
        return _66LRd

    @_YNQ5D
    def _Cupmm(license_keys_or_ids=None, product_id=None, token=None, update_if_older_than=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _OSmiG = _dqIWI
        if product_id:
            _OSmiG /= str(product_id)
        for _7xjVb in _OSmiG.rglob('*.skm'):
            _mjy3V = _uvles.from_file(_7xjVb, token=token, update_if_older_than=update_if_older_than)
            if license_keys_or_ids is None:
                yield (_7xjVb, _mjy3V)
            else:
                _HrF62 = str(_ka33M(_mjy3V.data, 'GlobalId'))
                if _HrF62 in license_keys_or_ids:
                    license_keys_or_ids.remove(_HrF62)
                    yield (_7xjVb, _mjy3V)
                    continue
                _VPKjZ = _ka33M(_mjy3V.data, 'Key')
                if _VPKjZ in license_keys_or_ids:
                    license_keys_or_ids.remove(_VPKjZ)
                    yield (_7xjVb, _mjy3V)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_VZVT3
    @cache
    def _X49Xh(product_id, token, variable_names=()):
        for _WEX8x in _1rHYr(_s0Jdi(product_id, variable_names), (lic for _, lic in _Cupmm(product_id=product_id, token=token, update_if_older_than=timedelta(days=30)))):
            try:
                lic.validate(token)
            except _46nNn:
                continue
            if product_id != lic.product_id:
                continue
            return lic
        _ydDhI = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _46nNn(_ydDhI, 'CL_NOT_FOUND')

    def _s0Jdi(product_id, var_names):
        for _JmHaR, _pg1Pr, _m5nRR in _wE5nc(var_names):
            yield _uvles.from_key(product_id, _m5nRR)
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_VZVT3
    @cache
    def _pS8bQ(product_code, shared_key, api_key, variable_names=(), cache_force_refresh=False, cache_expire_after=None):
        for _bVx8x in _1rHYr(_n5AwX(product_code, variable_names), _4aZXH(product_code)):
            try:
                _bVx8x.validate(shared_key, api_key, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            except _46nNn:
                continue
            if product_code != _bVx8x.product_code:
                continue
            return _bVx8x
        _olbvR = f'Unable to find valid license for product {product_code}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _46nNn(_olbvR, 'LS_NOT_FOUND')

    def _n5AwX(product_code, var_names):
        for _ltchI, _UjueA, _EgWga in _wE5nc(var_names):
            yield _VuBrH.from_key(product_code, _EgWga)

    def _4aZXH(product_code):
        for _TV3hh in (_yw6e4 / product_code).glob('*.lic'):
            yield _VuBrH.from_file(_TV3hh)
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_VZVT3
    @cache
    def _KS2xh(vendor_id, product_id, variable_names=()):
        _hMSJU(vendor_id)
        for _vsH5n in _1rHYr(_MaI3U(variable_names), _zF3VQ(product_id)):
            try:
                _Jnzja = _vsH5n.validate()
            except _46nNn:
                continue
            except _k8vYk:
                _d4mD0('Invalid signature in SLiC license')
                continue
            if vendor_id != _ka33M(_vsH5n.data, 'vendor', 'id') or product_id != _ka33M(_vsH5n.data, 'product', 'id'):
                continue
            return (_vsH5n.data, _Jnzja)
        _A34MI = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _46nNn(_A34MI, 'SLIC_NOT_FOUND')

    def _MaI3U(var_names):
        for _ZIxP4, _HYjkM, _nHBH1 in _wE5nc(var_names):
            try:
                yield _TtVVf(_nHBH1)
            except _k8vYk:
                _d4mD0(f'Invalid signature in SLiC license in {_nHBH1}')

    def _zF3VQ(product_id):
        for _xutAu, _DohY0 in _eaWss(product_id=product_id):
            try:
                yield _DohY0
            except _k8vYk:
                _d4mD0(f'Invalid signature in SLiC license in {_xutAu}')
    if TYPE_CHECKING:
        pass

    def _D8Kq0(ld):
        if isinstance(ld, str):
            ld = ld.strip()
            if ld.startswith('-----BEGIN LICENSE FILE-----'):
                return _zqnYo(ld)
            if ld.endswith('-V3'):
                _PUT1p = _pY1ZL(ld, 'fp/')
                _L1Kfh = _1Xvnh.from_key(_6CW9x(_PUT1p), _PUT1p)
                _L1Kfh.validate(activate_if_required=True)
                return _2jtBr(_L1Kfh)
            if ld.startswith('key/'):
                _L1Kfh = _X0JV7(ld)
                _3oL23(_L1Kfh)
                return _L1Kfh
            if ld.startswith('slicv1/'):
                return _qEtCA(ld)
        if Path(ld).exists():
            return _i3ImZ(Path(ld))
        _eEN62 = f"Don't know how to handle license_data {ld}"
        raise _NbVz9(_eEN62)

    def _i3ImZ(license_file):
        if not license_file.exists():
            _UD5ZS = f'File {license_file} not found'
            raise _NbVz9(_UD5ZS)
        if license_file.suffix == '.toml':
            return _9RHmr(license_file)
        if license_file.suffix == '.lic':
            with license_file.open() as _5bLOB:
                _H4FNz = _5bLOB.read()
            if _H4FNz.startswith('-----BEGIN LICENSE FILE-----'):
                return _zqnYo(license_file)
            return _1XXLn(license_file)
        if license_file.suffix == '.key':
            _RevKX = _X0JV7.from_file(license_file)
            _3oL23(_RevKX)
            return _RevKX
        if license_file.suffix == '.skm':
            return _42NyU(license_file)
        _UD5ZS = f'Unknown license file format {license_file}'
        raise _NbVz9(_UD5ZS)

    def _N3Sto(license_keys_or_ids=None, product_id=None):
        assert isinstance(license_keys_or_ids, set) or license_keys_or_ids is None
        return _1rHYr(_Cupmm(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _MdzKM(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _HAGwK(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _idr5P(license_keys_or_ids=license_keys_or_ids, product_code=product_id), _eaWss(license_keys_or_ids=license_keys_or_ids, product_id=product_id))

    def _coBLZ():
        _Br3bq()
    _KZGF9 = 0
    _4jYkh = 1
    RichHelpFormatter.styles['argparse.args'] = 'cyan'
    RichHelpFormatter.styles['argparse.groups'] = 'yellow'
    RichHelpFormatter.styles['argparse.metavar'] = 'green'

    def _KAiys(license_data):
        if license_data.startswith('key/'):
            return _X0JV7(license_data)
        if license_data.endswith('-V3'):
            _2jOLm = _pY1ZL(license_data, 'fp/')
            return _1Xvnh.from_key(_6CW9x(_2jOLm), _2jOLm)
        if license_data.startswith('-----BEGIN LICENSE FILE-----'):
            return _rJwrL(license_data, update_if_expired=True, override_original=False)
        if license_data.startswith('slicv1/'):
            return _TtVVf(license_data)
        if Path(license_data).exists():
            _LcA34 = Path(license_data)
            if _LcA34.suffix == '.toml':
                return _KAiys(_30Xfn(_LcA34))
            if _LcA34.suffix == '.lic':
                return _rJwrL(_LcA34, update_if_expired=True, override_original=False)
            if _LcA34.suffix == '.skm':
                return _uvles.from_file(_LcA34, token=None)
            _PrEtv = f'Unknown license format in file {_LcA34}'
            raise RuntimeError(_PrEtv)
        _PrEtv = 'Unknown key type'
        raise RuntimeError(_PrEtv)

    def _9M762(_):
        _OyNwR(_m8JHi())
        return _KZGF9

    def _H3xLN(license_keys_or_ids, raw=False, show_keys=False):
        assert isinstance(license_keys_or_ids, set)
        try:
            _n7mql = list(_N3Sto(license_keys_or_ids=license_keys_or_ids or None))
        except _NbVz9 as e:
            _8HHq0(str(e))
            return _4jYkh
        if license_keys_or_ids:
            for _wUCSU in license_keys_or_ids:
                try:
                    _n7mql.append((None, _KAiys(_wUCSU)))
                except RuntimeError:
                    _8HHq0(f'{_wUCSU}: No such license.')
                    return _4jYkh
        try:
            for _w2fBp, _Y5SnD in _n7mql:
                if raw:
                    _OyNwR(_Y5SnD.data)
                else:
                    _Y5SnD.prettyprint(show_key=show_keys)
        except Exception as e:
            _8HHq0(str(e))
            return _4jYkh
        return _KZGF9

    def _8QMXE(license_keys_or_ids, automatic_yes=False):
        license_keys_or_ids = set(license_keys_or_ids)
        if license_keys_or_ids:
            license_keys_or_ids = {k.strip().replace('\n', '') for k in license_keys_or_ids}
        try:
            _sdkhm = list(_N3Sto(license_keys_or_ids=license_keys_or_ids))
        except _NbVz9 as e:
            _8HHq0(str(e))
            return _4jYkh
        if license_keys_or_ids:
            _4KgvU = ', '.join(license_keys_or_ids)
            _3VEhf = '' if len(license_keys_or_ids) == 1 else 's'
            _8HHq0(f'Could not find the following license{_3VEhf}: {_4KgvU}')
            return _4jYkh
        for _2BemX, _64JHW in _sdkhm:
            _64JHW.prettyprint()
        if not _sdkhm:
            return _KZGF9
        _3VEhf = '' if len(_sdkhm) == 1 else 's'
        if automatic_yes or Confirm.ask(f'Uninstall the above license{_3VEhf} and deactivate machine?'):
            for _HwiPO, _6GDpe in _sdkhm:
                try:
                    _6GDpe.deactivate({_m8JHi()})
                except Exception:
                    pass
            for _tEC0u, _b8yBI in _sdkhm:
                _tEC0u.unlink()
            if not any(_tEC0u.parent.iterdir()):
                _tEC0u.parent.rmdir()
            _OyNwR('Removed.', style='green')
            return _KZGF9
        _OyNwR('Abort.')
        return _4jYkh

    def _uccqC(license_data):
        try:
            _GUwXA = _D8Kq0(license_data)
        except Exception as e:
            _8HHq0(str(e))
            return _4jYkh
        _GUwXA.prettyprint()
        return _KZGF9

    def _Nms8g(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _GK1nW = list(_N3Sto(license_keys_or_ids={license_key_or_id}))
        except _NbVz9 as e:
            _8HHq0(str(e))
            return _4jYkh
        if not _GK1nW:
            _XraQ2 = f"Couldn't find license with key or ID {license_key_or_id}"
            _8HHq0(_XraQ2)
            return _4jYkh
        _cDYwi = _m8JHi()
        if not machine_fingerprints:
            machine_fingerprints = {_cDYwi}
        _OyNwR()
        for _uDsoS in machine_fingerprints:
            _OyNwR(_uDsoS, style='bold')
        _OyNwR()
        if automatic_yes or Confirm.ask(f'Activate the above machine(s) for license {license_key_or_id}?'):
            for _hLFEZ, _ZHttT in _GK1nW:
                try:
                    _ZHttT.activate()
                except (RuntimeError, _46nNn) as e:
                    _8HHq0(str(e))
                    return _4jYkh
                _ZHttT.prettyprint()
        return _KZGF9

    def _nF4Bj(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _OMizl = list(_N3Sto(license_keys_or_ids={license_key_or_id}))
        except _NbVz9 as e:
            _8HHq0(str(e))
            return _4jYkh
        if not _OMizl:
            _AeyNo = f"Couldn't find license with key or ID {license_key_or_id}"
            _8HHq0(_AeyNo)
            return _4jYkh
        _PMKSs = _m8JHi()
        if not machine_fingerprints:
            machine_fingerprints = {_PMKSs}
        _OyNwR()
        for _jYjgR in machine_fingerprints:
            _OyNwR(_jYjgR, style='bold')
        _OyNwR()
        if automatic_yes or Confirm.ask(f'Deactivate the above machine(s) for license {license_key_or_id}?'):
            for _EuykM, _8QjIV in _OMizl:
                try:
                    _8QjIV.deactivate(machine_fingerprints)
                except Exception as e:
                    _8HHq0(str(e))
                    return _4jYkh
                _8QjIV.prettyprint()
        return _KZGF9

    def _yl8o3(argv=None):
        _HdWx0 = argparse.ArgumentParser(description='Stonefish License Manager.', formatter_class=RichHelpFormatter)
        _HdWx0.add_argument('--version', '-v', action='version', version=_uKIxC(), help='display version information')
        _QBKhI = _HdWx0.add_subparsers(title='subcommands', required=True)
        _JGnKK = _QBKhI.add_parser('versions', help='Display version information, including dependencies', aliases=['vv'], formatter_class=_HdWx0.formatter_class)
        _JGnKK.set_defaults(func=lambda _nRoVV: _9Dg2E())
        _jTZqt = _QBKhI.add_parser('list', help='List installed licenses', aliases=['ls', 'show', 'info'], formatter_class=_HdWx0.formatter_class)
        _jTZqt.add_argument('-r', '--raw', action='store_true', help='Show raw license data')
        _jTZqt.add_argument('-k', '--show-keys', action='store_true', help='Show license keys')
        _jTZqt.add_argument('license_ids_or_keys', type=str, nargs='*', help='License IDs or keys (optional)')
        _jTZqt.set_defaults(func=lambda _dmAC5: _H3xLN(set(_dmAC5.license_ids_or_keys), _dmAC5.raw, _dmAC5.show_keys))
        _9kHh6 = _QBKhI.add_parser('install', help='Install (and activate) licenses', aliases=['add', 'a'], formatter_class=_HdWx0.formatter_class)
        _9kHh6.add_argument('license_file', type=str, help='License file')
        _9kHh6.set_defaults(func=lambda _AeWhS: _uccqC(str(_AeWhS.license_file)))
        _VgmOp = _QBKhI.add_parser('uninstall', help='Uninstall (and deactivate) licenses', aliases=['remove', 'rm', 'delete', 'del'], formatter_class=_HdWx0.formatter_class)
        _VgmOp.add_argument('license_key_or_id', type=str, nargs='+', help='License keys or IDs')
        _VgmOp.add_argument('-y', '--yes', action='store_true', help='Automatic yes to prompts')
        _VgmOp.set_defaults(func=lambda _EuB3L: _8QMXE(_EuB3L.license_key_or_id, _EuB3L.yes))
        _9kHh6 = _QBKhI.add_parser('activate', help='Activate machine for license', formatter_class=_HdWx0.formatter_class)
        _9kHh6.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _9kHh6.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _9kHh6.set_defaults(func=lambda _74bI1: _Nms8g(_74bI1.license_file_or_id_or_key, set(_74bI1.machine_fingerprints)))
        _9kHh6 = _QBKhI.add_parser('deactivate', help='Deactivate machine for license', formatter_class=_HdWx0.formatter_class)
        _9kHh6.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _9kHh6.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _9kHh6.set_defaults(func=lambda _qi7vz: _nF4Bj(_qi7vz.license_file_or_id_or_key, set(_qi7vz.machine_fingerprints)))
        _jTZqt = _QBKhI.add_parser('fingerprint', help='Display machine fingerprint', aliases=['fp'], formatter_class=_HdWx0.formatter_class)
        _jTZqt.set_defaults(func=_9M762)
        _duYYB = _QBKhI.add_parser('refresh', help='Refresh license files and cache', formatter_class=_HdWx0.formatter_class)
        _duYYB.set_defaults(func=_13OoV)
        _Z1auC = _QBKhI.add_parser('cache', help='Manage the cache', formatter_class=_HdWx0.formatter_class)
        _Fd1jV = _Z1auC.add_subparsers(title='subcommands', required=True)
        _RANVr = _Fd1jV.add_parser('clear', help='Remove all items from the cache', aliases=['clean'], formatter_class=_HdWx0.formatter_class)
        _RANVr.set_defaults(func=_TCJmT)
        _Unr7q = _Fd1jV.add_parser('dir', help='Show the cache directory', formatter_class=_HdWx0.formatter_class)
        _Unr7q.set_defaults(func=_Ure5o)
        _qi7vz = _HdWx0.parse_args(argv)
        return _qi7vz.func(_qi7vz)

    def _uKIxC():
        _aVkg6 = _VyfsH('stonefish-license-manager')
        return '\n'.join([f'Stonefish License Manager {_aVkg6} [Python {_bwg8W()}]'])

    def _9Dg2E():
        for _sFkZe in python_package_info.yield_info_lines('stonefish-license-manager'):
            print(_sFkZe)

    def _13OoV(_):
        _fujdo = _Br3bq()
        _OyNwR(f'Refreshed {_fujdo} installed licenses')
        _TCJmT(_)
        return _KZGF9

    def _TCJmT(_):
        _1xo1X()
        _h7L6l()
        _m0LZZ()
        return _KZGF9

    def _Ure5o(_):
        _OyNwR(_Yb1rt)
        return _KZGF9
_ZbVz8()
del _ZbVz8
