def _eYinw(f):
    def _kWsfI(*args, **kwargs):
        return f(*args, **kwargs)
    _kWsfI.__module__ = f.__module__
    _kWsfI.__name__ = f.__name__
    _kWsfI.__doc__ = f.__doc__
    _kWsfI.__dict__.update(f.__dict__)
    f.__refcalls__ = 0
    return _kWsfI

@_eYinw
def _M926w():
    global _mX1yl, _13L5B, _mh6oC, _2j709, _mSZtN, _FVu1e, _8Lkp3, _4mVXj, _RTMWE, _GaeeQ, _GubD7, _5hgEd, _6NJiw, _kYot3, _3PZvv, _KYYgQ, _BFip4, _GjaQY, _aHY8a, _2Pkos, _Xd9mg, _4a5FT, _cxXKq, _Mcv73, _gZJwc, _Vw3QP, _u7ZBC, _9qv3F, _YLTBa, _maWwn, _2pLyt, _ZKemR, _T2xAh, _3G4AH, _C0Y45, _3mIZM, _dbtt6, _RaYUN, _qLGoy, _hSlNs, _9wEqm, _8JuUu, _rnT9f, _qhjLD, _KsfW2, _t8btf, _ZwR51
    from __future__ import annotations
    from cryptography.exceptions import InvalidSignature
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from dataclasses import dataclass
    from datetime import datetime, timedelta, timezone
    from email.utils import parsedate_to_datetime
    from importlib import metadata
    from importlib.util import find_spec
    from pathlib import Path
    from requests import Request
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm, Prompt
    from rich.table import Table
    from rich.text import Text
    from rich_argparse import RichHelpFormatter
    from sys import version_info
    from typing import Any, Literal, Protocol, TYPE_CHECKING
    from urllib.parse import quote, urlsplit
    from wsgiref.handlers import format_date_time
    import argparse, base64, binascii, hashlib, hmac, json, logging, machineid, multiprocessing, os, platform, platformdirs, python_package_info, re, requests, requests_cache, shutil, socket, sys, time, uuid

    def _KDNlx(license_string):
        assert not license_string.startswith('key/')
        if license_string.startswith('fp/'):
            return (license_string[3:], True)
        return (license_string, False)

    def _mX1yl(string, prefix, suffix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix).removesuffix(suffix)
        if string.startswith(prefix):
            string = string[len(prefix):]
        if string.endswith(suffix):
            string = string[:-len(suffix)]
        return string
    _1OdS3 = Console(highlight=True)
    _fD90Z = Console(stderr=True, style='yellow', highlight=False)
    _TPq2N = Console(stderr=True, style='red', highlight=False)

    def _13L5B(msg='', **_KvUUH):
        _1OdS3.print(msg, **_KvUUH)

    def _knJvs(msg):
        _fD90Z.print(f'Warning: {msg}')

    def _94mhs(msg):
        _TPq2N.print(f'\nError: {msg}')

    class _mh6oC(Exception):

        def __init__(self, message, code):
            super().__init__(message)
            self.code = code

        def show(self):
            _94mhs(f'{self} ({self.code})')

    class _2j709(Exception):
        pass

    class _eSHOm(Exception):
        pass
    _gciJB = platformdirs.user_data_path('slim')
    _4JBOP = platformdirs.user_cache_path('slim')

    def _ULPFF(package, fallback='unknown'):
        try:
            return metadata.version(package)
        except metadata.PackageNotFoundError:
            return fallback

    def _iNLlV():
        return f'{version_info.major}.{version_info.minor}.{version_info.micro}'

    def _mSZtN(dct, *_e2i0G, default=None):
        for _80F3Z in _e2i0G:
            try:
                dct = dct[_80F3Z]
            except (KeyError, TypeError, IndexError):
                return default
        return dct

    def _muC1y(obj, eps=timedelta(minutes=5)):
        if abs(obj - datetime.now(tz=timezone.utc)) > eps:
            _1Ew91 = 'Error code E044'
            raise RuntimeError(_1Ew91)

    def _wAVJC(obj, eps=timedelta(minutes=5)):
        if obj > datetime.now(tz=timezone.utc) + eps:
            _L3X2h = 'Error code E045'
            raise RuntimeError(_L3X2h)

    def _8xsDt(ts, **_ouDoB):
        _wAVJC(datetime.fromtimestamp(ts, tz=timezone.utc), **_ouDoB)

    def _FVu1e(res):
        _bINSW = parsedate_to_datetime(res.headers['Date'])
        if getattr(res, 'from_cache', False):
            _wAVJC(_bINSW)
        else:
            _muC1y(_bINSW)

    def _epe3G(td):
        _HYiFY = abs(td)
        if _HYiFY < timedelta(seconds=1):
            return 'just now'
        _pr8fD = td > timedelta(0)
        for _Zgg70, _AEQas, _9Jglf in [('second', _HYiFY.seconds, timedelta(minutes=1)), ('minute', round(_HYiFY.seconds / 60), timedelta(hours=1)), ('hour', round(_HYiFY.seconds / 3600), timedelta(days=1))]:
            if _HYiFY < _9Jglf:
                _W2f41 = '' if _AEQas == 1 else 's'
                return f'in {_AEQas} {_Zgg70}{_W2f41}' if _pr8fD else f'{_AEQas} {_Zgg70}{_W2f41} ago'
        if _HYiFY.days < 100:
            _AEQas = _HYiFY.days
            if _AEQas == 0:
                return 'today'
            if _pr8fD:
                if _AEQas == 1:
                    return 'tomorrow'
                return f'in {_AEQas} days'
            if _AEQas == 1:
                return 'yesterday'
            return f'{_AEQas} days ago'
        if _HYiFY.days < 365:
            _AEQas = round(_HYiFY.days / 30)
            _W2f41 = '' if _AEQas == 1 else 's'
            if _pr8fD:
                return f'in {_AEQas} month{_W2f41}'
            return f'{_AEQas} month{_W2f41} ago'
        _AEQas = round(_HYiFY.days / 365)
        _W2f41 = '' if _AEQas == 1 else 's'
        if _pr8fD:
            return f'in {_AEQas} year{_W2f41}'
        return f'{_AEQas} year{_W2f41} ago'

    def _3vA09(var_names):
        assert isinstance(var_names, (list, tuple))
        for _x5v0E in var_names:
            assert isinstance(_x5v0E, str)
            assert _x5v0E != ''
        for _OPV2R, _zFNdS in [('global', globals()), ('environment', os.environ)]:
            for _UAVce in var_names:
                if _UAVce in _zFNdS:
                    yield (_OPV2R, _UAVce, _zFNdS[_UAVce])

    def _Ve6k2(string, k):
        return '\n'.join((string[_nlYD0:_nlYD0 + k] for _nlYD0 in range(0, len(string), k)))

    def _8Lkp3(string):
        if sys.version_info >= (3, 11):
            return datetime.fromisoformat(string)
        try:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S.%f%z')
        except ValueError:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S%z')

    def _nUov3(string, prefix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix)
        if string.startswith(prefix):
            return string[len(prefix):]
        return string

    def _GcxE1(*_uyJyB):
        for _gucZ3 in _uyJyB:
            yield from _gucZ3

    def _0y24V(function):

        def _0GqGW(*_Bssep, **_e4pgz):
            _Bssep = [tuple(_eKK8P) if isinstance(_eKK8P, list) else _eKK8P for _eKK8P in _Bssep]
            _e4pgz = {key: tuple(value) if isinstance(value, list) else value for key, value in _e4pgz.items()}
            return function(*_Bssep, **_e4pgz)
        _0GqGW.cache_clear = function.cache_clear
        return _0GqGW

    def _7YIY4(gen):
        cache = set()

        def _j6plw(*_i7lF1, **_80NVD):
            for _bSUps in gen(*_i7lF1, **_80NVD):
                if _bSUps in cache:
                    continue
                yield _bSUps
                cache.add(_bSUps)
        return _j6plw

    def _TlrD4(key):
        if key.startswith('DEMO'):
            return '1fddcec8-8dd3-4d8d-9b16-215cac0f9b52'
        return '109c23d2-6cdd-4faf-bd8a-96c242733638'
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @cache
    def _4mVXj():
        if _TgDDD():
            return 'google.colab'
        _2Mg4Z = _PbQsr()
        if _2Mg4Z:
            return f'github-actions/{_2Mg4Z}'
        _cxEBW = _NkjIL()
        if _cxEBW:
            return f'travis-ci/{_cxEBW}'
        _aYlo5 = _eTxNf()
        if _aYlo5:
            return f'circle-ci/{_aYlo5}'
        _8TkDB = _jCDkU()
        if _8TkDB:
            return 'gitlab-ci/{gitlab_project_namespace}'
        if _DSFOW():
            return 'jenkins'
        if _oC3YE():
            return 'docker'
        return machineid.id().strip()

    def _oC3YE():
        _V4usi = Path('/proc/self/cgroup')
        return Path('/.dockerenv').is_file() or (_V4usi.is_file() and 'docker' in _V4usi.read_text())

    def _TgDDD():
        try:
            _1dux9 = find_spec('google.colab')
        except ModuleNotFoundError:
            return False
        return _1dux9 is not None

    def _PbQsr():
        if _lcITX([('CI', 'true'), ('GITHUB_ACTIONS', 'true'), 'GITHUB_ACTION', 'GITHUB_ACTION_REPOSITORY', 'GITHUB_ACTOR', 'GITHUB_ACTOR_ID', 'GITHUB_API_URL', 'GITHUB_BASE_REF', 'GITHUB_ENV', 'GITHUB_EVENT_NAME', 'GITHUB_EVENT_PATH', 'GITHUB_GRAPHQL_URL', 'GITHUB_HEAD_REF', 'GITHUB_JOB', 'GITHUB_PATH', 'GITHUB_REF', 'GITHUB_REF_NAME', 'GITHUB_REF_PROTECTED', 'GITHUB_REF_TYPE', 'GITHUB_REPOSITORY', 'GITHUB_REPOSITORY_ID', 'GITHUB_REPOSITORY_OWNER', 'GITHUB_REPOSITORY_OWNER_ID', 'GITHUB_RETENTION_DAYS', 'GITHUB_RUN_ATTEMPT', 'GITHUB_RUN_ID', 'GITHUB_RUN_NUMBER', 'GITHUB_SERVER_URL', 'GITHUB_SHA', 'GITHUB_STEP_SUMMARY', 'GITHUB_WORKFLOW', 'GITHUB_WORKFLOW_REF', 'GITHUB_WORKFLOW_SHA', 'GITHUB_WORKSPACE', 'RUNNER_ARCH', 'RUNNER_NAME', 'RUNNER_OS', 'RUNNER_TEMP', 'RUNNER_TOOL_CACHE']):
            return os.environ['GITHUB_REPOSITORY_OWNER']
        return None

    def _NkjIL():
        if _lcITX([('CI', 'true'), ('TRAVIS', 'true'), ('CONTINUOUS_INTEGRATION', 'true'), ('HAS_JOSH_K_SEAL_OF_APPROVAL', 'true'), ('USER', 'travis'), ('RAILS_ENV', 'test'), ('RACK_ENV', 'test'), ('MERB_ENV', 'test'), 'TRAVIS_ALLOW_FAILURE', 'TRAVIS_APP_HOST', 'TRAVIS_BRANCH', 'TRAVIS_BUILD_DIR', 'TRAVIS_BUILD_ID', 'TRAVIS_BUILD_NUMBER', 'TRAVIS_BUILD_WEB_URL', 'TRAVIS_COMMIT', 'TRAVIS_COMMIT_MESSAGE', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_COMPILER', 'TRAVIS_DEBUG_MODE', 'TRAVIS_DIST', 'TRAVIS_REPO_SLUG']):
            _dMwrO, _dqmy0 = os.environ['TRAVIS_REPO_SLUG'].split('/')
            return _dMwrO
        return None

    def _eTxNf():
        if _lcITX([('CI', 'true'), ('CIRCLE', 'true'), 'CIRCLE_BRANCH', 'CIRCLE_BUILD_NUM', 'CIRCLE_BUILD_URL', 'CIRCLE_JOB', 'CIRCLE_NODE_INDEX', 'CIRCLE_NODE_TOTAL', 'CIRCLE_OIDC_TOKEN', 'CIRCLE_OIDC_TOKEN_V2', 'CIRCLE_PR_NUMBER', 'CIRCLE_PR_REPONAME', 'CIRCLE_PR_USERNAME', 'CIRCLE_PROJECT_REPONAME', 'CIRCLE_PROJECT_USERNAME', 'CIRCLE_PULL_REQUEST', 'CIRCLE_PULL_REQUESTS', 'CIRCLE_REPOSITORY_URL', 'CIRCLE_SHA1', 'CIRCLE_TAG', 'CIRCLE_WORKFLOW_ID', 'CIRCLE_WORKFLOW_JOB_ID', 'CIRCLE_WORKFLOW_WORKSPACE_ID', 'CIRCLE_WORKING_DIRECTORY', 'CIRCLE_INTERNAL_TASK_DATA']):
            return os.environ['CIRCLE_PROJECT_USERNAME']
        return None

    def _jCDkU():
        if _lcITX(['CHAT_CHANNEL', 'CHAT_INPUT', 'CHAT_USER_ID', 'CI', 'CI_API_V4_URL', 'CI_API_GRAPHQL_URL', 'CI_BUILDS_DIR', 'CI_COMMIT_AUTHOR', 'CI_COMMIT_BEFORE_SHA', 'CI_COMMIT_BRANCH', 'CI_COMMIT_DESCRIPTION', 'CI_COMMIT_MESSAGE', 'CI_COMMIT_REF_NAME', 'CI_COMMIT_REF_PROTECTED', 'CI_COMMIT_REF_SLUG', 'CI_COMMIT_SHA', 'CI_COMMIT_SHORT_SHA', 'CI_COMMIT_TIMESTAMP', 'CI_COMMIT_TITLE', 'CI_CONCURRENT_ID', 'CI_CONCURRENT_PROJECT_ID', 'CI_CONFIG_PATH', 'CI_DEBUG_TRACE', 'CI_DEBUG_SERVICES', 'CI_DEFAULT_BRANCH', 'CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_PASSWORD', 'CI_DEPENDENCY_PROXY_SERVER', 'CI_DEPENDENCY_PROXY_USER', 'CI_DEPLOY_FREEZE', ('GITLAB_CI', 'true'), 'GITLAB_FEATURES', 'GITLAB_USER_EMAIL', 'GITLAB_USER_ID', 'GITLAB_USER_LOGIN', 'GITLAB_USER_NAME']):
            return os.environ['CI_PROJECT_NAMESPACE']
        return None

    def _DSFOW():
        return _lcITX(['BUILD_NUMBER', 'BUILD_ID', 'BUILD_DISPLAY_NAME', 'JOB_NAME', 'BUILD_TAG', 'EXECUTOR_NUMBER', 'NODE_NAME', 'NODE_LABELS', 'WORKSPACE', 'JENKINS_HOME', 'JENKINS_URL', 'BUILD_URL', 'JOB_URL'])

    def _lcITX(keys):
        for _lCoA8 in keys:
            if isinstance(_lCoA8, str):
                if _lCoA8 not in os.environ:
                    return False
            else:
                assert isinstance(_lCoA8, tuple)
                _GfxlK, _9NlI5 = _lCoA8
                if _mSZtN(os.environ, _GfxlK) != _9NlI5:
                    return False
        return True

    class _RTMWE(Protocol):
        key_type: str

        @property
        def data(self):
            ...

        @property
        def key(self):
            ...

        @property
        def product_name(self):
            ...

        @property
        def product_id(self):
            ...

        @property
        def vendor_name(self):
            ...

        @property
        def license_id(self):
            ...

        @property
        def user(self):
            ...

        @property
        def created(self):
            ...

        @property
        def expiry(self):
            ...

        @property
        def max_machines(self):
            ...

        @property
        def num_machines(self):
            ...

        @property
        def usage_type(self):
            return None

        @property
        def activations(self):
            return (None, None)

        def list_machines(self):
            ...

        def prettyprint(self, show_key=False):
            ...

        def _prettyprint(self, is_valid, validation_code=None, show_key=False):
            _2E9di = Table(box=None, padding=(0, 4, 0, 0), show_header=False)
            if self.product_name:
                _2E9di.add_row('Product', Text(self.product_name, style='cyan'))
            else:
                _2E9di.add_row('Product ID', str(self.product_id))
            if self.vendor_name:
                _2E9di.add_row('Vendor', self.vendor_name)
            if self.license_id:
                _2E9di.add_row('License ID', str(self.license_id))
            if show_key and self.key:
                _2E9di.add_row('Key', self.key)
            if self.usage_type:
                _2E9di.add_row('Usage type', Text(self.usage_type.title(), style='blue'))
            _osQR9 = None
            if is_valid is True:
                _2E9di.add_row('Valid', Text('True', style='green'))
                _osQR9 = 'green'
            elif is_valid is False:
                _5T4yk = 'False'
                if validation_code:
                    _5T4yk += f' ({validation_code})'
                _2E9di.add_row('Valid', Text(_5T4yk, style='red'))
                _osQR9 = 'red'
            else:
                assert is_valid == 'unknown'
                _5T4yk = 'Unknown'
                if validation_code:
                    _5T4yk += f' ({validation_code})'
                _2E9di.add_row('Valid', Text(_5T4yk, style='yellow'))
                _osQR9 = 'bright_black'
            if (email := _mSZtN(self.user, 'email')):
                _2E9di.add_row('User', email)
            if self.created:
                _2E9di.add_row('Created', self.created.strftime('%Y-%m-%d'))
            _HruWh = datetime.now(tz=timezone.utc)
            if self.expiry:
                _yfrTH = self.expiry - _HruWh
                if _yfrTH < timedelta(0):
                    _6MwWc = 'red'
                    _osQR9 = 'red'
                elif _yfrTH.days < 30:
                    _6MwWc = 'yellow'
                    if _osQR9 != 'red':
                        _osQR9 = 'yellow'
                else:
                    _6MwWc = None
                _2E9di.add_row('Expiry', Text(f"{self.expiry.strftime('%Y-%m-%d')} ({_epe3G(_yfrTH)})", style=_6MwWc))
            _oxjYj, _zw4Ou = self.activations
            if _oxjYj is not None:
                _wqJgX = None
                _5T4yk = str(_oxjYj)
                if _zw4Ou is not None:
                    if _oxjYj >= _zw4Ou:
                        _wqJgX = 'yellow'
                    _5T4yk += f'/{_zw4Ou}'
                _2E9di.add_row('Activations', Text(_5T4yk, style=_wqJgX))
            if self.num_machines is not None:
                _5T4yk = str(self.num_machines)
                if self.max_machines is not None:
                    _5T4yk += f'/{self.max_machines}'
                _2E9di.add_row('Seats used', _5T4yk)
            for _S7bKw, _ON1gG in enumerate(self.list_machines()):
                assert isinstance(_ON1gG, dict)
                _Jh4C9 = _mSZtN(_ON1gG, 'hostname') or f'machine {_S7bKw}'
                _Ykjen = []
                _UYqHC = False
                if (fp := _mSZtN(_ON1gG, 'fingerprint')):
                    _Ykjen.append(fp)
                    _UYqHC = fp == _4mVXj()
                _vtsF8 = _Jh4C9
                if _UYqHC:
                    _vtsF8 = f'[bold]{_vtsF8}[/]'
                if _Ykjen:
                    _vtsF8 += f" ({', '.join(_Ykjen)})"
                _2E9di.add_row('Machines' if _S7bKw == 0 else '', _vtsF8)
            _nPRp1 = Panel(_2E9di, title_align='left', border_style=_osQR9)
            _13L5B(_nPRp1)

    def _GaeeQ(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _62wxo(serialization.load_pem_public_key(key_bytes))

    def _GubD7(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _62wxo(serialization.load_der_public_key(key_bytes))

    def _gqPrH(key_bytes):
        _81Jdh = _GubD7(key_bytes)
        assert isinstance(_81Jdh, _6NJiw)
        return _81Jdh

    def _62wxo(key):
        if isinstance(key, Ed25519PublicKey):
            return _5hgEd(key)
        if isinstance(key, RSAPublicKey):
            return _6NJiw(key)
        _GJRvx = 'Unknown key'
        raise ValueError(_GJRvx)

    class _LIeeZ:
        pass

    class _5hgEd(_LIeeZ):
        alg = 'ed25519'

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(Ed25519PublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, Ed25519PublicKey)
            self.key = key

        def verify(self, sig_bytes, msg_bytes):
            try:
                self.key.verify(sig_bytes, msg_bytes)
            except InvalidSignature:
                _FAbMA = 'SLiM: Ed25519 signature verification error. (Wrong key?)'
                raise _2j709(_FAbMA) from None

        def verify_response(self, res):
            try:
                _xhoR0 = res.created_at.replace(tzinfo=timezone.utc)
            except AttributeError:
                _xhoR0 = datetime.now(tz=timezone.utc)
            if _xhoR0 < datetime(2024, 2, 7, 0, 0, tzinfo=timezone.utc):
                return
            alg, _W6lAK, _DmwYN = _5LPq5(res)
            if alg.lower() != self.alg:
                _W6lAK = f'Expected alg {self.alg}, got {alg}'
                raise ValueError(_W6lAK)
            self.verify(_DmwYN, _W6lAK)

    class _6NJiw(_LIeeZ):

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(RSAPublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, RSAPublicKey)
            self.key = key
            self.pad_pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH)
            self.pad_pkcs1v15 = padding.PKCS1v15()

        def verify(self, sig_bytes, msg_bytes, padding):
            if padding.lower() == 'pss':
                _Uimez = self.pad_pss
            elif padding.lower() == 'pkcs1v15':
                _Uimez = self.pad_pkcs1v15
            else:
                _Wf15d = f'Unknown padding {padding}'
                raise ValueError(_Wf15d)
            try:
                self.key.verify(sig_bytes, msg_bytes, _Uimez, hashes.SHA256())
            except InvalidSignature:
                _Wf15d = 'SLiM: RSA signature verification error. (Wrong key?)'
                raise _2j709(_Wf15d) from None

        def verify_response(self, *_xZYDP, **_NkPKY):
            _2oewB, _A28dz, _ywUZA = _5LPq5(*_xZYDP, **_NkPKY)
            if _2oewB.lower() == 'rsa-pss-sha256':
                self.verify(_ywUZA, _A28dz, padding='pss')
                return
            if _2oewB.lower() == 'rsa-sha256':
                self.verify(_ywUZA, _A28dz, padding='pkcs1v15')
                return
            _A28dz = f'Unknown RSA alg {_2oewB}'
            raise ValueError(_A28dz)

    def _5LPq5(res):
        _iYZWi = hashlib.sha256(res.content).digest()
        _w1CqE = base64.b64encode(_iYZWi).decode()
        if f'sha-256={_w1CqE}' != res.headers['Digest']:
            _Yw1gV = 'SLiM: Invalid response digest'
            raise RuntimeError(_Yw1gV)
        _9yRwM = urlsplit(res.request.url)
        _UZteX = '\n'.join([f'(request-target): {res.request.method.lower()} {res.request.path_url}', f'host: {_9yRwM.netloc}', f"date: {res.headers['Date']}", f'digest: sha-256={_w1CqE}']).encode()
        _eKAXr = _OXr5p(res.headers['Keygen-Signature'])
        return (_eKAXr['algorithm'], _UZteX, base64.b64decode(_eKAXr['signature']))

    def _OXr5p(string):
        _VQDQ0 = {}
        for _w0UqT in re.split(',\\s*', string):
            _Ya99y = re.match('([^=]+)="([^"]+)"', _w0UqT)
            assert _Ya99y
            _VQDQ0[_Ya99y.group(1)] = _Ya99y.group(2)
        return _VQDQ0

    class _oEVjb:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        vendor_id = '6697c7f2-ad29-42c6-8b78-8ddb2a56bc0b'
        verify_key = _5hgEd.from_hex('43157566ccbbe4f46fe5f02d6c1d363a3a502c3dbee36c22cf266e4015bdc23e')
    _jqHjo = {vendor.vendor_id: vendor for vendor in [_oEVjb]}

    def _6Zmn8(vendor_id):
        try:
            return _jqHjo[vendor_id]
        except KeyError:
            _xn0wa = f"Cannot use SLiM with vendor ID {vendor_id}. If you're a vendor and like to use the Stonefish, contact <support@mondaytech.com>."
            raise _mh6oC(_xn0wa, 'KG_VENDOR_ERROR') from None

    class _kYot3(_RTMWE):
        key_type = 'Stonefish License Creator'

        @classmethod
        def from_file(cls, path, *_yTbwX, **_5YWhf):
            path = Path(path)
            with path.open() as _sEOmw:
                _YXjKC = _sEOmw.read().strip().replace('\n', '')
            return cls(_YXjKC, *_yTbwX, **_5YWhf)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _vFAyX = 'slicv1/'
            if not key.startswith(_vFAyX):
                _L4jCH = f'Expected prefix {_vFAyX!r}, got {key[:len(_vFAyX)]!r}...'
                raise ValueError(_L4jCH)
            self._key = key
            self.signing_data, _KNNGi = self._key.split('.')
            self.enc_sig = base64.urlsafe_b64decode(_KNNGi)
            _8n2uf = self.signing_data[len(_vFAyX):]
            self._data = json.loads(base64.urlsafe_b64decode(_8n2uf))
            _lIWjw = _mSZtN(self._data, 'vendor', 'id')
            if not _lIWjw:
                _L4jCH = 'Key lacks vendor ID'
                raise _mh6oC(_L4jCH, 'SLIC_MISSING_VENDOR_ID')
            self.vendor = _6Zmn8(_lIWjw)
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            return _8Lkp3(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _mSZtN(self.data, 'license', 'expiry')):
                return _8Lkp3(expiry)
            return None

        def list_machines(self):
            return _mSZtN(self.data, 'machines', default=[])

        @property
        def product_name(self):
            return _mSZtN(self.data, 'product', 'name')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def user(self):
            return _mSZtN(self.data, 'user', default={})

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        def validate(self, raise_on_error=True):
            try:
                self.vendor.verify_key.verify(self.enc_sig, self.signing_data.encode())
            except _2j709:
                if raise_on_error:
                    raise
                return {'valid': False, 'code': 'SIGNATURE_ERROR', 'detail': 'Signature could not be verified'}
            _zITgL = datetime.now(tz=timezone.utc)
            _wbxMU = _8Lkp3(self.data['license']['created'])
            if _wbxMU > _zITgL:
                _mt3HG = 'SLIC_E043'
                _L6jQU = 'Unknown license error'
                if raise_on_error:
                    raise _mh6oC(_L6jQU, _mt3HG)
                return {'valid': False, 'code': _mt3HG, 'detail': _L6jQU}
            _J0nLv = _8Lkp3(expiry) if (expiry := _mSZtN(self.data, 'license', 'expiry')) else None
            if _J0nLv:
                if _wbxMU > _J0nLv:
                    _mt3HG = 'SLIC_E044'
                    _L6jQU = 'Unknown license error'
                    if raise_on_error:
                        raise _mh6oC(_L6jQU, _mt3HG)
                    return {'valid': False, 'code': _mt3HG, 'detail': _L6jQU}
                if _zITgL > _J0nLv:
                    _mt3HG = 'SLIC_EXPIRED'
                    _L6jQU = f'License has expired on {_J0nLv}'
                    if raise_on_error:
                        raise _mh6oC(_L6jQU, _mt3HG)
                    return {'valid': False, 'code': _mt3HG, 'detail': _L6jQU}
            _QtUSA = _mSZtN(self.data, 'machines')
            if _QtUSA:
                _32DhX = _4mVXj()
                if _32DhX not in _QtUSA:
                    _mt3HG = 'SLIC_MACHINE_ERROR'
                    _L6jQU = f'License not valid on this machine (fingerprint {_32DhX})'
                    if raise_on_error:
                        raise _mh6oC(_L6jQU, _mt3HG)
                    return {'valid': False, 'code': _mt3HG, 'detail': _L6jQU}
            return {'valid': True, 'code': None, 'detail': ''}

        def prettyprint(self, show_key=False):
            _qu2yr = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_mSZtN(_qu2yr, 'valid'), validation_code=_mSZtN(_qu2yr, 'code'))

    @dataclass
    class _sE1J5:
        name: str
        email: str | None
        product_ids: tuple[int]
        verify_key: VerifyKey
    _WF5Ll = _sE1J5('Monday Tech', 'support@mondaytech.com', (21778,), _GubD7(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfz7XiRe459sYB/PxgoMR0VKX0aA0rC+FPV8G7h02DHiYYKmtsI3o1kq7w3I6JKHpU8VnCEy2P6+W+8A0fdgTIQZJiKTsuJ7ymtX3hT/TyuIVveOsLBd5OHr0Prh/sshv4kFJTUYAROGtRVR/p/Ut2XTSaQIj02Zv9Yd8v1gMF8BsRgShG3Omyo+TfxA2OvXnlqCcSumyk2pfLtdkuGX0a5gTsG7kqY1e0RWB8LN0Ko7fCPCXuy1i/auwtGt/YALh+vL02RWb7CZSMvPEWJGh6WPwhcvywyRlEgFnKB3Ec1j3DcgUNXVQXHSYrbmveXfMkjpxokDIGWcbD3HY0agGwIDAQAB')))
    _rL2kM = _sE1J5('Deecie', None, (23488,), _GubD7(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArCITfOmahfX98LErjl8C22YRDpJjeQPJACSxBjEOAwjOwFoUNeEwVZyif0thbZVjZh4/Zp/413RoxQgSeWfoaZqsnvTV5iWBk3tN8wILmR4305fpjJHnrobJDyKoz9VUQRzwVtOkT3pbIeP/WrIz+937FO5Z2F76tMmMMlNtWgMCIEc8BT97yZPB5wXSWYozQ6WfNlm9/L2ajMce4P6kX1nKwBYkxY+MBG+7YyF66on7mG3LJUa/H1ZGVLpPNVpbd5WOL7f/vXE/RGYcwfSeQGiLEUxcwtsFhtfbjBivwxMSshOW7WLIgaC3lFKNWnT5sIeRGTeSvbFpVR5ERaiwhwIDAQAB')))
    _QJ0dr = {product_id: vendor for vendor in [_WF5Ll, _rL2kM] for product_id in vendor.product_ids}

    def _lTCip(product_id):
        assert isinstance(product_id, int)
        try:
            return _QJ0dr[product_id]
        except KeyError:
            _l6Roj = f"Cannot use SLiM with Cryptolens product ID {product_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _mh6oC(_l6Roj, 'CL_VENDOR_ERROR') from None
    _OjcxP = 'https://api.cryptolens.io/api'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _s2qy0 = requests_cache.CachedSession(cache_name=_4JBOP / 'cryptolens', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _3PZvv(_RTMWE):
        key_type = 'Cryptolens'

        @classmethod
        def from_key(cls, product_id, key):
            assert isinstance(product_id, int)
            return cls({'ProductId': product_id, 'Key': key})

        @classmethod
        def from_file(cls, path, token, update_if_older_than=timedelta(days=30)):
            path = Path(path)
            assert path.suffix == '.skm'
            with path.open() as _FBCd4:
                _hk8bY = json.load(_FBCd4)
            _ZKt3a = base64.b64decode(_hk8bY['signature'])
            _UAZMS = base64.b64decode(_hk8bY['licenseKey'])
            _Zjaw5 = json.loads(_UAZMS)
            _C9SgW = _lTCip(_Zjaw5['ProductId'])
            _C9SgW.verify_key.verify(sig_bytes=_ZKt3a, msg_bytes=_UAZMS, padding='pkcs1v15')
            _8xsDt(_Zjaw5['SignDate'])
            _8xsDt(_Zjaw5['Created'])
            if not token:
                for _AtV04 in _Zjaw5['DataObjects']:
                    if _AtV04['Name'] == 'token':
                        token = _AtV04['StringValue']
                        break
            _nuTds = datetime.now(tz=timezone.utc)
            _pkjYX = datetime.fromtimestamp(_Zjaw5['SignDate'], tz=timezone.utc)
            if token is not None and update_if_older_than and (_nuTds > _pkjYX + update_if_older_than):
                _hk8bY, _Zjaw5 = _oDhtG(_Zjaw5['ProductId'], _Zjaw5['Key'], token, activate=False)
                _8xsDt(_Zjaw5['SignDate'])
                _8xsDt(_Zjaw5['Created'])
                with path.open('w') as _QZDsp:
                    json.dump(_hk8bY, _QZDsp)
            return cls(_Zjaw5)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert isinstance(_mSZtN(data, 'ProductId'), int)
            assert isinstance(_mSZtN(data, 'Key'), str)
            self._data = data
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['Key']

        @property
        def license_id(self):
            return self.data['GlobalId']

        @property
        def product_id(self):
            return self.data['ProductId']

        @property
        def created(self):
            return datetime.fromtimestamp(self.data['Created'], tz=timezone.utc)

        @property
        def product_name(self):
            for _ch3Le in self.data['DataObjects']:
                if _ch3Le['Name'] == 'productName':
                    return _ch3Le['StringValue']
            return None

        def get_token(self):
            for _Z1LQh in self.data['DataObjects']:
                if _Z1LQh['Name'] == 'token':
                    return _Z1LQh['StringValue']
            return None

        @property
        def expiry(self):
            if not self.data['F1']:
                return None
            if (expiry := _mSZtN(self.data, 'Expires')):
                return datetime.fromtimestamp(expiry, tz=timezone.utc)
            return None

        @property
        def user(self):
            return {'email': _mSZtN(self.data, 'Customer', 'email')}

        @property
        def max_machines(self):
            return self.data['MaxNoOfMachines']

        @property
        def num_machines(self):
            return len(self.data['ActivatedMachines'])

        def list_machines(self):
            return self.data['ActivatedMachines']

        def validate(self, token, activate=True, raise_on_error=True):
            assert isinstance(token, str)
            _BsiJZ, data = _oDhtG(self.product_id, self.key, token, activate=activate, raise_on_error=raise_on_error)
            _BpBzR = _BsiJZ['metadata']['licenseStatus']
            if _BsiJZ['result'] != 0:
                raise _mh6oC(_BsiJZ['message'], 'CL_RESULT_ERROR')
            if raise_on_error:
                if not _BpBzR['isValid']:
                    raise _mh6oC(*_6pj0t(_BpBzR['reasonForInvalidity']))
                expiry = datetime.fromtimestamp(data['Expires'], tz=timezone.utc)
                if datetime.now(tz=timezone.utc) > expiry + timedelta(minutes=5):
                    _3oSKh = f'License has expired on {expiry}'
                    raise _mh6oC(_3oSKh, 'CL_EXPIRED')
            _8xsDt(data['SignDate'])
            _8xsDt(data['Created'])
            self._data = data
            return _BpBzR

        def prettyprint(self, show_key=False):
            _NtvFD: bool | Literal['unknown'] = 'unknown'
            _CMnos: str | None = None
            if (token := self.get_token()):
                _8CThz = self.validate(token, activate=False, raise_on_error=False)
                _NtvFD = _mSZtN(_8CThz, 'isValid')
                assert isinstance(_NtvFD, bool)
                if _NtvFD is False:
                    _0UqiX, _CMnos = _6pj0t(_8CThz['reasonForInvalidity'])
            super()._prettyprint(show_key=show_key, is_valid=_NtvFD, validation_code=_CMnos)

    def _oDhtG(product_id, key, token, activate=True, raise_on_error=True):
        _TNSoW = {'token': token, 'ProductId': product_id, 'Key': key, 'Metadata': True, 'ModelVersion': 3, 'Sign': True, 'SignMethod': 1}
        if activate:
            _kjc2o = f'{_OjcxP}/key/Activate'
            _TNSoW['MachineCode'] = _4mVXj()
        else:
            _kjc2o = f'{_OjcxP}/key/GetKey'
        _eG6K5 = _s2qy0.get(_kjc2o, params=_TNSoW)
        _14lTJ = _eG6K5.json()
        if not _eG6K5.ok:
            _y5ijz = f"CryptoLens: {_14lTJ['message']}"
            raise _mh6oC(_y5ijz, 'CL_REQUEST_ERROR')
        if raise_on_error:
            if _14lTJ['result'] != 0:
                raise _mh6oC(_14lTJ['message'], 'CL_RESULT_ERROR')
            _zALci = _14lTJ['metadata']['licenseStatus']
            if not _zALci['isValid']:
                raise _mh6oC(*_6pj0t(_zALci['reasonForInvalidity']))
        _vj1Yp = base64.b64decode(_14lTJ['signature'])
        _Sx4JK = base64.b64decode(_14lTJ['licenseKey'])
        _lTCip(product_id).verify_key.verify(sig_bytes=_vj1Yp, msg_bytes=_Sx4JK, padding='pkcs1v15')
        _FVu1e(_eG6K5)
        return (_14lTJ, json.loads(_Sx4JK))

    def _6pj0t(reason_for_invalidity):
        if reason_for_invalidity == 1:
            return ('License expired', 'CL_EXPIRED')
        if reason_for_invalidity == 2:
            return ('License blocked', 'CL_BLOCKED')
        return ('License validation failed', 'CL_FAILED_VALIDATION')

    def _KYYgQ():
        _s2qy0.cache.clear()
    _tkCTg = _gciJB / 'slic'

    def _BFip4(data):
        _HIW3Y = _kYot3(data)
        _3X059 = _HIW3Y.data['product']['id']
        _Upvov = _HIW3Y.data['license']['id']
        _HdpRJ = _tkCTg / _3X059 / (_Upvov + '.key')
        _HdpRJ.parent.mkdir(parents=True, exist_ok=True)
        _WIkgq, _5Z3PG = _HIW3Y.key.split('/')
        data, _iD1oq = _5Z3PG.split('.')
        with _HdpRJ.open('w') as _gHNvh:
            _gHNvh.write(_WIkgq + '/\n' + _Ve6k2(data, 60) + '\n.\n' + _Ve6k2(_iD1oq, 60))
        return _HIW3Y

    @_7YIY4
    def _GjaQY(license_keys_or_ids=None, product_id=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _CpOLV = _tkCTg
        if product_id:
            _CpOLV /= product_id
        for _hL6UO in _CpOLV.rglob('*.key'):
            _5LXXU = _kYot3.from_file(_hL6UO)
            if license_keys_or_ids is None:
                yield (_hL6UO, _5LXXU)
            else:
                _mpe0a = _mSZtN(_5LXXU.data, 'license', 'id')
                if _mpe0a in license_keys_or_ids:
                    license_keys_or_ids.remove(_mpe0a)
                    yield (_hL6UO, _5LXXU)
                    continue
                if _5LXXU.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_5LXXU.key)
                    yield (_hL6UO, _5LXXU)
                    continue
    if TYPE_CHECKING:
        from datetime import timedelta
        from pathlib import Path
    _LszBa = _gciJB / 'cryptolens'

    def _aHY8a(file):
        _0vMxv = _3PZvv.from_file(file, update_if_older_than=None, token=None)
        _JjgKi = _0vMxv.data['ProductId']
        _oeXPJ = _0vMxv.data['GlobalId']
        _qScgI = _LszBa / str(_JjgKi) / (str(_oeXPJ) + '.skm')
        _qScgI.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(file, _qScgI)
        return _0vMxv

    @_7YIY4
    def _2Pkos(license_keys_or_ids=None, product_id=None, token=None, update_if_older_than=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _ebz9n = _LszBa
        if product_id:
            _ebz9n /= str(product_id)
        for _JrW6y in _ebz9n.rglob('*.skm'):
            _CBiFV = _3PZvv.from_file(_JrW6y, token=token, update_if_older_than=update_if_older_than)
            if license_keys_or_ids is None:
                yield (_JrW6y, _CBiFV)
            else:
                _jDh9i = str(_mSZtN(_CBiFV.data, 'GlobalId'))
                if _jDh9i in license_keys_or_ids:
                    license_keys_or_ids.remove(_jDh9i)
                    yield (_JrW6y, _CBiFV)
                    continue
                _YJLHX = _mSZtN(_CBiFV.data, 'Key')
                if _YJLHX in license_keys_or_ids:
                    license_keys_or_ids.remove(_YJLHX)
                    yield (_JrW6y, _CBiFV)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_0y24V
    @cache
    def _Xd9mg(product_id, token, variable_names=()):
        for _UBiik in _GcxE1(_fmnr5(product_id, variable_names), (lic for _, lic in _2Pkos(product_id=product_id, token=token, update_if_older_than=timedelta(days=30)))):
            try:
                lic.validate(token)
            except _mh6oC:
                continue
            if product_id != lic.product_id:
                continue
            return lic
        _o9xbd = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _mh6oC(_o9xbd, 'CL_NOT_FOUND')

    def _fmnr5(product_id, var_names):
        for _yYd9x, _2sbqZ, _P9D6e in _3vA09(var_names):
            yield _3PZvv.from_key(product_id, _P9D6e)

    @dataclass
    class _4a5FT:
        name: str
        email: str | None
        account_id: str
        verify_key: Ed25519
    _eWg8F = _4a5FT(name='Monday Tech', email='support@mondaytech.com', account_id='109c23d2-6cdd-4faf-bd8a-96c242733638', verify_key=_5hgEd.from_hex('cee3f0572684018bd7e4c77ed82c91b6631ebd110ed8cdcf8ecfc8e2d4cf41e1'))
    _85nKh = _4a5FT(name='Keygen demo', email=None, account_id='1fddcec8-8dd3-4d8d-9b16-215cac0f9b52', verify_key=_5hgEd.from_hex('e8601e48b69383ba520245fd07971e983d06d22c4257cfd82304601479cee788'))
    _fajxm = {vendor.account_id: vendor for vendor in [_eWg8F, _85nKh]}

    def _cxXKq(account_id):
        try:
            return _fajxm[account_id]
        except KeyError:
            _Edz8y = f"Cannot use SLiM with Keygen account_id {account_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _mh6oC(_Edz8y, 'KG_VENDOR_ERROR') from None

    class _Mcv73(_RTMWE):
        key_type = 'Keygen offline'

        @classmethod
        def from_file(cls, path):
            assert isinstance(path, (str, Path))
            path = Path(path)
            with path.open() as _HDlmd:
                _yi0OA = _HDlmd.read().strip().replace('\n', '')
            assert _yi0OA, f'Empty license file {path}'
            return cls(_yi0OA)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _89AIS = 'key/'
            if not key.startswith(_89AIS):
                _1z9b3 = f'Expected prefix key/, got {key[:len(_89AIS)]}...'
                raise ValueError(_1z9b3)
            self._key = key
            _Rd9UQ, _M1Uci = self._key.split('.')
            _pZJuG = base64.urlsafe_b64decode(_M1Uci)
            self._data = json.loads(base64.urlsafe_b64decode(_Rd9UQ[len(_89AIS):]))
            _F1g8S = _mSZtN(self._data, 'account', 'id')
            if not _F1g8S:
                _1z9b3 = 'Key lacks account ID'
                raise _mh6oC(_1z9b3, 'KG_MISSING_ACCOUNT_ID')
            self.vendor: Vendor = _cxXKq(_F1g8S)
            _IXuf7 = self.vendor.verify_key
            if isinstance(_IXuf7, _6NJiw):
                _IXuf7.verify(_pZJuG, _Rd9UQ.encode(), padding='pss')
            else:
                _IXuf7.verify(_pZJuG, _Rd9UQ.encode())

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def account_id(self):
            return _mSZtN(self.data, 'account', 'id')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def product_name(self):
            return None

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def created(self):
            return _8Lkp3(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _mSZtN(self.data, 'license', 'expiry')):
                return _8Lkp3(expiry)
            return None

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def user(self):
            if (user := _mSZtN(self.data, 'user')):
                return {'id': _mSZtN(user, 'id'), 'email': _mSZtN(user, 'email')}
            return {}

        def list_machines(self):
            return []

        def validate(self, raise_on_error=True):
            _b4eHl = datetime.now(tz=timezone.utc)
            created = _mSZtN(self.data, 'license', 'created')
            if created and _b4eHl < _8Lkp3(created) - timedelta(minutes=5):
                if raise_on_error:
                    _SORbz = 'Invalid license'
                    raise _mh6oC(_SORbz, 'KG_E043')
                return {'valid': False, 'code': 'KG_E043', 'detail': 'Unknown error E043'}
            expiry = _mSZtN(self.data, 'license', 'expiry')
            if expiry and _b4eHl > _8Lkp3(expiry) + timedelta(minutes=5):
                if raise_on_error:
                    _SORbz = f'License has expired on {expiry}'
                    raise _mh6oC(_SORbz, 'KG_EXPIRED')
                return {'valid': False, 'code': 'KG_EXPIRED', 'detail': 'License has expired'}
            return {'valid': True, 'code': 'VALID', 'detail': 'is valid'}

        def prettyprint(self, show_key=False):
            _t3mEa = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_t3mEa['valid'], validation_code=_t3mEa['code'])

    def _gZJwc():
        _UxT98 = requests.get('https://ipinfo.io/json', timeout=10)
        _UxT98.raise_for_status()
        return _UxT98.json()
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _sLApi = '1.3'
    _0ImOT = requests_cache.CachedSession(cache_name=_4JBOP / 'keygen', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4), allowable_methods=['GET', 'HEAD', 'POST'])

    class _Vw3QP(_RTMWE):
        key_type = 'Keygen online'

        @classmethod
        def from_key(cls, account_id, key):
            assert account_id
            assert isinstance(key, str)
            assert not key.startswith('key/')
            return cls({'attributes': {'key': key}, 'relationships': {'account': {'data': {'id': account_id}}}})

        def __init__(self, data):
            assert isinstance(data, dict)
            assert 'data' not in data
            self._data = data
            _a0pcu = data['relationships']['account']['data']['id']
            self.base_url = f'https://api.keygen.sh/v1/accounts/{_a0pcu}'
            self.vendor = _cxXKq(_a0pcu)
            self.verify_response = self.vendor.verify_key.verify_response
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['attributes']['key']

        @property
        def auth(self):
            return f'License {self.key}'

        @property
        def license_id(self):
            return _mSZtN(self.data, 'id')

        @property
        def license_key(self):
            return self.data['attributes']['key']

        @property
        def account_id(self):
            return _mSZtN(self.data, 'relationships', 'account', 'data', 'id')

        @property
        def product_id(self):
            return _mSZtN(self.data, 'relationships', 'product', 'data', 'id')

        @property
        def product_name(self):
            return _mSZtN(self.data, 'attributes', 'metadata', 'productName')

        @property
        def usage_type(self):
            return _mSZtN(self.data, 'attributes', 'metadata', 'usageType')

        @property
        def activations(self):
            _9YyUB = _mSZtN(self.data, 'attributes', 'metadata', 'tokenId')
            if not _9YyUB:
                return (None, None)
            _rPEpr = _0ImOT.get(f'{self.base_url}/tokens/{_9YyUB}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _sLApi}, timeout=10)
            _rPEpr.raise_for_status()
            data = _rPEpr.json()
            _pJsAf = data['data']['attributes']
            return (_pJsAf['activations'], _pJsAf['maxActivations'])

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            if (created := _mSZtN(self.data, 'attributes', 'created')):
                return _8Lkp3(created)
            return None

        @property
        def expiry(self):
            if (expiry := _mSZtN(self.data, 'attributes', 'expiry')):
                return _8Lkp3(expiry)
            return None

        @property
        def num_machines(self):
            return _mSZtN(self.data, 'relationships', 'machines', 'meta', 'count')

        @property
        def max_machines(self):
            return _mSZtN(self.data, 'attributes', 'maxMachines')

        def list_machines(self):
            try:
                _5Ej9x = self.get_machines()
            except requests.exceptions.ReadTimeout:
                return []
            _e4hhD = []
            for _mcGdU in _5Ej9x:
                _Hs6s7 = _mSZtN(_mcGdU, 'attributes', 'fingerprint')
                _XUE7U = {'hostname': _mSZtN(_mcGdU, 'attributes', 'hostname'), 'requireHeartbeat': _mSZtN(_mcGdU, 'attributes', 'requireHeartbeat'), 'heartbeatStatus': _mSZtN(_mcGdU, 'attributes', 'heartbeatStatus'), 'fingerprint': _Hs6s7}
                if (lhb := _mSZtN(_mcGdU, 'attributes', 'lastHeartbeat')):
                    _XUE7U['lastHeartbeat'] = _8Lkp3(lhb)
                if (created := _mSZtN(_mcGdU, 'attributes', 'created')):
                    _XUE7U['created'] = _8Lkp3(created)
                _e4hhD.append(_XUE7U)
            return _e4hhD

        @property
        def user(self):
            metadata = self.data['attributes']['metadata']
            _u83Kn = _mSZtN(metadata, 'email') or _mSZtN(metadata, 'user')
            if _u83Kn and _u83Kn not in {'sigma@mondaytech.com', 'meshpro@mondaytech.com', 'texworld@mondaytech.com'}:
                return {'email': _u83Kn}
            return {}

        def validate(self, activate_if_required=False, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None, require_product_id=None):
            if _mSZtN(self.data, 'attributes', 'metadata', 'requireFingerprintScope') is True:
                return self._validate_fingerprinted(activate_if_required, require_product_id=require_product_id, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            _4XmaP = self._validate_cached(with_fingerprint=False, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _w4Xzq = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _mh6oC(_w4Xzq, 'KG_WRONG_PRODUCT_ID')
            if _mSZtN(_4XmaP, 'valid'):
                return _4XmaP
            _fsCeO = _mSZtN(_4XmaP, 'code')
            if _fsCeO == 'FINGERPRINT_SCOPE_REQUIRED':
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if raise_on_error:
                _w4Xzq = f'License {self.license_id}: Key validation failed'
                raise _mh6oC(_w4Xzq, _fsCeO)
            return _4XmaP

        def _validate_fingerprinted(self, activate_if_required, require_product_id=None, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _A00KK = self._validate_cached(with_fingerprint=True, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _HzmXC = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _mh6oC(_HzmXC, 'KG_WRONG_PRODUCT_ID')
            if _mSZtN(_A00KK, 'valid'):
                return _A00KK
            _ikALa = _mSZtN(_A00KK, 'code')
            if _ikALa == 'HEARTBEAT_NOT_STARTED':
                self._ping_heartbeat_cached(raise_on_error=True, cache_force_refresh=True)
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error)
            if activate_if_required and _ikALa in {'NO_MACHINE', 'NO_MACHINES', 'FINGERPRINT_SCOPE_MISMATCH', 'HEARTBEAT_DEAD'}:
                self.activate(raise_on_error=True)
                return self._validate_fingerprinted(activate_if_required, cache_force_refresh=True, cache_expire_after=cache_expire_after, raise_on_error=raise_on_error)
            if raise_on_error:
                _wUuWu = []
                _aJFWo = _mSZtN(_A00KK, 'detail')
                _cX59v = _mSZtN(_A00KK, 'code')
                if _ikALa and _aJFWo:
                    _wUuWu.append(f'Validation error {_ikALa}: {_aJFWo}')
                if _ikALa == 'NOT_FOUND':
                    _wUuWu.append('Did you provide the license ID instead of the key?')
                raise _mh6oC('\n'.join(_wUuWu), f'KG_{_cX59v}')
            return _A00KK

        def _validate_cached(self, with_fingerprint, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _6UTkQ: dict[str, Any] = {'key': self.key}
            if with_fingerprint:
                _6UTkQ['scope'] = {'fingerprint': _4mVXj()}
            _j6Ron = _0ImOT.post(f'{self.base_url}/licenses/actions/validate-key', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _sLApi}, json={'meta': _6UTkQ}, timeout=10, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            try:
                self.verify_response(_j6Ron)
            except _2j709:
                _0ImOT.cache.delete(requests=[_j6Ron.request])
                raise
            _FVu1e(_j6Ron)
            json = _j6Ron.json()
            if not _j6Ron.ok:
                _8fSST = _mSZtN(json, 'errors', 0)
                _dKkIu = f'Validation failed for license {self.license_id}: '
                if _8fSST:
                    if _8fSST.get('title') == 'Daily API request limit reached':
                        _Rq4aT = 'KG_RATE_LIMIT'
                        _dKkIu += 'Daily API rate limit has been reached. Limit will be reset at midnight UTC.'
                    else:
                        _Rq4aT = _mSZtN(_8fSST, 'code')
                        _dKkIu += _mSZtN(_8fSST, 'detail')
                else:
                    _Rq4aT = 'KG_VALIDATION_FAILED'
                    _dKkIu += 'unknown'
                raise _mh6oC(_dKkIu, _Rq4aT)
            data = json['data']
            _6UTkQ = json['meta']
            if not _mSZtN(_6UTkQ, 'valid') and raise_on_error:
                _vYB4B = _mSZtN(_6UTkQ, 'code')
                _W7JAP = _mSZtN(_6UTkQ, 'detail')
                _QjHNp = []
                if _vYB4B and _W7JAP:
                    _QjHNp.append(f'Validation error {_vYB4B}: {_W7JAP}')
                if _vYB4B == 'NOT_FOUND':
                    _QjHNp.append('Did you provide the license ID instead of the key?')
                raise _mh6oC('\n'.join(_QjHNp), _vYB4B)
            if _mSZtN(_6UTkQ, 'valid') and _mSZtN(data, 'attributes', 'requireHeartbeat'):
                self._ping_heartbeat_cached(raise_on_error=True)
            if data:
                self._data = data
            return _6UTkQ

        def activate(self, raise_on_error=True):
            _13L5B('Activating machine for license...', highlight=False, end='', style='green')
            _SGJRn = _mSZtN(self.data, 'attributes', 'metadata', 'token')
            _i3Ydf = _mSZtN(self.data, 'attributes', 'metadata', 'tokenId')
            _h6gCn = _SGJRn and _i3Ydf
            auth = f'Bearer {_SGJRn}' if _h6gCn else f'License {self.key}'
            _h7YWv = _gZJwc()
            _b5m8y = requests.post(f'{self.base_url}/machines', headers={'Authorization': auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _sLApi}, json={'data': {'type': 'machines', 'attributes': {'ip': _h7YWv.get('ip'), 'cores': multiprocessing.cpu_count(), 'fingerprint': _4mVXj(), 'platform': platform.platform(), 'hostname': socket.gethostname(), 'metadata': {'country': _h7YWv.get('country'), 'python-version': _iNLlV(), 'slim-version': _ULPFF('stonefish-license-manager')}}, 'relationships': {'license': {'data': {'type': 'licenses', 'id': self.license_id}}}}}, timeout=10)
            self.verify_response(_b5m8y)
            _FVu1e(_b5m8y)
            _0PAgU = _b5m8y.json()
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _h6gCn:
                self._clear_tokens_cache(_i3Ydf)
            if raise_on_error and 'errors' in _0PAgU:
                _13L5B(_0PAgU)
                _9Gl2v = f'Activation errors with license {self.license_id}:\n' + '\n'.join((f"    {_EBaOI['title']}: {_EBaOI['detail']}" for _EBaOI in _0PAgU['errors']))
                raise _mh6oC(_9Gl2v, 'KG_ACTIVATION_ERROR')
            _13L5B('done.', style='green')

        def deactivate(self, fingerprints=None):
            _13L5B('Deactivating machine for license...', highlight=False, end='', style='green')
            _1BWKt = _mSZtN(self.data, 'attributes', 'metadata', 'token')
            _aFNuD = _mSZtN(self.data, 'attributes', 'metadata', 'tokenId')
            _fkJi4 = _1BWKt and _aFNuD
            auth = f'Bearer {_1BWKt}' if _fkJi4 else f'License {self.key}'
            if not fingerprints:
                fingerprints = {_4mVXj()}
            for _NN3Lb in fingerprints:
                _6qL37 = self._get_machine_by_fingerprint_cached(_NN3Lb, cache_force_refresh=True)
                _v6Qyb = _mSZtN(_6qL37, 'data', 0, 'id')
                if not _v6Qyb:
                    _FJda9 = f"Couldn't get machine ID for machine {_NN3Lb}. Not activated?"
                    raise _mh6oC(_FJda9, 'KG_MACHINE_NOT_FOUND')
                _fP3HD = requests.delete(f'{self.base_url}/machines/{_v6Qyb}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': _sLApi}, timeout=10)
                if not _fP3HD.ok:
                    _uQ3en = _mSZtN(_fP3HD.json(), 'errors', 0)
                    if _uQ3en:
                        _6dydt = _mSZtN(_uQ3en, 'code')
                        _FJda9 = f"Machined deactivation failed: {_uQ3en['detail']}"
                    elif _fP3HD.status_code == 404:
                        _6dydt = 'KG_MACHINE_NOT_FOUND'
                        _FJda9 = 'Machine deactivation failed (not found)'
                    else:
                        _6dydt = 'KG_DEACTIVATION_FAILED'
                        _FJda9 = 'Unsuccessful deactivation request'
                    raise _mh6oC(_FJda9, _6dydt)
                self.verify_response(_fP3HD)
                _FVu1e(_fP3HD)
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _fkJi4:
                self._clear_tokens_cache(_aFNuD)
            _13L5B('done.', style='green')

        def _clear_validation_cache(self):
            _0ImOT.cache.delete(requests=[Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key}}), Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key, 'scope': {'fingerprint': _4mVXj()}}})])

        def _clear_machines_cache(self):
            _0ImOT.cache.delete(urls=[f'{self.base_url}/licenses/{self.license_id}/machines'])

        def _clear_tokens_cache(self, token_id):
            _0ImOT.cache.delete(urls=[f'{self.base_url}/tokens/{token_id}'])

        def get_machines(self, cache_force_refresh=False):
            _2WA1h = _0ImOT.get(f'{self.base_url}/licenses/{self.license_id}/machines', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _sLApi}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_2WA1h)
            except _2j709:
                _0ImOT.cache.delete(requests=[_2WA1h.request])
                raise
            _FVu1e(_2WA1h)
            json = _2WA1h.json()
            return _mSZtN(json, 'data', default=[])

        def prettyprint(self, show_key=False):
            _HOm5p: bool | Literal['unknown']
            try:
                _IyzFt = self.validate(raise_on_error=False)
            except requests.exceptions.ReadTimeout:
                _HOm5p = 'unknown'
                _tz6vB = 'timeout'
            else:
                _HOm5p = _IyzFt['valid']
                assert isinstance(_HOm5p, bool)
                _tz6vB = _mSZtN(_IyzFt, 'code')
            super()._prettyprint(show_key=show_key, is_valid=_HOm5p, validation_code=_tz6vB)

        def _get_machine_by_fingerprint_cached(self, fingerprint, cache_force_refresh=False, raise_on_error=False):
            _LOdQi = _0ImOT.get(url=f'{self.base_url}/machines', params={'fingerprint': quote(fingerprint)}, headers={'Authorization': self.auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _sLApi}, timeout=10, force_refresh=cache_force_refresh)
            self.verify_response(_LOdQi)
            _FVu1e(_LOdQi)
            _Q2r6z = _LOdQi.json()
            _jQ16r = _mSZtN(_Q2r6z, 'errors')
            if raise_on_error and _jQ16r:
                _Dfwwc = 'Get-Machine errors:\n' + '\n'.join((f"    {_g3KH0['title']}: {_g3KH0['detail']}" for _g3KH0 in _jQ16r))
                raise _mh6oC(_Dfwwc, 'KG_MACHINE_ERROR')
            return _Q2r6z

        def _ping_heartbeat_cached(self, raise_on_error, cache_force_refresh=False):
            _581r7 = _4mVXj()
            _5NkdQ = self._get_machine_by_fingerprint_cached(_581r7, cache_force_refresh=cache_force_refresh)
            _npVLB = _mSZtN(_5NkdQ, 'data', 0, 'id')
            if _npVLB is None:
                _7Pkme = f'Machine with fingerprint {_581r7} not found'
                raise _mh6oC(_7Pkme, 'KG_MACHINE_NOT_FOUND')
            _kK8KD = _0ImOT.post(f'{self.base_url}/machines/{_npVLB}/actions/ping-heartbeat', headers={'Authorization': self.auth, 'Accept': 'application/vnd.api+json', 'Keygen-Version': _sLApi}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_kK8KD)
            except _2j709:
                _0ImOT.cache.delete(requests=[_kK8KD.request])
                raise
            _FVu1e(_kK8KD)
            _GL6BQ = _kK8KD.json()
            _uWQgC = _mSZtN(_GL6BQ, 'errors')
            if _uWQgC and _mSZtN(_uWQgC[0], 'code') == 'NOT_FOUND' and (not cache_force_refresh):
                return self._ping_heartbeat_cached(raise_on_error, cache_force_refresh=True)
            if raise_on_error and _uWQgC:
                _7Pkme = f'License {self.license_id}: Heartbeat errors:\n' + '\n'.join((f"    {_V6Y7V['title']}: {_V6Y7V['detail']}" for _V6Y7V in _uWQgC))
                raise _mh6oC(_7Pkme, 'KG_HEARTBEAT_ERROR')
            return _GL6BQ

    def _u7ZBC():
        _0ImOT.cache.clear()

    def _9qv3F(cert_data_or_path, update_if_expired=True, override_original=True):
        _wdsqd = None
        if isinstance(cert_data_or_path, Path):
            _wdsqd = cert_data_or_path
            with _wdsqd.open() as _nEAQe:
                _mQAIy = _nEAQe.read()
        else:
            assert isinstance(cert_data_or_path, str)
            _mQAIy = cert_data_or_path
        _wPnb2, _qUAZY = _maWwn(_mQAIy)
        _TGLQC = datetime.now(tz=timezone.utc)
        if _8Lkp3(_qUAZY['issued']) > _TGLQC + timedelta(minutes=5):
            _OMdn1 = 'License error'
            raise _mh6oC(_OMdn1, 'KG_E058')
        if _wdsqd and update_if_expired and (_TGLQC > _8Lkp3(_qUAZY['expiry'])):
            _mQAIy = _2pLyt(_wPnb2['relationships']['account']['data']['id'], _wPnb2['id'], auth=f"License {_wPnb2['attributes']['key']}")
            _wPnb2, _qUAZY = _maWwn(_mQAIy)
            if override_original:
                with _wdsqd.open('w') as _WT398:
                    _WT398.write(_mQAIy)
        _hrAJZ = _wPnb2['attributes']['key']
        if _hrAJZ.startswith('key/'):
            return _Mcv73(_hrAJZ)
        return _Vw3QP(_wPnb2)

    def _YLTBa(path):
        with path.open() as _3K3Y8:
            _Jy5sL = _3K3Y8.read()
        _71NN2, _lfaHl = _maWwn(_Jy5sL)
        _R7Kre = _71NN2['attributes']['key']
        _Jy5sL = _2pLyt(_71NN2['relationships']['account']['data']['id'], _71NN2['id'], auth=f'License {_R7Kre}')
        with path.open('w') as _xARHS:
            _xARHS.write(_Jy5sL)

    def _maWwn(content):
        assert isinstance(content, str)
        _k4jpp = '-----BEGIN LICENSE FILE-----\n'
        _Kal9A = '-----END LICENSE FILE-----'
        content = content.strip()
        if not content.startswith(_k4jpp) or not content.endswith(_Kal9A):
            _1zoxS = f'Error in license file. Expected\n```{_k4jpp}...\n{_Kal9A}\n```\ngot\n```\n{content}\n```\nTry refreshing the the license file with `slim refresh`.\n'
            raise ValueError(_1zoxS)
        _hoCeN = base64.b64decode(_mX1yl(content, _k4jpp, _Kal9A))
        try:
            _MYRtH = json.loads(_hoCeN)
        except UnicodeDecodeError:
            _1zoxS = 'Unexpected license data'
            raise RuntimeError(_1zoxS) from None
        _KmFwl = json.loads(base64.b64decode(_MYRtH['enc']))
        _EmUAT = _mSZtN(_KmFwl, 'data', 'relationships', 'account', 'data', 'id')
        _BC7kW = _cxXKq(_EmUAT).verify_key
        _E7Feb = ('license/' + _MYRtH['enc']).encode()
        _vC3xt, _ShJMt = _MYRtH['alg'].split('+')
        assert _vC3xt == 'base64'
        _YW04d = base64.b64decode(_MYRtH['sig'])
        if _BC7kW.alg != _ShJMt:
            _1zoxS = f'Requested {_ShJMt} key, but got {_BC7kW.alg} verify_key'
            raise RuntimeError(_1zoxS)
        _BC7kW.verify(_YW04d, _E7Feb)
        return (_KmFwl['data'], _KmFwl['meta'])

    def _2pLyt(account_id, license_id_or_key, auth, host='api.keygen.sh'):
        _Fq127 = requests.get(f'https://{host}/v1/accounts/{account_id}/licenses/{quote(license_id_or_key)}/actions/check-out', headers={'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': '1.3'}, timeout=10)
        _Fq127.raise_for_status()
        _cxXKq(account_id).verify_key.verify_response(_Fq127)
        _FVu1e(_Fq127)
        return _Fq127.text
    try:
        import tomllib
    except ImportError:
        import tomli as tomllib
    _bLgF6 = _gciJB / 'keygen'

    def _ZKemR(file_or_cert):
        _cctCM = _9qv3F(file_or_cert, update_if_expired=True, override_original=False)
        if isinstance(_cctCM, _Vw3QP):
            _cctCM.validate(activate_if_required=True)
            return _T2xAh(_cctCM, file_or_cert)
        assert isinstance(_cctCM, _Mcv73)
        _3G4AH(_cctCM)
        return _cctCM

    def _T2xAh(lic, cert=None):
        _13L5B('Installing license...', end='', style='green', highlight=False)
        if cert is None:
            cert = _2pLyt(lic.account_id, lic.license_key, auth=f'License {lic.license_key}')
        elif isinstance(cert, Path):
            with cert.open() as _aguRB:
                cert = _aguRB.read()
        assert isinstance(cert, str)
        assert cert.startswith('-----BEGIN LICENSE FILE-----')
        assert lic.product_id, 'Missing product ID'
        assert lic.license_id, 'Missing license ID'
        _VzE96 = _bLgF6 / lic.product_id / (lic.license_id + '.lic')
        _VzE96.parent.mkdir(parents=True, exist_ok=True)
        with _VzE96.open('w') as _pMsGN:
            _pMsGN.write(cert)
        _13L5B('done.', style='green')
        return lic

    def _3G4AH(lic):
        _3jRGu = _bLgF6 / lic.product_id / (lic.license_id + '.key')
        _3jRGu.parent.mkdir(parents=True, exist_ok=True)
        _pjbDv, _AKHys = lic.key.split('/')
        _8XnPy, _iVCzl = _AKHys.split('.')
        with _3jRGu.open('w') as _yssZF:
            _yssZF.write(_pjbDv + '/\n' + _Ve6k2(_8XnPy, 60) + '\n.\n' + _Ve6k2(_iVCzl, 60))

    def _C0Y45(toml_file):
        _Cjaaa = _3mIZM(toml_file)
        if _Cjaaa.startswith('key/'):
            _lYsTW = _Mcv73(_Cjaaa)
            _3G4AH(_lYsTW)
            return _lYsTW
        _Cjaaa = _nUov3(_Cjaaa, 'fp/')
        _LFnbN = _Vw3QP.from_key(_TlrD4(_Cjaaa), _Cjaaa)
        _LFnbN.validate(activate_if_required=True)
        _T2xAh(_LFnbN)
        return _LFnbN

    def _3mIZM(toml_file):
        with Path(toml_file).open('rb') as _q8KbU:
            _DuHI1 = tomllib.load(_q8KbU)
        assert _DuHI1, f'Empty license file {toml_file}'
        return _DuHI1['license_key']

    @_7YIY4
    def _dbtt6(product_id=None, license_keys_or_ids=None):
        _881P9 = _bLgF6
        if product_id:
            _881P9 /= product_id
        for _gT0F4 in _881P9.rglob('*.key'):
            _lJvt7 = _Mcv73.from_file(_gT0F4)
            if license_keys_or_ids is None:
                yield (_gT0F4, _lJvt7)
            else:
                _mbUEE = _mSZtN(_lJvt7.data, 'license', 'id')
                if _mbUEE in license_keys_or_ids:
                    license_keys_or_ids.remove(_mbUEE)
                    yield (_gT0F4, _lJvt7)
                    continue
                if _lJvt7.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_lJvt7.key)
                    yield (_gT0F4, _lJvt7)
                    continue

    @_7YIY4
    def _RaYUN(product_id=None, license_keys_or_ids=None):
        _rvgQV = _bLgF6
        if product_id:
            _rvgQV /= product_id
        for _Kmba7 in _rvgQV.rglob('*.toml'):
            _C0Y45(_Kmba7)
            _Kmba7.unlink()
        for _WOMOJ in _rvgQV.rglob('*.lic'):
            _ljtsQ = _9qv3F(_WOMOJ)
            if license_keys_or_ids is None:
                yield (_WOMOJ, _ljtsQ)
            else:
                _5Sc01 = _mSZtN(_ljtsQ.data, 'id')
                if _5Sc01 in license_keys_or_ids:
                    license_keys_or_ids.remove(_5Sc01)
                    yield (_WOMOJ, _ljtsQ)
                    continue
                _TToXP = _mSZtN(_ljtsQ.data, 'attributes', 'key')
                if _TToXP in license_keys_or_ids:
                    license_keys_or_ids.remove(_TToXP)
                    yield (_WOMOJ, _ljtsQ)
                    continue

    def _qLGoy():
        _Q9pqZ = 0
        for _tMZtR in _bLgF6.rglob('*.lic'):
            _YLTBa(_tMZtR)
            _Q9pqZ += 1
        return _Q9pqZ
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_0y24V
    @cache
    def _hSlNs(account_id, product_id, variable_names=(), allow_user_input=True, cache_force_refresh=False, cache_expire_after=None):
        assert isinstance(product_id, str)
        _cxXKq(account_id)
        for _iuutP in _GcxE1(_8WqlY(account_id, list(variable_names)), _b0nis(product_id), _vW2Lz(product_id)):
            if isinstance(_iuutP, _Vw3QP):
                try:
                    _bGtI7 = _iuutP.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                except _mh6oC as e:
                    _knJvs(str(e))
                    continue
            elif isinstance(_iuutP, _Mcv73):
                try:
                    _bGtI7 = _iuutP.validate()
                except _mh6oC as e:
                    _knJvs(str(e))
                    continue
            else:
                continue
            if _iuutP.account_id != account_id or _iuutP.product_id != product_id:
                continue
            return (_iuutP.data, _bGtI7)
        _OmNHb = f'Unable to find valid license for product ID {product_id}.'
        if allow_user_input:
            _knJvs(_OmNHb)
            _8RU6r = Prompt.ask('Enter license key')
            _iuutP = _TqFRn(_8RU6r, account_id)
            if _iuutP is None:
                _aT8ik = f'Illegal license key `{_8RU6r}`. Typo?'
                raise _mh6oC(_aT8ik, 'ILLEGAL_KEY')
            if isinstance(_iuutP, _Vw3QP):
                _bGtI7 = _iuutP.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                _T2xAh(_iuutP)
                return (_iuutP.data, _bGtI7)
            if isinstance(_iuutP, _Mcv73):
                _bGtI7 = _iuutP.validate()
                if _iuutP.product_id != product_id:
                    _aT8ik = f'Require product ID {product_id}, but license has product ID {_iuutP.product_id}'
                    raise _mh6oC(_aT8ik, 'KG_WRONG_PRODUCT_ID')
                _3G4AH(_iuutP)
                return (_iuutP.data, _bGtI7)
        raise _mh6oC(_OmNHb, 'KG_NOT_FOUND')

    def _8WqlY(account_id, var_names):
        for _3IKY8, _JYB8w, _nPgF4 in _3vA09(var_names):
            if _nPgF4.strip() == '':
                _knJvs(f'{_3IKY8.title()} variable `{_JYB8w}` is empty.')
                continue
            _E30oy = _TqFRn(_nPgF4, account_id)
            if _E30oy is None:
                _knJvs(f'{_3IKY8.title()} variable `{_JYB8w}` contains value that cannot be converted to a KG license:\n{_nPgF4}')
                continue
            yield _E30oy

    def _TqFRn(value, account_id):
        if value.endswith('-V3'):
            _HMwZp = _nUov3(value, 'fp/')
            return _Vw3QP.from_key(account_id, _HMwZp)
        if value.startswith('key/'):
            return _Mcv73(value)
        if value.startswith('-----BEGIN LICENSE FILE-----'):
            return _9qv3F(value, update_if_expired=True, override_original=False)
        _TzaPN = Path(value)
        if _TzaPN.is_file():
            with _TzaPN.open() as _q9GWC:
                _0Wk3h = _q9GWC.read()
            return _TqFRn(_0Wk3h, account_id)
        return None

    def _b0nis(product_id):
        for _uusHn, _7q04Z in _dbtt6(product_id=product_id):
            yield _7q04Z

    def _vW2Lz(product_id):
        for _Lp90S, _KeEHY in _RaYUN(product_id=product_id):
            try:
                yield _KeEHY
            except _2j709:
                _knJvs(f'Invalid signature in {_Lp90S}. Skipping.')

    class _FGFY6:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        products_codes = ('stp01',)
    _ou6Sj = {product_code: vendor for vendor in [_FGFY6] for product_code in vendor.products_codes}

    def _dPVAH(product_code):
        try:
            return _ou6Sj[product_code]
        except KeyError:
            _B3XiN = f"Cannot use SLiM with LicenseSpring product code {product_code}... If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _mh6oC(_B3XiN, 'CL_VENDOR_ERROR') from None
    _1FgFC = platformdirs.user_data_path('slim', 'MondayTech') / 'license_spring'
    _EbdSO = _gqPrH(base64.b64decode('MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwEt7ZQWSzeBYNBwyi3KW+XU/6I+ju90R5ZpTvSE4VWL8KSgVJ6bWKIhaKTL2hbUpIQQgS5ZKfa4SEEMdIm5kxe0u2F64JFAVQunx/1O/UXsD7ADVt93Q/hxA9Npa16tKepZoyhi79sxpaxyy/WTdsZKuTLApX7bWX6/XPhaPjNyiWeeK2Naka44B+F+PwN/ey3rZUra3pBltShwy2dmKIxJVmprf5ttMYBB+ouqPin3VgDw5Jq1FZwpLBiOe+ogR+sHu7QYWwLq6AgC4e3JqgryEvqfJr/XkvOnAdcAIZm6tK6DdnLWCy6Onrk7t0VQK5nnGF1CKE+jcAByWopcIVCwfYrs1UCSY1YibKXNJoyvEhgLyCC+KAgXKf8omcg1Q18XKu5XSrvrCzXLnRnaFNpFDjcg5AJJab78hX7qGPC+e8PjuBYwh2vtx5mFj7/c+T59JM/vXwwvW9DsnDztDWEDFhzGanU71NgwrZbRoNSyTW0UjbZsyJVSIX6233Ng0y5L9mDe8p8P+u1B0sXAAozEKL/yG4Qu5r4LIw4iv6JVPT1xbWlH4Vc4KaN3toaf4+G0EkFy6ncvBncWifLARSoWpQ5YsygDdQNVYdmMsoQ76UTuNxo3eZ0sQJjbQVBqlkcXrAdtUCpuojPRsl/Xs9zVOJrzZPG0I98E5quNbRkMCAwEAAQ=='))
    _zOOuP = 'https://api.licensespring.com/api/v4'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _9lfmL = requests_cache.CachedSession(cache_name=_4JBOP / 'license_spring', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _9wEqm(_RTMWE):
        key_type = 'License Spring'

        @classmethod
        def from_file(cls, path):
            with Path(path).open() as _PpKbE:
                _WFId3 = _PpKbE.read()
            try:
                _UWZ4J = base64.b64decode(_WFId3)
            except binascii.Error:
                _fG3mC = f'Invalid license file {path}'
                raise _mh6oC(_fG3mC, 'LS_INVALID_FILE') from None
            _g2CIg = json.loads(_UWZ4J)
            _agdJM = base64.b64decode(_g2CIg.pop('license_signature_v2'))
            _pZeJZ = json.dumps(_g2CIg, separators=(',', ':')).encode()
            _EbdSO.verify(_agdJM, _pZeJZ, padding='pkcs1v15')
            _wAVJC(datetime.strptime(_g2CIg['date'], '%a %b %d %Y %H:%M:%S GMT%z'))
            return cls(_g2CIg)

        @classmethod
        def from_key(cls, product_code, license_key):
            _fe9Fk = {'product_details': {'short_code': product_code}, 'license_key': license_key}
            return cls(_fe9Fk)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert _mSZtN(data, 'license_key')
            _hofYk = _mSZtN(data, 'product_details', 'short_code')
            assert _hofYk
            self.vendor = _dPVAH(_hofYk)
            self._data = data

        @property
        def data(self):
            return self._data

        @property
        def license_id(self):
            return _mSZtN(self.data, 'id')

        @property
        def product_id(self):
            return _mSZtN(self.data, 'product_details', 'product_id')

        @property
        def product_code(self):
            return self.data['product_details']['short_code']

        @property
        def product_name(self):
            return _mSZtN(self.data, 'product_details', 'product_name')

        @property
        def key(self):
            return self.data['license_key']

        @property
        def created(self):
            if (date := _mSZtN(self.data, 'date')):
                return datetime.strptime(date, '%a %b %d %Y %H:%M:%S GMT%z')
            return None

        @property
        def expiry(self):
            if (vp := self.data.get('validity_period')):
                return _8Lkp3(vp)
            return None

        @property
        def user(self):
            user = _mSZtN(self.data, 'customer')
            if not user:
                return {}
            _SpOtr = []
            if (fn := user['first_name']):
                _SpOtr.append(fn)
            if (ln := user['last_name']):
                _SpOtr.append(ln)
            return {'name': ' '.join(_SpOtr) if _SpOtr else None, 'email': user['email'] or None}

        @property
        def vendor_name(self):
            return self.vendor.name

        def list_machines(self):
            return []

        def validate(self, shared_key, api_key, activate_if_required=True, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _MRbgP = _9lfmL.get(url=f'{_zOOuP}/check_license', headers=_cIlZ3(shared_key, api_key), params={'product': self.product_code, 'hardware_id': _4mVXj(), 'license_key': self.key}, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            _ymyFt(_MRbgP)
            _FVu1e(_MRbgP)
            data = _MRbgP.json()
            if data.get('code') in {'license_not_active', 'device_not_found'} and activate_if_required:
                self.activate(shared_key, api_key)
                _acqFW()
                return self.validate(shared_key, api_key, activate_if_required=activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=True)
            if not _MRbgP.ok and raise_on_error:
                raise _mh6oC(data['message'], 'LS_VALIDATION_ERROR')
            self._data = data
            return data

        def activate(self, shared_key, api_key, app_version=None):
            data = {'product': self.product_code, 'hardware_id': _4mVXj(), 'license_key': self.key, 'os_ver': platform.platform(), 'hostname': socket.gethostname(), 'mac_address': ':'.join((f'{_r3CCR:02x}' for _r3CCR in uuid.getnode().to_bytes(6, byteorder='big')))}
            _adVSV = _ULPFF('stonefish-license-manager')
            data['sdk_ver'] = f'Stonefish License Manager {_adVSV}'
            if app_version:
                data['app_ver'] = app_version
            _Knwa7 = requests.post(url=f'{_zOOuP}/activate_license', headers=_cIlZ3(shared_key, api_key), json=data, timeout=10)
            _ymyFt(_Knwa7)
            _FVu1e(_Knwa7)
            json = _Knwa7.json()
            if not _Knwa7.ok:
                raise _mh6oC(json['message'], 'LS_ACTIVATION_ERROR')
            return json

        def deactivate(self, shared_key, api_key):
            _SlZgM = requests.post(url=f'{_zOOuP}/deactivate_license', headers=_cIlZ3(shared_key, api_key), json={'product': self.product_code, 'hardware_id': _4mVXj(), 'license_key': self.key}, timeout=10)
            _FVu1e(_SlZgM)
            if not _SlZgM.ok:
                json = _SlZgM.json()
                raise _mh6oC(json['message'], 'LS_DEACTIVATION_ERROR')
            return

        def prettyprint(self, show_key=False):
            super()._prettyprint(show_key=show_key, is_valid='unknown', validation_code=None)

    def _8JuUu():
        _9lfmL.cache.clear()

    def _acqFW():
        for _I0Ev5 in _9lfmL.cache.responses.values():
            if _I0Ev5.url == f'{_zOOuP}/check_license':
                _9lfmL.cache.delete(_I0Ev5.cache_key)

    def _cIlZ3(shared_key, api_key):
        _KDuih = format_date_time(time.time())
        _MDjn7 = hmac.new(bytes(shared_key, 'utf-8'), f'licenseSpring\ndate: {_KDuih}'.encode(), hashlib.sha256).digest()
        _8cXEw = base64.b64encode(_MDjn7).decode()
        _ZNMuJ = ','.join(['algorithm="hmac-sha256"', 'headers="date"', f'signature="{_8cXEw}"', f'apiKey="{api_key}"'])
        return {'Content-Type': 'application/json', 'Date': _KDuih, 'Authorization': _ZNMuJ}

    def _P0aYg(product_code, shared_key, api_key):
        _pyuSv = _9lfmL.get(url=f'{_zOOuP}/product_details', params={'product': product_code}, headers=_cIlZ3(shared_key, api_key), timeout=10)
        _ymyFt(_pyuSv)
        _FVu1e(_pyuSv)
        _QyhSA = _pyuSv.json()
        if not _pyuSv.ok:
            raise _mh6oC(_QyhSA['message'], 'LS_PRODUCT_ERROR')
        return _QyhSA

    def _ymyFt(res):
        if (sig := res.headers.get('LicenseSignature')):
            _EbdSO.verify(base64.b64decode(sig), res.content, padding='pkcs1v15')
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_0y24V
    @cache
    def _rnT9f(product_code, shared_key, api_key, variable_names=(), cache_force_refresh=False, cache_expire_after=None):
        for _7U3vn in _GcxE1(_yPefS(product_code, variable_names), _NXUaN(product_code)):
            try:
                _7U3vn.validate(shared_key, api_key, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            except _mh6oC:
                continue
            if product_code != _7U3vn.product_code:
                continue
            return _7U3vn
        _6AQMi = f'Unable to find valid license for product {product_code}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _mh6oC(_6AQMi, 'LS_NOT_FOUND')

    def _yPefS(product_code, var_names):
        for _Lg5L7, _gnv54, _6plBu in _3vA09(var_names):
            yield _9wEqm.from_key(product_code, _6plBu)

    def _NXUaN(product_code):
        for _QVX0n in (_1FgFC / product_code).glob('*.lic'):
            yield _9wEqm.from_file(_QVX0n)
    if TYPE_CHECKING:
        from pathlib import Path
    _fxx3J = _gciJB / 'license_spring'

    def _qhjLD(path):
        _rmFlw = _9wEqm.from_file(path)
        _wQWdz = _rmFlw.data['product_details']['short_code']
        _0XTmK = _rmFlw.data['id']
        _rOcC7 = _fxx3J / _wQWdz / (str(_0XTmK) + '.lic')
        _rOcC7.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(path, _rOcC7)
        return _rmFlw

    @_7YIY4
    def _KsfW2(license_keys_or_ids=None, product_code=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _eSDVP = _fxx3J
        if product_code:
            _eSDVP /= product_code
        for _5z3kp in _eSDVP.rglob('*.lic'):
            _0RH0H = _9wEqm.from_file(_5z3kp)
            if license_keys_or_ids is None:
                yield (_5z3kp, _0RH0H)
            else:
                _QGcWE = str(_mSZtN(_0RH0H.data, 'id'))
                if _QGcWE in license_keys_or_ids:
                    license_keys_or_ids.remove(_QGcWE)
                    yield (_5z3kp, _0RH0H)
                    continue
                _sv3kJ = _mSZtN(_0RH0H.data, 'license_key')
                if _sv3kJ in license_keys_or_ids:
                    license_keys_or_ids.remove(_sv3kJ)
                    yield (_5z3kp, _0RH0H)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_0y24V
    @cache
    def _t8btf(vendor_id, product_id, variable_names=()):
        _6Zmn8(vendor_id)
        for _kIS12 in _GcxE1(_IjEXN(variable_names), _EsDPm(product_id)):
            try:
                _yThCi = _kIS12.validate()
            except _mh6oC:
                continue
            except _2j709:
                _knJvs('Invalid signature in SLiC license')
                continue
            if vendor_id != _mSZtN(_kIS12.data, 'vendor', 'id') or product_id != _mSZtN(_kIS12.data, 'product', 'id'):
                continue
            return (_kIS12.data, _yThCi)
        _pJOLz = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _mh6oC(_pJOLz, 'SLIC_NOT_FOUND')

    def _IjEXN(var_names):
        for _upT2q, _7QZLs, _4DN49 in _3vA09(var_names):
            try:
                yield _kYot3(_4DN49)
            except _2j709:
                _knJvs(f'Invalid signature in SLiC license in {_4DN49}')

    def _EsDPm(product_id):
        for _bX3Jp, _akIhs in _GjaQY(product_id=product_id):
            try:
                yield _akIhs
            except _2j709:
                _knJvs(f'Invalid signature in SLiC license in {_bX3Jp}')
    if TYPE_CHECKING:
        pass

    def _rAQjM(ld):
        if isinstance(ld, str):
            ld = ld.strip()
            if ld.startswith('-----BEGIN LICENSE FILE-----'):
                return _ZKemR(ld)
            if ld.endswith('-V3'):
                _4x43z = _nUov3(ld, 'fp/')
                _3tbVB = _Vw3QP.from_key(_TlrD4(_4x43z), _4x43z)
                _3tbVB.validate(activate_if_required=True)
                return _T2xAh(_3tbVB)
            if ld.startswith('key/'):
                _3tbVB = _Mcv73(ld)
                _3G4AH(_3tbVB)
                return _3tbVB
            if ld.startswith('slicv1/'):
                return _BFip4(ld)
        if Path(ld).exists():
            return _qqhCO(Path(ld))
        _ktyls = f"Don't know how to handle license_data {ld}"
        raise _eSHOm(_ktyls)

    def _qqhCO(license_file):
        if not license_file.exists():
            _KMbqa = f'File {license_file} not found'
            raise _eSHOm(_KMbqa)
        if license_file.suffix == '.toml':
            return _C0Y45(license_file)
        if license_file.suffix == '.lic':
            with license_file.open() as _j1QI1:
                _H9E7S = _j1QI1.read()
            if _H9E7S.startswith('-----BEGIN LICENSE FILE-----'):
                return _ZKemR(license_file)
            return _qhjLD(license_file)
        if license_file.suffix == '.key':
            _4eGr0 = _Mcv73.from_file(license_file)
            _3G4AH(_4eGr0)
            return _4eGr0
        if license_file.suffix == '.skm':
            return _aHY8a(license_file)
        _KMbqa = f'Unknown license file format {license_file}'
        raise _eSHOm(_KMbqa)

    def _ChLDx(license_keys_or_ids=None, product_id=None):
        assert isinstance(license_keys_or_ids, set) or license_keys_or_ids is None
        return _GcxE1(_2Pkos(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _RaYUN(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _dbtt6(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _KsfW2(license_keys_or_ids=license_keys_or_ids, product_code=product_id), _GjaQY(license_keys_or_ids=license_keys_or_ids, product_id=product_id))

    def _wNr4M():
        _qLGoy()
    _mKcX1 = 0
    _5Oqx2 = 1
    RichHelpFormatter.styles['argparse.args'] = 'cyan'
    RichHelpFormatter.styles['argparse.groups'] = 'yellow'
    RichHelpFormatter.styles['argparse.metavar'] = 'green'

    def _jMEnA(license_data):
        if license_data.startswith('key/'):
            return _Mcv73(license_data)
        if license_data.endswith('-V3'):
            _M8DTz = _nUov3(license_data, 'fp/')
            return _Vw3QP.from_key(_TlrD4(_M8DTz), _M8DTz)
        if license_data.startswith('-----BEGIN LICENSE FILE-----'):
            return _9qv3F(license_data, update_if_expired=True, override_original=False)
        if license_data.startswith('slicv1/'):
            return _kYot3(license_data)
        if Path(license_data).exists():
            _uNJGB = Path(license_data)
            if _uNJGB.suffix == '.toml':
                return _jMEnA(_3mIZM(_uNJGB))
            if _uNJGB.suffix == '.lic':
                return _9qv3F(_uNJGB, update_if_expired=True, override_original=False)
            if _uNJGB.suffix == '.skm':
                return _3PZvv.from_file(_uNJGB, token=None)
            _YlzPB = f'Unknown license format in file {_uNJGB}'
            raise RuntimeError(_YlzPB)
        _YlzPB = 'Unknown key type'
        raise RuntimeError(_YlzPB)

    def _eVoeo(_):
        _13L5B(_4mVXj())
        return _mKcX1

    def _BYrIP(license_keys_or_ids, raw=False, show_keys=False):
        assert isinstance(license_keys_or_ids, set)
        try:
            _yNl1t = list(_ChLDx(license_keys_or_ids=license_keys_or_ids or None))
        except _eSHOm as e:
            _94mhs(str(e))
            return _5Oqx2
        if license_keys_or_ids:
            for _PvsgP in license_keys_or_ids:
                try:
                    _yNl1t.append((None, _jMEnA(_PvsgP)))
                except RuntimeError:
                    _94mhs(f'{_PvsgP}: No such license.')
                    return _5Oqx2
        try:
            for _I8Tpw, _fO7jJ in _yNl1t:
                if raw:
                    _13L5B(_fO7jJ.data)
                else:
                    _fO7jJ.prettyprint(show_key=show_keys)
        except Exception as e:
            _94mhs(str(e))
            return _5Oqx2
        return _mKcX1

    def _s4gqx(license_keys_or_ids, automatic_yes=False):
        license_keys_or_ids = set(license_keys_or_ids)
        if license_keys_or_ids:
            license_keys_or_ids = {k.strip().replace('\n', '') for k in license_keys_or_ids}
        try:
            _zVLXi = list(_ChLDx(license_keys_or_ids=license_keys_or_ids))
        except _eSHOm as e:
            _94mhs(str(e))
            return _5Oqx2
        if license_keys_or_ids:
            _SwkNa = ', '.join(license_keys_or_ids)
            _dGzI4 = '' if len(license_keys_or_ids) == 1 else 's'
            _94mhs(f'Could not find the following license{_dGzI4}: {_SwkNa}')
            return _5Oqx2
        for _iHJRa, _NSwvE in _zVLXi:
            _NSwvE.prettyprint()
        if not _zVLXi:
            return _mKcX1
        _dGzI4 = '' if len(_zVLXi) == 1 else 's'
        if automatic_yes or Confirm.ask(f'Uninstall the above license{_dGzI4} and deactivate machine?'):
            for _whmfs, _YE8ir in _zVLXi:
                try:
                    _YE8ir.deactivate({_4mVXj()})
                except Exception:
                    pass
            for _KQslA, _BdseJ in _zVLXi:
                _KQslA.unlink()
            if not any(_KQslA.parent.iterdir()):
                _KQslA.parent.rmdir()
            _13L5B('Removed.', style='green')
            return _mKcX1
        _13L5B('Abort.')
        return _5Oqx2

    def _iDKPc(license_data):
        try:
            _3RiwW = _rAQjM(license_data)
        except Exception as e:
            _94mhs(str(e))
            return _5Oqx2
        _3RiwW.prettyprint()
        return _mKcX1

    def _22de9(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _2Pzbw = list(_ChLDx(license_keys_or_ids={license_key_or_id}))
        except _eSHOm as e:
            _94mhs(str(e))
            return _5Oqx2
        if not _2Pzbw:
            _S4ceZ = f"Couldn't find license with key or ID {license_key_or_id}"
            _94mhs(_S4ceZ)
            return _5Oqx2
        _SAATA = _4mVXj()
        if not machine_fingerprints:
            machine_fingerprints = {_SAATA}
        _13L5B()
        for _ky6qH in machine_fingerprints:
            _13L5B(_ky6qH, style='bold')
        _13L5B()
        if automatic_yes or Confirm.ask(f'Activate the above machine(s) for license {license_key_or_id}?'):
            for _BDsDn, _ANqBF in _2Pzbw:
                try:
                    _ANqBF.activate()
                except (RuntimeError, _mh6oC) as e:
                    _94mhs(str(e))
                    return _5Oqx2
                _ANqBF.prettyprint()
        return _mKcX1

    def _LNKOd(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _Z5uPS = list(_ChLDx(license_keys_or_ids={license_key_or_id}))
        except _eSHOm as e:
            _94mhs(str(e))
            return _5Oqx2
        if not _Z5uPS:
            _igfHW = f"Couldn't find license with key or ID {license_key_or_id}"
            _94mhs(_igfHW)
            return _5Oqx2
        _XCz39 = _4mVXj()
        if not machine_fingerprints:
            machine_fingerprints = {_XCz39}
        _13L5B()
        for _Xvmbt in machine_fingerprints:
            _13L5B(_Xvmbt, style='bold')
        _13L5B()
        if automatic_yes or Confirm.ask(f'Deactivate the above machine(s) for license {license_key_or_id}?'):
            for _QOWmZ, _Bw5yI in _Z5uPS:
                try:
                    _Bw5yI.deactivate(machine_fingerprints)
                except Exception as e:
                    _94mhs(str(e))
                    return _5Oqx2
                _Bw5yI.prettyprint()
        return _mKcX1

    def _ZwR51(argv=None):
        _jGYLk = argparse.ArgumentParser(description='Stonefish License Manager.', formatter_class=RichHelpFormatter)
        _jGYLk.add_argument('--version', '-v', action='version', version=_XrBJd(), help='display version information')
        _0JkVK = _jGYLk.add_subparsers(title='subcommands', required=True)
        _w9sdb = _0JkVK.add_parser('versions', help='Display version information, including dependencies', aliases=['vv'], formatter_class=_jGYLk.formatter_class)
        _w9sdb.set_defaults(func=lambda _OOzJu: _dwdkm())
        _CP1cQ = _0JkVK.add_parser('list', help='List installed licenses', aliases=['ls', 'show', 'info'], formatter_class=_jGYLk.formatter_class)
        _CP1cQ.add_argument('-r', '--raw', action='store_true', help='Show raw license data')
        _CP1cQ.add_argument('-k', '--show-keys', action='store_true', help='Show license keys')
        _CP1cQ.add_argument('license_ids_or_keys', type=str, nargs='*', help='License IDs or keys (optional)')
        _CP1cQ.set_defaults(func=lambda _FQrY5: _BYrIP(set(_FQrY5.license_ids_or_keys), _FQrY5.raw, _FQrY5.show_keys))
        _lL2Fa = _0JkVK.add_parser('install', help='Install (and activate) licenses', aliases=['add', 'a'], formatter_class=_jGYLk.formatter_class)
        _lL2Fa.add_argument('license_file', type=str, help='License file')
        _lL2Fa.set_defaults(func=lambda _vXuGe: _iDKPc(str(_vXuGe.license_file)))
        _LxMoJ = _0JkVK.add_parser('uninstall', help='Uninstall (and deactivate) licenses', aliases=['remove', 'rm', 'delete', 'del'], formatter_class=_jGYLk.formatter_class)
        _LxMoJ.add_argument('license_key_or_id', type=str, nargs='+', help='License keys or IDs')
        _LxMoJ.add_argument('-y', '--yes', action='store_true', help='Automatic yes to prompts')
        _LxMoJ.set_defaults(func=lambda _AfMGj: _s4gqx(_AfMGj.license_key_or_id, _AfMGj.yes))
        _lL2Fa = _0JkVK.add_parser('activate', help='Activate machine for license', formatter_class=_jGYLk.formatter_class)
        _lL2Fa.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _lL2Fa.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _lL2Fa.set_defaults(func=lambda _J3ch6: _22de9(_J3ch6.license_file_or_id_or_key, set(_J3ch6.machine_fingerprints)))
        _lL2Fa = _0JkVK.add_parser('deactivate', help='Deactivate machine for license', formatter_class=_jGYLk.formatter_class)
        _lL2Fa.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _lL2Fa.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _lL2Fa.set_defaults(func=lambda _AUNAj: _LNKOd(_AUNAj.license_file_or_id_or_key, set(_AUNAj.machine_fingerprints)))
        _CP1cQ = _0JkVK.add_parser('fingerprint', help='Display machine fingerprint', aliases=['fp'], formatter_class=_jGYLk.formatter_class)
        _CP1cQ.set_defaults(func=_eVoeo)
        _dwIre = _0JkVK.add_parser('refresh', help='Refresh license files and cache', formatter_class=_jGYLk.formatter_class)
        _dwIre.set_defaults(func=_38B1q)
        _5W4Dv = _0JkVK.add_parser('cache', help='Manage the cache', formatter_class=_jGYLk.formatter_class)
        _osidB = _5W4Dv.add_subparsers(title='subcommands', required=True)
        _MdIn3 = _osidB.add_parser('clear', help='Remove all items from the cache', aliases=['clean'], formatter_class=_jGYLk.formatter_class)
        _MdIn3.set_defaults(func=_zVCMP)
        _vs6eP = _osidB.add_parser('dir', help='Show the cache directory', formatter_class=_jGYLk.formatter_class)
        _vs6eP.set_defaults(func=_tdJ6S)
        _AUNAj = _jGYLk.parse_args(argv)
        return _AUNAj.func(_AUNAj)

    def _XrBJd():
        _1dHhd = _ULPFF('stonefish-license-manager')
        return '\n'.join([f'Stonefish License Manager {_1dHhd} [Python {_iNLlV()}]'])

    def _dwdkm():
        for _IUaNj in python_package_info.yield_info_lines('stonefish-license-manager'):
            print(_IUaNj)

    def _38B1q(_):
        _S7RmX = _qLGoy()
        _13L5B(f'Refreshed {_S7RmX} installed licenses')
        _zVCMP(_)
        return _mKcX1

    def _zVCMP(_):
        _u7ZBC()
        _KYYgQ()
        _8JuUu()
        return _mKcX1

    def _tdJ6S(_):
        _13L5B(_4JBOP)
        return _mKcX1
_M926w()
del _M926w
