def _KVBS7(f):
    def _pfcsH(*args, **kwargs):
        return f(*args, **kwargs)
    _pfcsH.__module__ = f.__module__
    _pfcsH.__name__ = f.__name__
    _pfcsH.__doc__ = f.__doc__
    _pfcsH.__dict__.update(f.__dict__)
    f.__refcalls__ = 0
    return _pfcsH

@_KVBS7
def _HOK8e():
    global _ESZQd, _DXrdA, _txTPF, _lhrkA, _Tron3, _xphIh, _DxcmY, _0yywo, _gFYHi, _oUY9L, _rdZ7v, _XvAFl, _jhzbC, _hBrNf, _rl4q5, _XrWnY, _R717p, _R1tXt, _ohmTQ, _qwXwD, _qHHlJ, _PFhQH, _ZTZMc, _lKqLb, _5EJ2N, _qVJVV, _5E94a, _eiotx, _7dYGZ, _eo43R, _sCNsZ, _Rnzmf, _lYT3k, _q7ozR, _7iOTr, _0rlOG, _rMzYK, _RmQwA, _TGn0H, _HqpHn, _bIn0J, _0il6L, _kLf5j, _z0cxQ, _oxsJ5, _MLqjf, _r8FRZ
    from __future__ import annotations
    from cryptography.exceptions import InvalidSignature
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey
    from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey
    from dataclasses import dataclass
    from datetime import datetime, timedelta, timezone
    from email.utils import parsedate_to_datetime
    from importlib import metadata
    from importlib.util import find_spec
    from pathlib import Path
    from requests import Request
    from rich.console import Console
    from rich.panel import Panel
    from rich.prompt import Confirm, Prompt
    from rich.table import Table
    from rich.text import Text
    from rich_argparse import RichHelpFormatter
    from sys import version_info
    from typing import Any, Literal, Protocol, TYPE_CHECKING
    from urllib.parse import quote, urlsplit
    from wsgiref.handlers import format_date_time
    import argparse, base64, binascii, hashlib, hmac, json, logging, machineid, multiprocessing, os, platform, platformdirs, python_package_info, re, requests, requests_cache, shutil, socket, sys, time, uuid
    _cnOKv = platformdirs.user_data_path('slim')
    _VMujV = platformdirs.user_cache_path('slim')

    def _igKWe(package, fallback='unknown'):
        try:
            return metadata.version(package)
        except metadata.PackageNotFoundError:
            return fallback

    def _eqrJe():
        return f'{version_info.major}.{version_info.minor}.{version_info.micro}'

    def _ESZQd(dct, *_uwl5b, default=None):
        for _XeU8X in _uwl5b:
            try:
                dct = dct[_XeU8X]
            except (KeyError, TypeError, IndexError):
                return default
        return dct

    def _EFtq9(obj, eps=timedelta(minutes=5)):
        if abs(obj - datetime.now(tz=timezone.utc)) > eps:
            _x0fCG = 'Error code E044'
            raise RuntimeError(_x0fCG)

    def _OiyG5(obj, eps=timedelta(minutes=5)):
        if obj > datetime.now(tz=timezone.utc) + eps:
            _ilMBW = 'Error code E045'
            raise RuntimeError(_ilMBW)

    def _4Sjqo(ts, **_CCePr):
        _OiyG5(datetime.fromtimestamp(ts, tz=timezone.utc), **_CCePr)

    def _DXrdA(res):
        _DtbbL = parsedate_to_datetime(res.headers['Date'])
        if getattr(res, 'from_cache', False):
            _OiyG5(_DtbbL)
        else:
            _EFtq9(_DtbbL)

    def _QKoq5(td):
        _uQNmL = abs(td)
        if _uQNmL < timedelta(seconds=1):
            return 'just now'
        _dPTcI = td > timedelta(0)
        for _zxjm6, _HgDm7, _3GY3D in [('second', _uQNmL.seconds, timedelta(minutes=1)), ('minute', round(_uQNmL.seconds / 60), timedelta(hours=1)), ('hour', round(_uQNmL.seconds / 3600), timedelta(days=1))]:
            if _uQNmL < _3GY3D:
                _lzSFr = '' if _HgDm7 == 1 else 's'
                return f'in {_HgDm7} {_zxjm6}{_lzSFr}' if _dPTcI else f'{_HgDm7} {_zxjm6}{_lzSFr} ago'
        if _uQNmL.days < 100:
            _HgDm7 = _uQNmL.days
            if _HgDm7 == 0:
                return 'today'
            if _dPTcI:
                if _HgDm7 == 1:
                    return 'tomorrow'
                return f'in {_HgDm7} days'
            if _HgDm7 == 1:
                return 'yesterday'
            return f'{_HgDm7} days ago'
        if _uQNmL.days < 365:
            _HgDm7 = round(_uQNmL.days / 30)
            _lzSFr = '' if _HgDm7 == 1 else 's'
            if _dPTcI:
                return f'in {_HgDm7} month{_lzSFr}'
            return f'{_HgDm7} month{_lzSFr} ago'
        _HgDm7 = round(_uQNmL.days / 365)
        _lzSFr = '' if _HgDm7 == 1 else 's'
        if _dPTcI:
            return f'in {_HgDm7} year{_lzSFr}'
        return f'{_HgDm7} year{_lzSFr} ago'

    def _c0AU2(var_names):
        assert isinstance(var_names, (list, tuple))
        for _eC2bv in var_names:
            assert isinstance(_eC2bv, str)
            assert _eC2bv != ''
        for _FJ0ZM, _hn60z in [('global', globals()), ('environment', os.environ)]:
            for _R5JAC in var_names:
                if _R5JAC in _hn60z:
                    yield (_FJ0ZM, _R5JAC, _hn60z[_R5JAC])

    def _jVEGT(string, k):
        return '\n'.join((string[_9u300:_9u300 + k] for _9u300 in range(0, len(string), k)))

    def _txTPF(string):
        if sys.version_info >= (3, 11):
            return datetime.fromisoformat(string)
        try:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S.%f%z')
        except ValueError:
            return datetime.strptime(string, '%Y-%m-%dT%H:%M:%S%z')

    def _rpuQp(string, prefix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix)
        if string.startswith(prefix):
            return string[len(prefix):]
        return string

    def _7Xblr(*_Jtz5d):
        for _0pK09 in _Jtz5d:
            yield from _0pK09

    def _hqHOZ(function):

        def _XZ1kW(*_OVLLi, **_Co6MT):
            _OVLLi = [tuple(_hSulv) if isinstance(_hSulv, list) else _hSulv for _hSulv in _OVLLi]
            _Co6MT = {key: tuple(value) if isinstance(value, list) else value for key, value in _Co6MT.items()}
            return function(*_OVLLi, **_Co6MT)
        _XZ1kW.cache_clear = function.cache_clear
        return _XZ1kW

    def _TAgnC(gen):
        cache = set()

        def _JBBTM(*_RVnfH, **_yk3uC):
            for _qVVzG in gen(*_RVnfH, **_yk3uC):
                if _qVVzG in cache:
                    continue
                yield _qVVzG
                cache.add(_qVVzG)
        return _JBBTM

    def _pJm8K(key):
        if key.startswith('DEMO'):
            return '1fddcec8-8dd3-4d8d-9b16-215cac0f9b52'
        return '109c23d2-6cdd-4faf-bd8a-96c242733638'
    _ZIfrq = Console(highlight=True)
    _aQrz8 = Console(stderr=True, style='yellow', highlight=False)
    _zmLT0 = Console(stderr=True, style='red', highlight=False)

    def _lhrkA(msg='', **_OZuOx):
        _ZIfrq.print(msg, **_OZuOx)

    def _i5A1B(msg):
        _aQrz8.print(f'Warning: {msg}')

    def _VWpFZ(msg):
        _zmLT0.print(f'\nError: {msg}')

    class _Tron3(Exception):

        def __init__(self, message, code):
            super().__init__(message)
            self.code = code

        def show(self):
            _VWpFZ(f'{self} ({self.code})')

    class _xphIh(Exception):
        pass

    class _5CyRv(Exception):
        pass

    def _DxcmY(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _viLgH(serialization.load_pem_public_key(key_bytes))

    def _0yywo(key_bytes):
        assert isinstance(key_bytes, bytes)
        return _viLgH(serialization.load_der_public_key(key_bytes))

    def _WaTbg(key_bytes):
        _jKJeA = _0yywo(key_bytes)
        assert isinstance(_jKJeA, _oUY9L)
        return _jKJeA

    def _viLgH(key):
        if isinstance(key, Ed25519PublicKey):
            return _gFYHi(key)
        if isinstance(key, RSAPublicKey):
            return _oUY9L(key)
        _K1JYB = 'Unknown key'
        raise ValueError(_K1JYB)

    class _cMf6S:
        pass

    class _gFYHi(_cMf6S):
        alg = 'ed25519'

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(Ed25519PublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, Ed25519PublicKey)
            self.key = key

        def verify(self, sig_bytes, msg_bytes):
            try:
                self.key.verify(sig_bytes, msg_bytes)
            except InvalidSignature:
                _7pGpU = 'SLiM: Ed25519 signature verification error. (Wrong key?)'
                raise _xphIh(_7pGpU) from None

        def verify_response(self, res):
            try:
                _ofyoy = res.created_at.replace(tzinfo=timezone.utc)
            except AttributeError:
                _ofyoy = datetime.now(tz=timezone.utc)
            if _ofyoy < datetime(2024, 2, 7, 0, 0, tzinfo=timezone.utc):
                return
            alg, _kk60u, _pJAfA = _4kSZU(res)
            if alg.lower() != self.alg:
                _kk60u = f'Expected alg {self.alg}, got {alg}'
                raise ValueError(_kk60u)
            self.verify(_pJAfA, _kk60u)

    class _oUY9L(_cMf6S):

        @classmethod
        def from_bytes(cls, key_bytes):
            return cls(RSAPublicKey.from_public_bytes(key_bytes))

        @classmethod
        def from_hex(cls, key_hex):
            return cls.from_bytes(bytes.fromhex(key_hex))

        @classmethod
        def from_base64(cls, key_b64):
            return cls.from_bytes(base64.b64decode(key_b64))

        def __init__(self, key):
            assert isinstance(key, RSAPublicKey)
            self.key = key
            self.pad_pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH)
            self.pad_pkcs1v15 = padding.PKCS1v15()

        def verify(self, sig_bytes, msg_bytes, padding):
            if padding.lower() == 'pss':
                _eENNm = self.pad_pss
            elif padding.lower() == 'pkcs1v15':
                _eENNm = self.pad_pkcs1v15
            else:
                _MQXRG = f'Unknown padding {padding}'
                raise ValueError(_MQXRG)
            try:
                self.key.verify(sig_bytes, msg_bytes, _eENNm, hashes.SHA256())
            except InvalidSignature:
                _MQXRG = 'SLiM: RSA signature verification error. (Wrong key?)'
                raise _xphIh(_MQXRG) from None

        def verify_response(self, *_VIw5k, **_Way0j):
            _zDB3j, _FqXUM, _vJFGb = _4kSZU(*_VIw5k, **_Way0j)
            if _zDB3j.lower() == 'rsa-pss-sha256':
                self.verify(_vJFGb, _FqXUM, padding='pss')
                return
            if _zDB3j.lower() == 'rsa-sha256':
                self.verify(_vJFGb, _FqXUM, padding='pkcs1v15')
                return
            _FqXUM = f'Unknown RSA alg {_zDB3j}'
            raise ValueError(_FqXUM)

    def _4kSZU(res):
        _S7fqs = hashlib.sha256(res.content).digest()
        _erkpW = base64.b64encode(_S7fqs).decode()
        if f'sha-256={_erkpW}' != res.headers['Digest']:
            _Qz97g = 'SLiM: Invalid response digest'
            raise RuntimeError(_Qz97g)
        _ewE0o = urlsplit(res.request.url)
        _8hPED = '\n'.join([f'(request-target): {res.request.method.lower()} {res.request.path_url}', f'host: {_ewE0o.netloc}', f"date: {res.headers['Date']}", f'digest: sha-256={_erkpW}']).encode()
        _shmWN = _v55Gs(res.headers['Keygen-Signature'])
        return (_shmWN['algorithm'], _8hPED, base64.b64decode(_shmWN['signature']))

    def _v55Gs(string):
        _nr9WE = {}
        for _Wyn3K in re.split(',\\s*', string):
            _DgTH2 = re.match('([^=]+)="([^"]+)"', _Wyn3K)
            assert _DgTH2
            _nr9WE[_DgTH2.group(1)] = _DgTH2.group(2)
        return _nr9WE
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @cache
    def _rdZ7v():
        if _KXwKJ():
            return 'google.colab'
        _ow56V = _Md0SX()
        if _ow56V:
            return f'github-actions/{_ow56V}'
        _JMheI = _uvoXq()
        if _JMheI:
            return f'travis-ci/{_JMheI}'
        _uscIn = _eGFcL()
        if _uscIn:
            return f'circle-ci/{_uscIn}'
        _zcX4k = _iIOPP()
        if _zcX4k:
            return 'gitlab-ci/{gitlab_project_namespace}'
        if _w6JIz():
            return 'jenkins'
        if _VSGnm():
            return 'docker'
        return machineid.id().strip()

    def _VSGnm():
        _4F42r = Path('/proc/self/cgroup')
        return Path('/.dockerenv').is_file() or (_4F42r.is_file() and 'docker' in _4F42r.read_text())

    def _KXwKJ():
        try:
            _IoAbk = find_spec('google.colab')
        except ModuleNotFoundError:
            return False
        return _IoAbk is not None

    def _Md0SX():
        if _SjFZb([('CI', 'true'), ('GITHUB_ACTIONS', 'true'), 'GITHUB_ACTION', 'GITHUB_ACTION_REPOSITORY', 'GITHUB_ACTOR', 'GITHUB_ACTOR_ID', 'GITHUB_API_URL', 'GITHUB_BASE_REF', 'GITHUB_ENV', 'GITHUB_EVENT_NAME', 'GITHUB_EVENT_PATH', 'GITHUB_GRAPHQL_URL', 'GITHUB_HEAD_REF', 'GITHUB_JOB', 'GITHUB_PATH', 'GITHUB_REF', 'GITHUB_REF_NAME', 'GITHUB_REF_PROTECTED', 'GITHUB_REF_TYPE', 'GITHUB_REPOSITORY', 'GITHUB_REPOSITORY_ID', 'GITHUB_REPOSITORY_OWNER', 'GITHUB_REPOSITORY_OWNER_ID', 'GITHUB_RETENTION_DAYS', 'GITHUB_RUN_ATTEMPT', 'GITHUB_RUN_ID', 'GITHUB_RUN_NUMBER', 'GITHUB_SERVER_URL', 'GITHUB_SHA', 'GITHUB_STEP_SUMMARY', 'GITHUB_WORKFLOW', 'GITHUB_WORKFLOW_REF', 'GITHUB_WORKFLOW_SHA', 'GITHUB_WORKSPACE', 'RUNNER_ARCH', 'RUNNER_NAME', 'RUNNER_OS', 'RUNNER_TEMP', 'RUNNER_TOOL_CACHE']):
            return os.environ['GITHUB_REPOSITORY_OWNER']
        return None

    def _uvoXq():
        if _SjFZb([('CI', 'true'), ('TRAVIS', 'true'), ('CONTINUOUS_INTEGRATION', 'true'), ('HAS_JOSH_K_SEAL_OF_APPROVAL', 'true'), ('USER', 'travis'), ('RAILS_ENV', 'test'), ('RACK_ENV', 'test'), ('MERB_ENV', 'test'), 'TRAVIS_ALLOW_FAILURE', 'TRAVIS_APP_HOST', 'TRAVIS_BRANCH', 'TRAVIS_BUILD_DIR', 'TRAVIS_BUILD_ID', 'TRAVIS_BUILD_NUMBER', 'TRAVIS_BUILD_WEB_URL', 'TRAVIS_COMMIT', 'TRAVIS_COMMIT_MESSAGE', 'TRAVIS_COMMIT_RANGE', 'TRAVIS_COMPILER', 'TRAVIS_DEBUG_MODE', 'TRAVIS_DIST', 'TRAVIS_REPO_SLUG']):
            _wBZMB, _SCD8D = os.environ['TRAVIS_REPO_SLUG'].split('/')
            return _wBZMB
        return None

    def _eGFcL():
        if _SjFZb([('CI', 'true'), ('CIRCLE', 'true'), 'CIRCLE_BRANCH', 'CIRCLE_BUILD_NUM', 'CIRCLE_BUILD_URL', 'CIRCLE_JOB', 'CIRCLE_NODE_INDEX', 'CIRCLE_NODE_TOTAL', 'CIRCLE_OIDC_TOKEN', 'CIRCLE_OIDC_TOKEN_V2', 'CIRCLE_PR_NUMBER', 'CIRCLE_PR_REPONAME', 'CIRCLE_PR_USERNAME', 'CIRCLE_PROJECT_REPONAME', 'CIRCLE_PROJECT_USERNAME', 'CIRCLE_PULL_REQUEST', 'CIRCLE_PULL_REQUESTS', 'CIRCLE_REPOSITORY_URL', 'CIRCLE_SHA1', 'CIRCLE_TAG', 'CIRCLE_WORKFLOW_ID', 'CIRCLE_WORKFLOW_JOB_ID', 'CIRCLE_WORKFLOW_WORKSPACE_ID', 'CIRCLE_WORKING_DIRECTORY', 'CIRCLE_INTERNAL_TASK_DATA']):
            return os.environ['CIRCLE_PROJECT_USERNAME']
        return None

    def _iIOPP():
        if _SjFZb(['CHAT_CHANNEL', 'CHAT_INPUT', 'CHAT_USER_ID', 'CI', 'CI_API_V4_URL', 'CI_API_GRAPHQL_URL', 'CI_BUILDS_DIR', 'CI_COMMIT_AUTHOR', 'CI_COMMIT_BEFORE_SHA', 'CI_COMMIT_BRANCH', 'CI_COMMIT_DESCRIPTION', 'CI_COMMIT_MESSAGE', 'CI_COMMIT_REF_NAME', 'CI_COMMIT_REF_PROTECTED', 'CI_COMMIT_REF_SLUG', 'CI_COMMIT_SHA', 'CI_COMMIT_SHORT_SHA', 'CI_COMMIT_TIMESTAMP', 'CI_COMMIT_TITLE', 'CI_CONCURRENT_ID', 'CI_CONCURRENT_PROJECT_ID', 'CI_CONFIG_PATH', 'CI_DEBUG_TRACE', 'CI_DEBUG_SERVICES', 'CI_DEFAULT_BRANCH', 'CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX', 'CI_DEPENDENCY_PROXY_PASSWORD', 'CI_DEPENDENCY_PROXY_SERVER', 'CI_DEPENDENCY_PROXY_USER', 'CI_DEPLOY_FREEZE', ('GITLAB_CI', 'true'), 'GITLAB_FEATURES', 'GITLAB_USER_EMAIL', 'GITLAB_USER_ID', 'GITLAB_USER_LOGIN', 'GITLAB_USER_NAME']):
            return os.environ['CI_PROJECT_NAMESPACE']
        return None

    def _w6JIz():
        return _SjFZb(['BUILD_NUMBER', 'BUILD_ID', 'BUILD_DISPLAY_NAME', 'JOB_NAME', 'BUILD_TAG', 'EXECUTOR_NUMBER', 'NODE_NAME', 'NODE_LABELS', 'WORKSPACE', 'JENKINS_HOME', 'JENKINS_URL', 'BUILD_URL', 'JOB_URL'])

    def _SjFZb(keys):
        for _08E5b in keys:
            if isinstance(_08E5b, str):
                if _08E5b not in os.environ:
                    return False
            else:
                assert isinstance(_08E5b, tuple)
                _54ZdT, _axcV5 = _08E5b
                if _ESZQd(os.environ, _54ZdT) != _axcV5:
                    return False
        return True

    class _XvAFl(Protocol):
        key_type: str

        @property
        def data(self):
            ...

        @property
        def key(self):
            ...

        @property
        def product_name(self):
            ...

        @property
        def product_id(self):
            ...

        @property
        def vendor_name(self):
            ...

        @property
        def license_id(self):
            ...

        @property
        def user(self):
            ...

        @property
        def created(self):
            ...

        @property
        def expiry(self):
            ...

        @property
        def max_machines(self):
            ...

        @property
        def num_machines(self):
            ...

        @property
        def usage_type(self):
            return None

        @property
        def activations(self):
            return (None, None)

        def list_machines(self):
            ...

        def prettyprint(self, show_key=False):
            ...

        def _prettyprint(self, is_valid, validation_code=None, show_key=False):
            _mlg2d = Table(box=None, padding=(0, 4, 0, 0), show_header=False)
            if self.product_name:
                _mlg2d.add_row('Product', Text(self.product_name, style='cyan'))
            else:
                _mlg2d.add_row('Product ID', str(self.product_id))
            if self.vendor_name:
                _mlg2d.add_row('Vendor', self.vendor_name)
            if self.license_id:
                _mlg2d.add_row('License ID', str(self.license_id))
            if show_key and self.key:
                _mlg2d.add_row('Key', self.key)
            if self.usage_type:
                _mlg2d.add_row('Usage type', Text(self.usage_type.title(), style='blue'))
            _Ttx2D = None
            if is_valid is True:
                _mlg2d.add_row('Valid', Text('True', style='green'))
                _Ttx2D = 'green'
            elif is_valid is False:
                _RPaQX = 'False'
                if validation_code:
                    _RPaQX += f' ({validation_code})'
                _mlg2d.add_row('Valid', Text(_RPaQX, style='red'))
                _Ttx2D = 'red'
            else:
                assert is_valid == 'unknown'
                _RPaQX = 'Unknown'
                if validation_code:
                    _RPaQX += f' ({validation_code})'
                _mlg2d.add_row('Valid', Text(_RPaQX, style='yellow'))
                _Ttx2D = 'bright_black'
            if (email := _ESZQd(self.user, 'email')):
                _mlg2d.add_row('User', email)
            if self.created:
                _mlg2d.add_row('Created', self.created.strftime('%Y-%m-%d'))
            _1mcTA = datetime.now(tz=timezone.utc)
            if self.expiry:
                _HhiK8 = self.expiry - _1mcTA
                if _HhiK8 < timedelta(0):
                    _S4qwF = 'red'
                    _Ttx2D = 'red'
                elif _HhiK8.days < 30:
                    _S4qwF = 'yellow'
                    if _Ttx2D != 'red':
                        _Ttx2D = 'yellow'
                else:
                    _S4qwF = None
                _mlg2d.add_row('Expiry', Text(f"{self.expiry.strftime('%Y-%m-%d')} ({_QKoq5(_HhiK8)})", style=_S4qwF))
            _dkQqf, _EUYf3 = self.activations
            if _dkQqf is not None:
                _0vPE5 = None
                _RPaQX = str(_dkQqf)
                if _EUYf3 is not None:
                    if _dkQqf >= _EUYf3:
                        _0vPE5 = 'yellow'
                    _RPaQX += f'/{_EUYf3}'
                _mlg2d.add_row('Activations', Text(_RPaQX, style=_0vPE5))
            if self.num_machines is not None:
                _RPaQX = str(self.num_machines)
                if self.max_machines is not None:
                    _RPaQX += f'/{self.max_machines}'
                _mlg2d.add_row('Seats used', _RPaQX)
            for _Su8mT, _sixhd in enumerate(self.list_machines()):
                assert isinstance(_sixhd, dict)
                _11TZx = _ESZQd(_sixhd, 'hostname') or f'machine {_Su8mT}'
                _dtZAc = []
                _fWzEN = False
                if (fp := _ESZQd(_sixhd, 'fingerprint')):
                    _dtZAc.append(fp)
                    _fWzEN = fp == _rdZ7v()
                _kR9vm = _11TZx
                if _fWzEN:
                    _kR9vm = f'[bold]{_kR9vm}[/]'
                if _dtZAc:
                    _kR9vm += f" ({', '.join(_dtZAc)})"
                _mlg2d.add_row('Machines' if _Su8mT == 0 else '', _kR9vm)
            _U6xHA = Panel(_mlg2d, title_align='left', border_style=_Ttx2D)
            _lhrkA(_U6xHA)

    class _sSxYf:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        products_codes = ('stp01',)
    _Sic0C = {product_code: vendor for vendor in [_sSxYf] for product_code in vendor.products_codes}

    def _VXL4z(product_code):
        try:
            return _Sic0C[product_code]
        except KeyError:
            _VkdVl = f"Cannot use SLiM with LicenseSpring product code {product_code}... If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _Tron3(_VkdVl, 'CL_VENDOR_ERROR') from None
    _dLKCv = platformdirs.user_data_path('slim', 'MondayTech') / 'license_spring'
    _WeVY4 = _WaTbg(base64.b64decode('MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwEt7ZQWSzeBYNBwyi3KW+XU/6I+ju90R5ZpTvSE4VWL8KSgVJ6bWKIhaKTL2hbUpIQQgS5ZKfa4SEEMdIm5kxe0u2F64JFAVQunx/1O/UXsD7ADVt93Q/hxA9Npa16tKepZoyhi79sxpaxyy/WTdsZKuTLApX7bWX6/XPhaPjNyiWeeK2Naka44B+F+PwN/ey3rZUra3pBltShwy2dmKIxJVmprf5ttMYBB+ouqPin3VgDw5Jq1FZwpLBiOe+ogR+sHu7QYWwLq6AgC4e3JqgryEvqfJr/XkvOnAdcAIZm6tK6DdnLWCy6Onrk7t0VQK5nnGF1CKE+jcAByWopcIVCwfYrs1UCSY1YibKXNJoyvEhgLyCC+KAgXKf8omcg1Q18XKu5XSrvrCzXLnRnaFNpFDjcg5AJJab78hX7qGPC+e8PjuBYwh2vtx5mFj7/c+T59JM/vXwwvW9DsnDztDWEDFhzGanU71NgwrZbRoNSyTW0UjbZsyJVSIX6233Ng0y5L9mDe8p8P+u1B0sXAAozEKL/yG4Qu5r4LIw4iv6JVPT1xbWlH4Vc4KaN3toaf4+G0EkFy6ncvBncWifLARSoWpQ5YsygDdQNVYdmMsoQ76UTuNxo3eZ0sQJjbQVBqlkcXrAdtUCpuojPRsl/Xs9zVOJrzZPG0I98E5quNbRkMCAwEAAQ=='))
    _rc8wM = 'https://api.licensespring.com/api/v4'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _mVDqd = requests_cache.CachedSession(cache_name=_VMujV / 'license_spring', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _jhzbC(_XvAFl):
        key_type = 'License Spring'

        @classmethod
        def from_file(cls, path):
            with Path(path).open() as _qCLUz:
                _VNMhw = _qCLUz.read()
            try:
                _4NKPf = base64.b64decode(_VNMhw)
            except binascii.Error:
                _e4Hiw = f'Invalid license file {path}'
                raise _Tron3(_e4Hiw, 'LS_INVALID_FILE') from None
            _CEQD7 = json.loads(_4NKPf)
            _bdw9D = base64.b64decode(_CEQD7.pop('license_signature_v2'))
            _mBwYe = json.dumps(_CEQD7, separators=(',', ':')).encode()
            _WeVY4.verify(_bdw9D, _mBwYe, padding='pkcs1v15')
            _OiyG5(datetime.strptime(_CEQD7['date'], '%a %b %d %Y %H:%M:%S GMT%z'))
            return cls(_CEQD7)

        @classmethod
        def from_key(cls, product_code, license_key):
            _oBFY6 = {'product_details': {'short_code': product_code}, 'license_key': license_key}
            return cls(_oBFY6)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert _ESZQd(data, 'license_key')
            _C5tEV = _ESZQd(data, 'product_details', 'short_code')
            assert _C5tEV
            self.vendor = _VXL4z(_C5tEV)
            self._data = data

        @property
        def data(self):
            return self._data

        @property
        def license_id(self):
            return _ESZQd(self.data, 'id')

        @property
        def product_id(self):
            return _ESZQd(self.data, 'product_details', 'product_id')

        @property
        def product_code(self):
            return self.data['product_details']['short_code']

        @property
        def product_name(self):
            return _ESZQd(self.data, 'product_details', 'product_name')

        @property
        def key(self):
            return self.data['license_key']

        @property
        def created(self):
            if (date := _ESZQd(self.data, 'date')):
                return datetime.strptime(date, '%a %b %d %Y %H:%M:%S GMT%z')
            return None

        @property
        def expiry(self):
            if (vp := self.data.get('validity_period')):
                return _txTPF(vp)
            return None

        @property
        def user(self):
            user = _ESZQd(self.data, 'customer')
            if not user:
                return {}
            _a36dY = []
            if (fn := user['first_name']):
                _a36dY.append(fn)
            if (ln := user['last_name']):
                _a36dY.append(ln)
            return {'name': ' '.join(_a36dY) if _a36dY else None, 'email': user['email'] or None}

        @property
        def vendor_name(self):
            return self.vendor.name

        def list_machines(self):
            return []

        def validate(self, shared_key, api_key, activate_if_required=True, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _i1Y5V = _mVDqd.get(url=f'{_rc8wM}/check_license', headers=_FAbDu(shared_key, api_key), params={'product': self.product_code, 'hardware_id': _rdZ7v(), 'license_key': self.key}, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            _RH3SQ(_i1Y5V)
            _DXrdA(_i1Y5V)
            data = _i1Y5V.json()
            if data.get('code') in {'license_not_active', 'device_not_found'} and activate_if_required:
                self.activate(shared_key, api_key)
                _VPqdN()
                return self.validate(shared_key, api_key, activate_if_required=activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=True)
            if not _i1Y5V.ok and raise_on_error:
                raise _Tron3(data['message'], 'LS_VALIDATION_ERROR')
            self._data = data
            return data

        def activate(self, shared_key, api_key, app_version=None):
            data = {'product': self.product_code, 'hardware_id': _rdZ7v(), 'license_key': self.key, 'os_ver': platform.platform(), 'hostname': socket.gethostname(), 'mac_address': ':'.join((f'{_YJpfa:02x}' for _YJpfa in uuid.getnode().to_bytes(6, byteorder='big')))}
            _eohtP = _igKWe('stonefish-license-manager')
            data['sdk_ver'] = f'Stonefish License Manager {_eohtP}'
            if app_version:
                data['app_ver'] = app_version
            _ba9Id = requests.post(url=f'{_rc8wM}/activate_license', headers=_FAbDu(shared_key, api_key), json=data, timeout=10)
            _RH3SQ(_ba9Id)
            _DXrdA(_ba9Id)
            json = _ba9Id.json()
            if not _ba9Id.ok:
                raise _Tron3(json['message'], 'LS_ACTIVATION_ERROR')
            return json

        def deactivate(self, shared_key, api_key):
            _ZzMtb = requests.post(url=f'{_rc8wM}/deactivate_license', headers=_FAbDu(shared_key, api_key), json={'product': self.product_code, 'hardware_id': _rdZ7v(), 'license_key': self.key}, timeout=10)
            _DXrdA(_ZzMtb)
            if not _ZzMtb.ok:
                json = _ZzMtb.json()
                raise _Tron3(json['message'], 'LS_DEACTIVATION_ERROR')
            return

        def prettyprint(self, show_key=False):
            super()._prettyprint(show_key=show_key, is_valid='unknown', validation_code=None)

    def _hBrNf():
        _mVDqd.cache.clear()

    def _VPqdN():
        for _PvDis in _mVDqd.cache.responses.values():
            if _PvDis.url == f'{_rc8wM}/check_license':
                _mVDqd.cache.delete(_PvDis.cache_key)

    def _FAbDu(shared_key, api_key):
        _yhxy3 = format_date_time(time.time())
        _OH0R9 = hmac.new(bytes(shared_key, 'utf-8'), f'licenseSpring\ndate: {_yhxy3}'.encode(), hashlib.sha256).digest()
        _eiLXA = base64.b64encode(_OH0R9).decode()
        _H2ISR = ','.join(['algorithm="hmac-sha256"', 'headers="date"', f'signature="{_eiLXA}"', f'apiKey="{api_key}"'])
        return {'Content-Type': 'application/json', 'Date': _yhxy3, 'Authorization': _H2ISR}

    def _Vz10r(product_code, shared_key, api_key):
        _3xamP = _mVDqd.get(url=f'{_rc8wM}/product_details', params={'product': product_code}, headers=_FAbDu(shared_key, api_key), timeout=10)
        _RH3SQ(_3xamP)
        _DXrdA(_3xamP)
        _fQcNe = _3xamP.json()
        if not _3xamP.ok:
            raise _Tron3(_fQcNe['message'], 'LS_PRODUCT_ERROR')
        return _fQcNe

    def _RH3SQ(res):
        if (sig := res.headers.get('LicenseSignature')):
            _WeVY4.verify(base64.b64decode(sig), res.content, padding='pkcs1v15')
    if TYPE_CHECKING:
        from pathlib import Path
    _p532T = _cnOKv / 'license_spring'

    def _rl4q5(path):
        _R233G = _jhzbC.from_file(path)
        _rwAK3 = _R233G.data['product_details']['short_code']
        _aQAZx = _R233G.data['id']
        _DwnTP = _p532T / _rwAK3 / (str(_aQAZx) + '.lic')
        _DwnTP.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(path, _DwnTP)
        return _R233G

    @_TAgnC
    def _XrWnY(license_keys_or_ids=None, product_code=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _BGrSK = _p532T
        if product_code:
            _BGrSK /= product_code
        for _b4VKl in _BGrSK.rglob('*.lic'):
            _OG3oP = _jhzbC.from_file(_b4VKl)
            if license_keys_or_ids is None:
                yield (_b4VKl, _OG3oP)
            else:
                _qVI2v = str(_ESZQd(_OG3oP.data, 'id'))
                if _qVI2v in license_keys_or_ids:
                    license_keys_or_ids.remove(_qVI2v)
                    yield (_b4VKl, _OG3oP)
                    continue
                _tq5R7 = _ESZQd(_OG3oP.data, 'license_key')
                if _tq5R7 in license_keys_or_ids:
                    license_keys_or_ids.remove(_tq5R7)
                    yield (_b4VKl, _OG3oP)
                    continue

    @dataclass
    class _jwejw:
        name: str
        email: str | None
        product_ids: tuple[int]
        verify_key: VerifyKey
    _2OpcR = _jwejw('Monday Tech', 'support@mondaytech.com', (21778,), _0yywo(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfz7XiRe459sYB/PxgoMR0VKX0aA0rC+FPV8G7h02DHiYYKmtsI3o1kq7w3I6JKHpU8VnCEy2P6+W+8A0fdgTIQZJiKTsuJ7ymtX3hT/TyuIVveOsLBd5OHr0Prh/sshv4kFJTUYAROGtRVR/p/Ut2XTSaQIj02Zv9Yd8v1gMF8BsRgShG3Omyo+TfxA2OvXnlqCcSumyk2pfLtdkuGX0a5gTsG7kqY1e0RWB8LN0Ko7fCPCXuy1i/auwtGt/YALh+vL02RWb7CZSMvPEWJGh6WPwhcvywyRlEgFnKB3Ec1j3DcgUNXVQXHSYrbmveXfMkjpxokDIGWcbD3HY0agGwIDAQAB')))
    _h49uJ = _jwejw('Deecie', None, (23488,), _0yywo(base64.b64decode('MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArCITfOmahfX98LErjl8C22YRDpJjeQPJACSxBjEOAwjOwFoUNeEwVZyif0thbZVjZh4/Zp/413RoxQgSeWfoaZqsnvTV5iWBk3tN8wILmR4305fpjJHnrobJDyKoz9VUQRzwVtOkT3pbIeP/WrIz+937FO5Z2F76tMmMMlNtWgMCIEc8BT97yZPB5wXSWYozQ6WfNlm9/L2ajMce4P6kX1nKwBYkxY+MBG+7YyF66on7mG3LJUa/H1ZGVLpPNVpbd5WOL7f/vXE/RGYcwfSeQGiLEUxcwtsFhtfbjBivwxMSshOW7WLIgaC3lFKNWnT5sIeRGTeSvbFpVR5ERaiwhwIDAQAB')))
    _uDEHO = {product_id: vendor for vendor in [_2OpcR, _h49uJ] for product_id in vendor.product_ids}

    def _QhJPe(product_id):
        assert isinstance(product_id, int)
        try:
            return _uDEHO[product_id]
        except KeyError:
            _NsJwZ = f"Cannot use SLiM with Cryptolens product ID {product_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _Tron3(_NsJwZ, 'CL_VENDOR_ERROR') from None
    _tNxda = 'https://api.cryptolens.io/api'
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _5P6C0 = requests_cache.CachedSession(cache_name=_VMujV / 'cryptolens', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4))

    class _R717p(_XvAFl):
        key_type = 'Cryptolens'

        @classmethod
        def from_key(cls, product_id, key):
            assert isinstance(product_id, int)
            return cls({'ProductId': product_id, 'Key': key})

        @classmethod
        def from_file(cls, path, token, update_if_older_than=timedelta(days=30)):
            path = Path(path)
            assert path.suffix == '.skm'
            with path.open() as _KCrHG:
                _In3Iq = json.load(_KCrHG)
            _KInSa = base64.b64decode(_In3Iq['signature'])
            _9Dav6 = base64.b64decode(_In3Iq['licenseKey'])
            _7v0XR = json.loads(_9Dav6)
            _1XFAp = _QhJPe(_7v0XR['ProductId'])
            _1XFAp.verify_key.verify(sig_bytes=_KInSa, msg_bytes=_9Dav6, padding='pkcs1v15')
            _4Sjqo(_7v0XR['SignDate'])
            _4Sjqo(_7v0XR['Created'])
            if not token:
                for _tvCMe in _7v0XR['DataObjects']:
                    if _tvCMe['Name'] == 'token':
                        token = _tvCMe['StringValue']
                        break
            _qrV7T = datetime.now(tz=timezone.utc)
            _AdHCp = datetime.fromtimestamp(_7v0XR['SignDate'], tz=timezone.utc)
            if token is not None and update_if_older_than and (_qrV7T > _AdHCp + update_if_older_than):
                _In3Iq, _7v0XR = _fS83E(_7v0XR['ProductId'], _7v0XR['Key'], token, activate=False)
                _4Sjqo(_7v0XR['SignDate'])
                _4Sjqo(_7v0XR['Created'])
                with path.open('w') as _KIlGG:
                    json.dump(_In3Iq, _KIlGG)
            return cls(_7v0XR)

        def __init__(self, data):
            assert isinstance(data, dict)
            assert isinstance(_ESZQd(data, 'ProductId'), int)
            assert isinstance(_ESZQd(data, 'Key'), str)
            self._data = data
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['Key']

        @property
        def license_id(self):
            return self.data['GlobalId']

        @property
        def product_id(self):
            return self.data['ProductId']

        @property
        def created(self):
            return datetime.fromtimestamp(self.data['Created'], tz=timezone.utc)

        @property
        def product_name(self):
            for _nAuOu in self.data['DataObjects']:
                if _nAuOu['Name'] == 'productName':
                    return _nAuOu['StringValue']
            return None

        def get_token(self):
            for _QehLf in self.data['DataObjects']:
                if _QehLf['Name'] == 'token':
                    return _QehLf['StringValue']
            return None

        @property
        def expiry(self):
            if not self.data['F1']:
                return None
            if (expiry := _ESZQd(self.data, 'Expires')):
                return datetime.fromtimestamp(expiry, tz=timezone.utc)
            return None

        @property
        def user(self):
            return {'email': _ESZQd(self.data, 'Customer', 'email')}

        @property
        def max_machines(self):
            return self.data['MaxNoOfMachines']

        @property
        def num_machines(self):
            return len(self.data['ActivatedMachines'])

        def list_machines(self):
            return self.data['ActivatedMachines']

        def validate(self, token, activate=True, raise_on_error=True):
            assert isinstance(token, str)
            _iJoh8, data = _fS83E(self.product_id, self.key, token, activate=activate, raise_on_error=raise_on_error)
            _dQQEu = _iJoh8['metadata']['licenseStatus']
            if _iJoh8['result'] != 0:
                raise _Tron3(_iJoh8['message'], 'CL_RESULT_ERROR')
            if raise_on_error:
                if not _dQQEu['isValid']:
                    raise _Tron3(*_Fi3Tq(_dQQEu['reasonForInvalidity']))
                expiry = datetime.fromtimestamp(data['Expires'], tz=timezone.utc)
                if datetime.now(tz=timezone.utc) > expiry + timedelta(minutes=5):
                    _SM74J = f'License has expired on {expiry}'
                    raise _Tron3(_SM74J, 'CL_EXPIRED')
            _4Sjqo(data['SignDate'])
            _4Sjqo(data['Created'])
            self._data = data
            return _dQQEu

        def prettyprint(self, show_key=False):
            _89SQn: bool | Literal['unknown'] = 'unknown'
            _TlNbu: str | None = None
            if (token := self.get_token()):
                _Mrdy4 = self.validate(token, activate=False, raise_on_error=False)
                _89SQn = _ESZQd(_Mrdy4, 'isValid')
                assert isinstance(_89SQn, bool)
                if _89SQn is False:
                    _MbiFJ, _TlNbu = _Fi3Tq(_Mrdy4['reasonForInvalidity'])
            super()._prettyprint(show_key=show_key, is_valid=_89SQn, validation_code=_TlNbu)

    def _fS83E(product_id, key, token, activate=True, raise_on_error=True):
        _VK5v8 = {'token': token, 'ProductId': product_id, 'Key': key, 'Metadata': True, 'ModelVersion': 3, 'Sign': True, 'SignMethod': 1}
        if activate:
            _KTfEB = f'{_tNxda}/key/Activate'
            _VK5v8['MachineCode'] = _rdZ7v()
        else:
            _KTfEB = f'{_tNxda}/key/GetKey'
        _f4z03 = _5P6C0.get(_KTfEB, params=_VK5v8)
        _5UkHV = _f4z03.json()
        if not _f4z03.ok:
            _RR0a8 = f"CryptoLens: {_5UkHV['message']}"
            raise _Tron3(_RR0a8, 'CL_REQUEST_ERROR')
        if raise_on_error:
            if _5UkHV['result'] != 0:
                raise _Tron3(_5UkHV['message'], 'CL_RESULT_ERROR')
            _5j0CB = _5UkHV['metadata']['licenseStatus']
            if not _5j0CB['isValid']:
                raise _Tron3(*_Fi3Tq(_5j0CB['reasonForInvalidity']))
        _v6meS = base64.b64decode(_5UkHV['signature'])
        _QMmJA = base64.b64decode(_5UkHV['licenseKey'])
        _QhJPe(product_id).verify_key.verify(sig_bytes=_v6meS, msg_bytes=_QMmJA, padding='pkcs1v15')
        _DXrdA(_f4z03)
        return (_5UkHV, json.loads(_QMmJA))

    def _Fi3Tq(reason_for_invalidity):
        if reason_for_invalidity == 1:
            return ('License expired', 'CL_EXPIRED')
        if reason_for_invalidity == 2:
            return ('License blocked', 'CL_BLOCKED')
        return ('License validation failed', 'CL_FAILED_VALIDATION')

    def _R1tXt():
        _5P6C0.cache.clear()
    if TYPE_CHECKING:
        from datetime import timedelta
        from pathlib import Path
    _mOcEs = _cnOKv / 'cryptolens'

    def _ohmTQ(file):
        _Wva3r = _R717p.from_file(file, update_if_older_than=None, token=None)
        _A7l4i = _Wva3r.data['ProductId']
        _PYGTD = _Wva3r.data['GlobalId']
        _0bsdS = _mOcEs / str(_A7l4i) / (str(_PYGTD) + '.skm')
        _0bsdS.parent.mkdir(parents=True, exist_ok=True)
        shutil.copyfile(file, _0bsdS)
        return _Wva3r

    @_TAgnC
    def _qwXwD(license_keys_or_ids=None, product_id=None, token=None, update_if_older_than=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _snIaB = _mOcEs
        if product_id:
            _snIaB /= str(product_id)
        for _01oEv in _snIaB.rglob('*.skm'):
            _Tjvkf = _R717p.from_file(_01oEv, token=token, update_if_older_than=update_if_older_than)
            if license_keys_or_ids is None:
                yield (_01oEv, _Tjvkf)
            else:
                _dAGHH = str(_ESZQd(_Tjvkf.data, 'GlobalId'))
                if _dAGHH in license_keys_or_ids:
                    license_keys_or_ids.remove(_dAGHH)
                    yield (_01oEv, _Tjvkf)
                    continue
                _efMX7 = _ESZQd(_Tjvkf.data, 'Key')
                if _efMX7 in license_keys_or_ids:
                    license_keys_or_ids.remove(_efMX7)
                    yield (_01oEv, _Tjvkf)
                    continue
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_hqHOZ
    @cache
    def _qHHlJ(product_id, token, variable_names=()):
        for _09PSF in _7Xblr(_sNehL(product_id, variable_names), (lic for _, lic in _qwXwD(product_id=product_id, token=token, update_if_older_than=timedelta(days=30)))):
            try:
                lic.validate(token)
            except _Tron3:
                continue
            if product_id != lic.product_id:
                continue
            return lic
        _jp9td = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _Tron3(_jp9td, 'CL_NOT_FOUND')

    def _sNehL(product_id, var_names):
        for _qvD2C, _8hGEC, _sgd9u in _c0AU2(var_names):
            yield _R717p.from_key(product_id, _sgd9u)

    def _PFhQH():
        _jpNJG = requests.get('https://ipinfo.io/json', timeout=10)
        _jpNJG.raise_for_status()
        return _jpNJG.json()

    class _3NsKb:
        name = 'Monday Tech'
        email = 'support@mondaytech.com'
        vendor_id = '6697c7f2-ad29-42c6-8b78-8ddb2a56bc0b'
        verify_key = _gFYHi.from_hex('43157566ccbbe4f46fe5f02d6c1d363a3a502c3dbee36c22cf266e4015bdc23e')
    _TwE83 = {vendor.vendor_id: vendor for vendor in [_3NsKb]}

    def _LHjYV(vendor_id):
        try:
            return _TwE83[vendor_id]
        except KeyError:
            _gZvXd = f"Cannot use SLiM with vendor ID {vendor_id}. If you're a vendor and like to use the Stonefish, contact <support@mondaytech.com>."
            raise _Tron3(_gZvXd, 'KG_VENDOR_ERROR') from None

    class _ZTZMc(_XvAFl):
        key_type = 'Stonefish License Creator'

        @classmethod
        def from_file(cls, path, *_DhBRE, **_hMpE2):
            path = Path(path)
            with path.open() as _BZkCu:
                _Hmfzg = _BZkCu.read().strip().replace('\n', '')
            return cls(_Hmfzg, *_DhBRE, **_hMpE2)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _9g2kh = 'slicv1/'
            if not key.startswith(_9g2kh):
                _Hlosn = f'Expected prefix {_9g2kh!r}, got {key[:len(_9g2kh)]!r}...'
                raise ValueError(_Hlosn)
            self._key = key
            self.signing_data, _Ax59Z = self._key.split('.')
            self.enc_sig = base64.urlsafe_b64decode(_Ax59Z)
            _YxIy0 = self.signing_data[len(_9g2kh):]
            self._data = json.loads(base64.urlsafe_b64decode(_YxIy0))
            _7GrNv = _ESZQd(self._data, 'vendor', 'id')
            if not _7GrNv:
                _Hlosn = 'Key lacks vendor ID'
                raise _Tron3(_Hlosn, 'SLIC_MISSING_VENDOR_ID')
            self.vendor = _LHjYV(_7GrNv)
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            return _txTPF(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _ESZQd(self.data, 'license', 'expiry')):
                return _txTPF(expiry)
            return None

        def list_machines(self):
            return _ESZQd(self.data, 'machines', default=[])

        @property
        def product_name(self):
            return _ESZQd(self.data, 'product', 'name')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def user(self):
            return _ESZQd(self.data, 'user', default={})

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        def validate(self, raise_on_error=True):
            try:
                self.vendor.verify_key.verify(self.enc_sig, self.signing_data.encode())
            except _xphIh:
                if raise_on_error:
                    raise
                return {'valid': False, 'code': 'SIGNATURE_ERROR', 'detail': 'Signature could not be verified'}
            _Y53yy = datetime.now(tz=timezone.utc)
            _K7fAm = _txTPF(self.data['license']['created'])
            if _K7fAm > _Y53yy:
                _RduMI = 'SLIC_E043'
                _7Jq2N = 'Unknown license error'
                if raise_on_error:
                    raise _Tron3(_7Jq2N, _RduMI)
                return {'valid': False, 'code': _RduMI, 'detail': _7Jq2N}
            _A87dJ = _txTPF(expiry) if (expiry := _ESZQd(self.data, 'license', 'expiry')) else None
            if _A87dJ:
                if _K7fAm > _A87dJ:
                    _RduMI = 'SLIC_E044'
                    _7Jq2N = 'Unknown license error'
                    if raise_on_error:
                        raise _Tron3(_7Jq2N, _RduMI)
                    return {'valid': False, 'code': _RduMI, 'detail': _7Jq2N}
                if _Y53yy > _A87dJ:
                    _RduMI = 'SLIC_EXPIRED'
                    _7Jq2N = f'License has expired on {_A87dJ}'
                    if raise_on_error:
                        raise _Tron3(_7Jq2N, _RduMI)
                    return {'valid': False, 'code': _RduMI, 'detail': _7Jq2N}
            _KhLvF = _ESZQd(self.data, 'machines')
            if _KhLvF:
                _OkiGZ = _rdZ7v()
                if _OkiGZ not in _KhLvF:
                    _RduMI = 'SLIC_MACHINE_ERROR'
                    _7Jq2N = f'License not valid on this machine (fingerprint {_OkiGZ})'
                    if raise_on_error:
                        raise _Tron3(_7Jq2N, _RduMI)
                    return {'valid': False, 'code': _RduMI, 'detail': _7Jq2N}
            return {'valid': True, 'code': None, 'detail': ''}

        def prettyprint(self, show_key=False):
            _va1o0 = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_ESZQd(_va1o0, 'valid'), validation_code=_ESZQd(_va1o0, 'code'))
    _akbeT = _cnOKv / 'slic'

    def _lKqLb(data):
        _sN5dZ = _ZTZMc(data)
        _FuAIK = _sN5dZ.data['product']['id']
        _7iJlj = _sN5dZ.data['license']['id']
        _PBa2R = _akbeT / _FuAIK / (_7iJlj + '.key')
        _PBa2R.parent.mkdir(parents=True, exist_ok=True)
        _7KOQV, _ulo3Z = _sN5dZ.key.split('/')
        data, _6jfMt = _ulo3Z.split('.')
        with _PBa2R.open('w') as _khH3d:
            _khH3d.write(_7KOQV + '/\n' + _jVEGT(data, 60) + '\n.\n' + _jVEGT(_6jfMt, 60))
        return _sN5dZ

    @_TAgnC
    def _5EJ2N(license_keys_or_ids=None, product_id=None):
        assert license_keys_or_ids is None or isinstance(license_keys_or_ids, set)
        _ksy2m = _akbeT
        if product_id:
            _ksy2m /= product_id
        for _V4MvG in _ksy2m.rglob('*.key'):
            _bYWCT = _ZTZMc.from_file(_V4MvG)
            if license_keys_or_ids is None:
                yield (_V4MvG, _bYWCT)
            else:
                _kWHM4 = _ESZQd(_bYWCT.data, 'license', 'id')
                if _kWHM4 in license_keys_or_ids:
                    license_keys_or_ids.remove(_kWHM4)
                    yield (_V4MvG, _bYWCT)
                    continue
                if _bYWCT.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_bYWCT.key)
                    yield (_V4MvG, _bYWCT)
                    continue

    def _cvC0V(license_string):
        assert not license_string.startswith('key/')
        if license_string.startswith('fp/'):
            return (license_string[3:], True)
        return (license_string, False)

    def _qVJVV(string, prefix, suffix):
        if sys.version_info >= (3, 9):
            return string.removeprefix(prefix).removesuffix(suffix)
        if string.startswith(prefix):
            string = string[len(prefix):]
        if string.endswith(suffix):
            string = string[:-len(suffix)]
        return string

    @dataclass
    class _5E94a:
        name: str
        email: str | None
        account_id: str
        verify_key: Ed25519
    _7tLDo = _5E94a(name='Monday Tech', email='support@mondaytech.com', account_id='109c23d2-6cdd-4faf-bd8a-96c242733638', verify_key=_gFYHi.from_hex('cee3f0572684018bd7e4c77ed82c91b6631ebd110ed8cdcf8ecfc8e2d4cf41e1'))
    _qojjh = _5E94a(name='Keygen demo', email=None, account_id='1fddcec8-8dd3-4d8d-9b16-215cac0f9b52', verify_key=_gFYHi.from_hex('e8601e48b69383ba520245fd07971e983d06d22c4257cfd82304601479cee788'))
    _WIUUn = {vendor.account_id: vendor for vendor in [_7tLDo, _qojjh]}

    def _eiotx(account_id):
        try:
            return _WIUUn[account_id]
        except KeyError:
            _CJ88r = f"Cannot use SLiM with Keygen account_id {account_id}. If you'd like to use the Stonefish License Manager, contact support@mondaytech.com"
            raise _Tron3(_CJ88r, 'KG_VENDOR_ERROR') from None

    class _7dYGZ(_XvAFl):
        key_type = 'Keygen offline'

        @classmethod
        def from_file(cls, path):
            assert isinstance(path, (str, Path))
            path = Path(path)
            with path.open() as _cg5DT:
                _EbVID = _cg5DT.read().strip().replace('\n', '')
            assert _EbVID, f'Empty license file {path}'
            return cls(_EbVID)

        def __init__(self, key):
            assert isinstance(key, str)
            key = key.strip().replace('\n', '')
            _mAWIU = 'key/'
            if not key.startswith(_mAWIU):
                _2vqQ6 = f'Expected prefix key/, got {key[:len(_mAWIU)]}...'
                raise ValueError(_2vqQ6)
            self._key = key
            _grHWM, _7l6f0 = self._key.split('.')
            _QtQYu = base64.urlsafe_b64decode(_7l6f0)
            self._data = json.loads(base64.urlsafe_b64decode(_grHWM[len(_mAWIU):]))
            _atAdM = _ESZQd(self._data, 'account', 'id')
            if not _atAdM:
                _2vqQ6 = 'Key lacks account ID'
                raise _Tron3(_2vqQ6, 'KG_MISSING_ACCOUNT_ID')
            self.vendor: Vendor = _eiotx(_atAdM)
            _bW33Q = self.vendor.verify_key
            if isinstance(_bW33Q, _oUY9L):
                _bW33Q.verify(_QtQYu, _grHWM.encode(), padding='pss')
            else:
                _bW33Q.verify(_QtQYu, _grHWM.encode())

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self._key

        @property
        def account_id(self):
            return _ESZQd(self.data, 'account', 'id')

        @property
        def product_id(self):
            return self.data['product']['id']

        @property
        def product_name(self):
            return None

        @property
        def license_id(self):
            return self.data['license']['id']

        @property
        def created(self):
            return _txTPF(self.data['license']['created'])

        @property
        def expiry(self):
            if (expiry := _ESZQd(self.data, 'license', 'expiry')):
                return _txTPF(expiry)
            return None

        @property
        def max_machines(self):
            return None

        @property
        def num_machines(self):
            return None

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def user(self):
            if (user := _ESZQd(self.data, 'user')):
                return {'id': _ESZQd(user, 'id'), 'email': _ESZQd(user, 'email')}
            return {}

        def list_machines(self):
            return []

        def validate(self, raise_on_error=True):
            _dOi7u = datetime.now(tz=timezone.utc)
            created = _ESZQd(self.data, 'license', 'created')
            if created and _dOi7u < _txTPF(created) - timedelta(minutes=5):
                if raise_on_error:
                    _FzdxI = 'Invalid license'
                    raise _Tron3(_FzdxI, 'KG_E043')
                return {'valid': False, 'code': 'KG_E043', 'detail': 'Unknown error E043'}
            expiry = _ESZQd(self.data, 'license', 'expiry')
            if expiry and _dOi7u > _txTPF(expiry) + timedelta(minutes=5):
                if raise_on_error:
                    _FzdxI = f'License has expired on {expiry}'
                    raise _Tron3(_FzdxI, 'KG_EXPIRED')
                return {'valid': False, 'code': 'KG_EXPIRED', 'detail': 'License has expired'}
            return {'valid': True, 'code': 'VALID', 'detail': 'is valid'}

        def prettyprint(self, show_key=False):
            _lVex2 = self.validate(raise_on_error=False)
            super()._prettyprint(show_key=show_key, is_valid=_lVex2['valid'], validation_code=_lVex2['code'])
    logging.getLogger('requests_cache.session').setLevel(logging.ERROR)
    _cI9J3 = '1.7'
    _B3evb = requests_cache.CachedSession(cache_name=_VMujV / 'keygen', expire_after=timedelta(days=3), stale_while_revalidate=timedelta(days=4), allowable_methods=['GET', 'HEAD', 'POST'])

    class _eo43R(_XvAFl):
        key_type = 'Keygen online'

        @classmethod
        def from_key(cls, account_id, key):
            assert account_id
            assert isinstance(key, str)
            assert not key.startswith('key/')
            return cls({'attributes': {'key': key}, 'relationships': {'account': {'data': {'id': account_id}}}})

        def __init__(self, data):
            assert isinstance(data, dict)
            assert 'data' not in data
            self._data = data
            _rMbxQ = data['relationships']['account']['data']['id']
            self.base_url = f'https://api.keygen.sh/v1/accounts/{_rMbxQ}'
            self.vendor = _eiotx(_rMbxQ)
            self.verify_response = self.vendor.verify_key.verify_response
            super().__init__()

        @property
        def data(self):
            return self._data

        @property
        def key(self):
            return self.data['attributes']['key']

        @property
        def auth(self):
            return f'License {self.key}'

        @property
        def license_id(self):
            return _ESZQd(self.data, 'id')

        @property
        def license_key(self):
            return self.data['attributes']['key']

        @property
        def account_id(self):
            return _ESZQd(self.data, 'relationships', 'account', 'data', 'id')

        @property
        def product_id(self):
            return _ESZQd(self.data, 'relationships', 'product', 'data', 'id')

        @property
        def product_name(self):
            return _ESZQd(self.data, 'attributes', 'metadata', 'productName')

        @property
        def usage_type(self):
            return _ESZQd(self.data, 'attributes', 'metadata', 'usageType')

        @property
        def activations(self):
            _4Evfx = _ESZQd(self.data, 'attributes', 'metadata', 'tokenId')
            if not _4Evfx:
                return (None, None)
            _CqxnD = _B3evb.get(f'{self.base_url}/tokens/{_4Evfx}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _cI9J3}, timeout=10)
            _CqxnD.raise_for_status()
            data = _CqxnD.json()
            _Sk424 = data['data']['attributes']
            return (_Sk424['activations'], _Sk424['maxActivations'])

        @property
        def vendor_name(self):
            return self.vendor.name

        @property
        def created(self):
            if (created := _ESZQd(self.data, 'attributes', 'created')):
                return _txTPF(created)
            return None

        @property
        def expiry(self):
            if (expiry := _ESZQd(self.data, 'attributes', 'expiry')):
                return _txTPF(expiry)
            return None

        @property
        def num_machines(self):
            return _ESZQd(self.data, 'relationships', 'machines', 'meta', 'count')

        @property
        def max_machines(self):
            return _ESZQd(self.data, 'attributes', 'maxMachines')

        def list_machines(self):
            try:
                _ItxSd = self.get_machines()
            except requests.exceptions.ReadTimeout:
                return []
            _lgSPE = []
            for _PVrPU in _ItxSd:
                _4YKu8 = _ESZQd(_PVrPU, 'attributes', 'fingerprint')
                _B4IKa = {'hostname': _ESZQd(_PVrPU, 'attributes', 'hostname'), 'requireHeartbeat': _ESZQd(_PVrPU, 'attributes', 'requireHeartbeat'), 'heartbeatStatus': _ESZQd(_PVrPU, 'attributes', 'heartbeatStatus'), 'fingerprint': _4YKu8}
                if (lhb := _ESZQd(_PVrPU, 'attributes', 'lastHeartbeat')):
                    _B4IKa['lastHeartbeat'] = _txTPF(lhb)
                if (created := _ESZQd(_PVrPU, 'attributes', 'created')):
                    _B4IKa['created'] = _txTPF(created)
                _lgSPE.append(_B4IKa)
            return _lgSPE

        @property
        def user(self):
            metadata = self.data['attributes']['metadata']
            _2Ungq = _ESZQd(metadata, 'email') or _ESZQd(metadata, 'user')
            if _2Ungq and _2Ungq not in {'sigma@mondaytech.com', 'meshpro@mondaytech.com', 'texworld@mondaytech.com'}:
                return {'email': _2Ungq}
            return {}

        def validate(self, activate_if_required=False, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None, require_product_id=None):
            if _ESZQd(self.data, 'attributes', 'metadata', 'requireFingerprintScope') is True:
                return self._validate_fingerprinted(activate_if_required, require_product_id=require_product_id, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            _oqJyK = self._validate_cached(with_fingerprint=False, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _G75PK = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _Tron3(_G75PK, 'KG_WRONG_PRODUCT_ID')
            if _ESZQd(_oqJyK, 'valid'):
                return _oqJyK
            _XgJ6G = _ESZQd(_oqJyK, 'code')
            if _XgJ6G == 'FINGERPRINT_SCOPE_REQUIRED':
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if raise_on_error:
                _G75PK = f'License {self.license_id}: Key validation failed'
                raise _Tron3(_G75PK, _XgJ6G)
            return _oqJyK

        def _validate_fingerprinted(self, activate_if_required, require_product_id=None, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _0zOzy = self._validate_cached(with_fingerprint=True, raise_on_error=False, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            if require_product_id is not None and self.product_id != require_product_id:
                _eGcBA = f'Require product ID {require_product_id}, but license has product ID {self.product_id}'
                raise _Tron3(_eGcBA, 'KG_WRONG_PRODUCT_ID')
            if _ESZQd(_0zOzy, 'valid'):
                return _0zOzy
            _3cHo5 = _ESZQd(_0zOzy, 'code')
            if _3cHo5 == 'HEARTBEAT_NOT_STARTED':
                self._ping_heartbeat_cached(raise_on_error=True, cache_force_refresh=True)
                return self._validate_fingerprinted(activate_if_required, raise_on_error=raise_on_error)
            if activate_if_required and _3cHo5 in {'NO_MACHINE', 'NO_MACHINES', 'FINGERPRINT_SCOPE_MISMATCH', 'HEARTBEAT_DEAD'}:
                self.activate(raise_on_error=True)
                return self._validate_fingerprinted(activate_if_required, cache_force_refresh=True, cache_expire_after=cache_expire_after, raise_on_error=raise_on_error)
            if raise_on_error:
                _LGTjV = []
                _uPdOV = _ESZQd(_0zOzy, 'detail')
                _3G3l3 = _ESZQd(_0zOzy, 'code')
                if _3cHo5 and _uPdOV:
                    _LGTjV.append(f'Validation error {_3cHo5}: {_uPdOV}')
                if _3cHo5 == 'NOT_FOUND':
                    _LGTjV.append('Did you provide the license ID instead of the key?')
                raise _Tron3('\n'.join(_LGTjV), f'KG_{_3G3l3}')
            return _0zOzy

        def _validate_cached(self, with_fingerprint, raise_on_error=True, cache_force_refresh=False, cache_expire_after=None):
            _nbBWL: dict[str, Any] = {'key': self.key}
            if with_fingerprint:
                _nbBWL['scope'] = {'fingerprint': _rdZ7v()}
            _QYr5g = _B3evb.post(f'{self.base_url}/licenses/actions/validate-key', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _cI9J3}, json={'meta': _nbBWL}, timeout=10, force_refresh=cache_force_refresh, expire_after=cache_expire_after)
            try:
                self.verify_response(_QYr5g)
            except _xphIh:
                _B3evb.cache.delete(requests=[_QYr5g.request])
                raise
            _DXrdA(_QYr5g)
            json = _QYr5g.json()
            if not _QYr5g.ok:
                _PCOAu = _ESZQd(json, 'errors', 0)
                _2fDbE = f'Validation failed for license {self.license_id}: '
                if _PCOAu:
                    if _PCOAu.get('title') == 'Daily API request limit reached':
                        _9hVpH = 'KG_RATE_LIMIT'
                        _2fDbE += 'Daily API rate limit has been reached. Limit will be reset at midnight UTC.'
                    else:
                        _9hVpH = _ESZQd(_PCOAu, 'code')
                        _2fDbE += _ESZQd(_PCOAu, 'detail')
                else:
                    _9hVpH = 'KG_VALIDATION_FAILED'
                    _2fDbE += 'unknown'
                raise _Tron3(_2fDbE, _9hVpH)
            data = json['data']
            _nbBWL = json['meta']
            if not _ESZQd(_nbBWL, 'valid') and raise_on_error:
                _MqR6v = _ESZQd(_nbBWL, 'code')
                _2Lyqd = _ESZQd(_nbBWL, 'detail')
                _ONpNf = []
                if _MqR6v and _2Lyqd:
                    _ONpNf.append(f'Validation error {_MqR6v}: {_2Lyqd}')
                if _MqR6v == 'NOT_FOUND':
                    _ONpNf.append('Did you provide the license ID instead of the key?')
                raise _Tron3('\n'.join(_ONpNf), _MqR6v)
            if _ESZQd(_nbBWL, 'valid') and _ESZQd(data, 'attributes', 'requireHeartbeat'):
                self._ping_heartbeat_cached(raise_on_error=True)
            if data:
                self._data = data
            return _nbBWL

        def activate(self, raise_on_error=True):
            _lhrkA('Activating machine for license...', highlight=False, end='', style='green')
            _lsl5R = _ESZQd(self.data, 'attributes', 'metadata', 'token')
            _AOxuX = _ESZQd(self.data, 'attributes', 'metadata', 'tokenId')
            _xYfO0 = _lsl5R and _AOxuX
            auth = f'Bearer {_lsl5R}' if _xYfO0 else f'License {self.key}'
            _IpSHG = _PFhQH()
            _u1HpM = requests.post(f'{self.base_url}/machines', headers={'Authorization': auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _cI9J3}, json={'data': {'type': 'machines', 'attributes': {'ip': _IpSHG.get('ip'), 'cores': multiprocessing.cpu_count(), 'fingerprint': _rdZ7v(), 'platform': platform.platform(), 'hostname': socket.gethostname(), 'metadata': {'country': _IpSHG.get('country'), 'python-version': _eqrJe(), 'slim-version': _igKWe('stonefish-license-manager')}}, 'relationships': {'license': {'data': {'type': 'licenses', 'id': self.license_id}}}}}, timeout=10)
            self.verify_response(_u1HpM)
            _DXrdA(_u1HpM)
            _wcjkL = _u1HpM.json()
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _xYfO0:
                self._clear_tokens_cache(_AOxuX)
            if raise_on_error and 'errors' in _wcjkL:
                _lhrkA(_wcjkL)
                _fre7q = f'Activation errors with license {self.license_id}:\n' + '\n'.join((f"    {_xQlst['title']}: {_xQlst['detail']}" for _xQlst in _wcjkL['errors']))
                raise _Tron3(_fre7q, 'KG_ACTIVATION_ERROR')
            _lhrkA('done.', style='green')

        def deactivate(self, fingerprints=None):
            _lhrkA('Deactivating machine for license...', highlight=False, end='', style='green')
            _fYnMU = _ESZQd(self.data, 'attributes', 'metadata', 'token')
            _gMUz1 = _ESZQd(self.data, 'attributes', 'metadata', 'tokenId')
            _tNAMQ = _fYnMU and _gMUz1
            auth = f'Bearer {_fYnMU}' if _tNAMQ else f'License {self.key}'
            if not fingerprints:
                fingerprints = {_rdZ7v()}
            for _Lt4qr in fingerprints:
                _IEywQ = self._get_machine_by_fingerprint_cached(_Lt4qr, cache_force_refresh=True)
                _i0ViB = _ESZQd(_IEywQ, 'data', 0, 'id')
                if not _i0ViB:
                    _2tPtM = f"Couldn't get machine ID for machine {_Lt4qr}. Not activated?"
                    raise _Tron3(_2tPtM, 'KG_MACHINE_NOT_FOUND')
                _2qjtx = requests.delete(f'{self.base_url}/machines/{_i0ViB}', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': _cI9J3}, timeout=10)
                if not _2qjtx.ok:
                    _BvF56 = _ESZQd(_2qjtx.json(), 'errors', 0)
                    if _BvF56:
                        _7Vl8f = _ESZQd(_BvF56, 'code')
                        _2tPtM = f"Machined deactivation failed: {_BvF56['detail']}"
                    elif _2qjtx.status_code == 404:
                        _7Vl8f = 'KG_MACHINE_NOT_FOUND'
                        _2tPtM = 'Machine deactivation failed (not found)'
                    else:
                        _7Vl8f = 'KG_DEACTIVATION_FAILED'
                        _2tPtM = 'Unsuccessful deactivation request'
                    raise _Tron3(_2tPtM, _7Vl8f)
                self.verify_response(_2qjtx)
                _DXrdA(_2qjtx)
            self._clear_validation_cache()
            self._clear_machines_cache()
            if _tNAMQ:
                self._clear_tokens_cache(_gMUz1)
            _lhrkA('done.', style='green')

        def _clear_validation_cache(self):
            _B3evb.cache.delete(requests=[Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key}}), Request(method='POST', url=f'{self.base_url}/licenses/actions/validate-key', json={'meta': {'key': self.key, 'scope': {'fingerprint': _rdZ7v()}}})])

        def _clear_machines_cache(self):
            _B3evb.cache.delete(urls=[f'{self.base_url}/licenses/{self.license_id}/machines'])

        def _clear_tokens_cache(self, token_id):
            _B3evb.cache.delete(urls=[f'{self.base_url}/tokens/{token_id}'])

        def get_machines(self, cache_force_refresh=False):
            _p2h5y = _B3evb.get(f'{self.base_url}/licenses/{self.license_id}/machines', headers={'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Authorization': self.auth, 'Keygen-Version': _cI9J3}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_p2h5y)
            except _xphIh:
                _B3evb.cache.delete(requests=[_p2h5y.request])
                raise
            _DXrdA(_p2h5y)
            json = _p2h5y.json()
            return _ESZQd(json, 'data', default=[])

        def prettyprint(self, show_key=False):
            _fE3HJ: bool | Literal['unknown']
            try:
                _G9Y5f = self.validate(raise_on_error=False)
            except requests.exceptions.ReadTimeout:
                _fE3HJ = 'unknown'
                _BICO1 = 'timeout'
            else:
                _fE3HJ = _G9Y5f['valid']
                assert isinstance(_fE3HJ, bool)
                _BICO1 = _ESZQd(_G9Y5f, 'code')
            super()._prettyprint(show_key=show_key, is_valid=_fE3HJ, validation_code=_BICO1)

        def _get_machine_by_fingerprint_cached(self, fingerprint, cache_force_refresh=False, raise_on_error=False):
            _UXwOX = _B3evb.get(url=f'{self.base_url}/machines', params={'fingerprint': quote(fingerprint)}, headers={'Authorization': self.auth, 'Content-Type': 'application/vnd.api+json', 'Accept': 'application/vnd.api+json', 'Keygen-Version': _cI9J3}, timeout=10, force_refresh=cache_force_refresh)
            self.verify_response(_UXwOX)
            _DXrdA(_UXwOX)
            _LNdMM = _UXwOX.json()
            _Rw5iF = _ESZQd(_LNdMM, 'errors')
            if raise_on_error and _Rw5iF:
                _tWFsR = 'Get-Machine errors:\n' + '\n'.join((f"    {_ow8mf['title']}: {_ow8mf['detail']}" for _ow8mf in _Rw5iF))
                raise _Tron3(_tWFsR, 'KG_MACHINE_ERROR')
            return _LNdMM

        def _ping_heartbeat_cached(self, raise_on_error, cache_force_refresh=False):
            _8dZ7S = _rdZ7v()
            _PYHNY = self._get_machine_by_fingerprint_cached(_8dZ7S, cache_force_refresh=cache_force_refresh)
            _VW2dV = _ESZQd(_PYHNY, 'data', 0, 'id')
            if _VW2dV is None:
                _elDzK = f'Machine with fingerprint {_8dZ7S} not found'
                raise _Tron3(_elDzK, 'KG_MACHINE_NOT_FOUND')
            _Zniwj = _B3evb.post(f'{self.base_url}/machines/{_VW2dV}/actions/ping-heartbeat', headers={'Authorization': self.auth, 'Accept': 'application/vnd.api+json', 'Keygen-Version': _cI9J3}, timeout=10, force_refresh=cache_force_refresh)
            try:
                self.verify_response(_Zniwj)
            except _xphIh:
                _B3evb.cache.delete(requests=[_Zniwj.request])
                raise
            _DXrdA(_Zniwj)
            _hZb4Q = _Zniwj.json()
            _DuhQ4 = _ESZQd(_hZb4Q, 'errors')
            if _DuhQ4 and _ESZQd(_DuhQ4[0], 'code') == 'NOT_FOUND' and (not cache_force_refresh):
                return self._ping_heartbeat_cached(raise_on_error, cache_force_refresh=True)
            if raise_on_error and _DuhQ4:
                _elDzK = f'License {self.license_id}: Heartbeat errors:\n' + '\n'.join((f"    {_UMvsn['title']}: {_UMvsn['detail']}" for _UMvsn in _DuhQ4))
                raise _Tron3(_elDzK, 'KG_HEARTBEAT_ERROR')
            return _hZb4Q

    def _sCNsZ():
        _B3evb.cache.clear()

    def _Rnzmf(cert_data_or_path, update_if_expired=True, override_original=True):
        _Uoqbn = None
        if isinstance(cert_data_or_path, Path):
            _Uoqbn = cert_data_or_path
            with _Uoqbn.open() as _0YhPJ:
                _0QrPU = _0YhPJ.read()
        else:
            assert isinstance(cert_data_or_path, str)
            _0QrPU = cert_data_or_path
        _W8Jd3, _8RkgL = _q7ozR(_0QrPU)
        _Sbgvp = datetime.now(tz=timezone.utc)
        if _txTPF(_8RkgL['issued']) > _Sbgvp + timedelta(minutes=5):
            _J3TQI = 'License error'
            raise _Tron3(_J3TQI, 'KG_E058')
        if _Uoqbn and update_if_expired and (_Sbgvp > _txTPF(_8RkgL['expiry'])):
            _0QrPU = _7iOTr(_W8Jd3['relationships']['account']['data']['id'], _W8Jd3['id'], auth=f"License {_W8Jd3['attributes']['key']}")
            _W8Jd3, _8RkgL = _q7ozR(_0QrPU)
            if override_original:
                with _Uoqbn.open('w') as _v6217:
                    _v6217.write(_0QrPU)
        _X7DyQ = _W8Jd3['attributes']['key']
        if _X7DyQ.startswith('key/'):
            return _7dYGZ(_X7DyQ)
        return _eo43R(_W8Jd3)

    def _lYT3k(path):
        with path.open() as _gOgOs:
            _wmlHz = _gOgOs.read()
        _zvQs2, _F7n9J = _q7ozR(_wmlHz)
        _hLDaq = _zvQs2['attributes']['key']
        _wmlHz = _7iOTr(_zvQs2['relationships']['account']['data']['id'], _zvQs2['id'], auth=f'License {_hLDaq}')
        with path.open('w') as _gpaMS:
            _gpaMS.write(_wmlHz)

    def _q7ozR(content):
        assert isinstance(content, str)
        _STp9V = '-----BEGIN LICENSE FILE-----\n'
        _SqHZR = '-----END LICENSE FILE-----'
        content = content.strip()
        if not content.startswith(_STp9V) or not content.endswith(_SqHZR):
            _LJhfC = f'Error in license file. Expected\n```{_STp9V}...\n{_SqHZR}\n```\ngot\n```\n{content}\n```\nTry refreshing the the license file with `slim refresh`.\n'
            raise ValueError(_LJhfC)
        _OJFw3 = base64.b64decode(_qVJVV(content, _STp9V, _SqHZR))
        try:
            _ATqoJ = json.loads(_OJFw3)
        except UnicodeDecodeError:
            _LJhfC = 'Unexpected license data'
            raise RuntimeError(_LJhfC) from None
        _nYUQS = json.loads(base64.b64decode(_ATqoJ['enc']))
        _72zO6 = _ESZQd(_nYUQS, 'data', 'relationships', 'account', 'data', 'id')
        _9Q3fU = _eiotx(_72zO6).verify_key
        _t7dC4 = ('license/' + _ATqoJ['enc']).encode()
        _HQJBC, _PqGPN = _ATqoJ['alg'].split('+')
        assert _HQJBC == 'base64'
        _HAl1x = base64.b64decode(_ATqoJ['sig'])
        if _9Q3fU.alg != _PqGPN:
            _LJhfC = f'Requested {_PqGPN} key, but got {_9Q3fU.alg} verify_key'
            raise RuntimeError(_LJhfC)
        _9Q3fU.verify(_HAl1x, _t7dC4)
        return (_nYUQS['data'], _nYUQS['meta'])

    def _7iOTr(account_id, license_id_or_key, auth, host='api.keygen.sh'):
        _FbRyj = requests.get(f'https://{host}/v1/accounts/{account_id}/licenses/{quote(license_id_or_key)}/actions/check-out', headers={'Accept': 'application/vnd.api+json', 'Authorization': auth, 'Keygen-Version': '1.7'}, timeout=10)
        _FbRyj.raise_for_status()
        _eiotx(account_id).verify_key.verify_response(_FbRyj)
        _DXrdA(_FbRyj)
        return _FbRyj.text
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_hqHOZ
    @cache
    def _0rlOG(vendor_id, product_id, variable_names=()):
        _LHjYV(vendor_id)
        for _SfGoD in _7Xblr(_AGdUS(variable_names), _RXVM7(product_id)):
            try:
                _Nj7o7 = _SfGoD.validate()
            except _Tron3:
                continue
            except _xphIh:
                _i5A1B('Invalid signature in SLiC license')
                continue
            if vendor_id != _ESZQd(_SfGoD.data, 'vendor', 'id') or product_id != _ESZQd(_SfGoD.data, 'product', 'id'):
                continue
            return (_SfGoD.data, _Nj7o7)
        _pJBOR = f'Unable to find valid license for product ID {product_id}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _Tron3(_pJBOR, 'SLIC_NOT_FOUND')

    def _AGdUS(var_names):
        for _SYHLU, _DDKXD, _uWLvO in _c0AU2(var_names):
            try:
                yield _ZTZMc(_uWLvO)
            except _xphIh:
                _i5A1B(f'Invalid signature in SLiC license in {_uWLvO}')

    def _RXVM7(product_id):
        for _ftZUM, _am3I8 in _5EJ2N(product_id=product_id):
            try:
                yield _am3I8
            except _xphIh:
                _i5A1B(f'Invalid signature in SLiC license in {_ftZUM}')
    try:
        import tomllib
    except ImportError:
        import tomli as tomllib
    _uBEx0 = _cnOKv / 'keygen'

    def _rMzYK(file_or_cert):
        _6fXQc = _Rnzmf(file_or_cert, update_if_expired=True, override_original=False)
        if isinstance(_6fXQc, _eo43R):
            _6fXQc.validate(activate_if_required=True)
            return _RmQwA(_6fXQc, file_or_cert)
        assert isinstance(_6fXQc, _7dYGZ)
        _TGn0H(_6fXQc)
        return _6fXQc

    def _RmQwA(lic, cert=None):
        _lhrkA('Installing license...', end='', style='green', highlight=False)
        if cert is None:
            cert = _7iOTr(lic.account_id, lic.license_key, auth=f'License {lic.license_key}')
        elif isinstance(cert, Path):
            with cert.open() as _2Dt0u:
                cert = _2Dt0u.read()
        assert isinstance(cert, str)
        assert cert.startswith('-----BEGIN LICENSE FILE-----')
        assert lic.product_id, 'Missing product ID'
        assert lic.license_id, 'Missing license ID'
        _uowUj = _uBEx0 / lic.product_id / (lic.license_id + '.lic')
        _uowUj.parent.mkdir(parents=True, exist_ok=True)
        with _uowUj.open('w') as _WfzLd:
            _WfzLd.write(cert)
        _lhrkA('done.', style='green')
        return lic

    def _TGn0H(lic):
        _ruLU0 = _uBEx0 / lic.product_id / (lic.license_id + '.key')
        _ruLU0.parent.mkdir(parents=True, exist_ok=True)
        _2SECj, _lSwJR = lic.key.split('/')
        _C1y94, _BaGb8 = _lSwJR.split('.')
        with _ruLU0.open('w') as _OnfNt:
            _OnfNt.write(_2SECj + '/\n' + _jVEGT(_C1y94, 60) + '\n.\n' + _jVEGT(_BaGb8, 60))

    def _HqpHn(toml_file):
        _6dA4i = _bIn0J(toml_file)
        if _6dA4i.startswith('key/'):
            _fTGK5 = _7dYGZ(_6dA4i)
            _TGn0H(_fTGK5)
            return _fTGK5
        _6dA4i = _rpuQp(_6dA4i, 'fp/')
        _IrMsX = _eo43R.from_key(_pJm8K(_6dA4i), _6dA4i)
        _IrMsX.validate(activate_if_required=True)
        _RmQwA(_IrMsX)
        return _IrMsX

    def _bIn0J(toml_file):
        with Path(toml_file).open('rb') as _m5ES4:
            _A43ah = tomllib.load(_m5ES4)
        assert _A43ah, f'Empty license file {toml_file}'
        return _A43ah['license_key']

    @_TAgnC
    def _0il6L(product_id=None, license_keys_or_ids=None):
        _vA8NH = _uBEx0
        if product_id:
            _vA8NH /= product_id
        for _xPPHN in _vA8NH.rglob('*.key'):
            _lcJdr = _7dYGZ.from_file(_xPPHN)
            if license_keys_or_ids is None:
                yield (_xPPHN, _lcJdr)
            else:
                _nCGv9 = _ESZQd(_lcJdr.data, 'license', 'id')
                if _nCGv9 in license_keys_or_ids:
                    license_keys_or_ids.remove(_nCGv9)
                    yield (_xPPHN, _lcJdr)
                    continue
                if _lcJdr.key in license_keys_or_ids:
                    license_keys_or_ids.remove(_lcJdr.key)
                    yield (_xPPHN, _lcJdr)
                    continue

    @_TAgnC
    def _kLf5j(product_id=None, license_keys_or_ids=None):
        _Cwg5m = _uBEx0
        if product_id:
            _Cwg5m /= product_id
        for _3NsUs in _Cwg5m.rglob('*.toml'):
            _HqpHn(_3NsUs)
            _3NsUs.unlink()
        for _KH8DV in _Cwg5m.rglob('*.lic'):
            _TFrVo = _Rnzmf(_KH8DV)
            if license_keys_or_ids is None:
                yield (_KH8DV, _TFrVo)
            else:
                _yFVDu = _ESZQd(_TFrVo.data, 'id')
                if _yFVDu in license_keys_or_ids:
                    license_keys_or_ids.remove(_yFVDu)
                    yield (_KH8DV, _TFrVo)
                    continue
                _EhvmV = _ESZQd(_TFrVo.data, 'attributes', 'key')
                if _EhvmV in license_keys_or_ids:
                    license_keys_or_ids.remove(_EhvmV)
                    yield (_KH8DV, _TFrVo)
                    continue

    def _z0cxQ():
        _dqtmI = 0
        for _HlzYs in _uBEx0.rglob('*.lic'):
            _lYT3k(_HlzYs)
            _dqtmI += 1
        return _dqtmI
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_hqHOZ
    @cache
    def _oxsJ5(account_id, product_id, variable_names=(), allow_user_input=True, cache_force_refresh=False, cache_expire_after=None):
        assert isinstance(product_id, str)
        _eiotx(account_id)
        for _EJuFA in _7Xblr(_KDwKe(account_id, list(variable_names)), _edTxp(product_id), _wQEsi(product_id)):
            if isinstance(_EJuFA, _eo43R):
                try:
                    _WPEHn = _EJuFA.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                except _Tron3 as e:
                    _i5A1B(str(e))
                    continue
            elif isinstance(_EJuFA, _7dYGZ):
                try:
                    _WPEHn = _EJuFA.validate()
                except _Tron3 as e:
                    _i5A1B(str(e))
                    continue
            else:
                continue
            if _EJuFA.account_id != account_id or _EJuFA.product_id != product_id:
                continue
            return (_EJuFA.data, _WPEHn)
        _8BDWs = f'Unable to find valid license for product ID {product_id}.'
        if allow_user_input:
            _i5A1B(_8BDWs)
            _ABoqa = Prompt.ask('Enter license key')
            _EJuFA = _VUwKi(_ABoqa, account_id)
            if _EJuFA is None:
                _ktVWD = f'Illegal license key `{_ABoqa}`. Typo?'
                raise _Tron3(_ktVWD, 'ILLEGAL_KEY')
            if isinstance(_EJuFA, _eo43R):
                _WPEHn = _EJuFA.validate(activate_if_required=True, require_product_id=product_id, cache_expire_after=cache_expire_after, cache_force_refresh=cache_force_refresh)
                _RmQwA(_EJuFA)
                return (_EJuFA.data, _WPEHn)
            if isinstance(_EJuFA, _7dYGZ):
                _WPEHn = _EJuFA.validate()
                if _EJuFA.product_id != product_id:
                    _ktVWD = f'Require product ID {product_id}, but license has product ID {_EJuFA.product_id}'
                    raise _Tron3(_ktVWD, 'KG_WRONG_PRODUCT_ID')
                _TGn0H(_EJuFA)
                return (_EJuFA.data, _WPEHn)
        raise _Tron3(_8BDWs, 'KG_NOT_FOUND')

    def _KDwKe(account_id, var_names):
        for _F1XEg, _DZEYM, _47yPI in _c0AU2(var_names):
            if _47yPI.strip() == '':
                _i5A1B(f'{_F1XEg.title()} variable `{_DZEYM}` is empty.')
                continue
            _tVS8l = _VUwKi(_47yPI, account_id)
            if _tVS8l is None:
                _i5A1B(f'{_F1XEg.title()} variable `{_DZEYM}` contains value that cannot be converted to a KG license:\n{_47yPI}')
                continue
            yield _tVS8l

    def _VUwKi(value, account_id):
        if value.endswith('-V3'):
            _WiOKt = _rpuQp(value, 'fp/')
            return _eo43R.from_key(account_id, _WiOKt)
        if value.startswith('key/'):
            return _7dYGZ(value)
        if value.startswith('-----BEGIN LICENSE FILE-----'):
            return _Rnzmf(value, update_if_expired=True, override_original=False)
        _UJ550 = Path(value)
        if _UJ550.is_file():
            with _UJ550.open() as _BmHkC:
                _aLgGs = _BmHkC.read()
            return _VUwKi(_aLgGs, account_id)
        return None

    def _edTxp(product_id):
        for _Pu63z, _FqYrJ in _0il6L(product_id=product_id):
            yield _FqYrJ

    def _wQEsi(product_id):
        for _g8Bx3, _WgmaU in _kLf5j(product_id=product_id):
            try:
                yield _WgmaU
            except _xphIh:
                _i5A1B(f'Invalid signature in {_g8Bx3}. Skipping.')
    try:
        from functools import cache
    except ImportError:
        from functools import lru_cache as cache

    @_hqHOZ
    @cache
    def _MLqjf(product_code, shared_key, api_key, variable_names=(), cache_force_refresh=False, cache_expire_after=None):
        for _Thcy2 in _7Xblr(_OpfJa(product_code, variable_names), _yYhAB(product_code)):
            try:
                _Thcy2.validate(shared_key, api_key, cache_force_refresh=cache_force_refresh, cache_expire_after=cache_expire_after)
            except _Tron3:
                continue
            if product_code != _Thcy2.product_code:
                continue
            return _Thcy2
        _szXXE = f'Unable to find valid license for product {product_code}. \n\nAdd a license with\n\n    slim install <your-license>\n'
        raise _Tron3(_szXXE, 'LS_NOT_FOUND')

    def _OpfJa(product_code, var_names):
        for _TZ9CI, _X3fBa, _bOjuN in _c0AU2(var_names):
            yield _jhzbC.from_key(product_code, _bOjuN)

    def _yYhAB(product_code):
        for _zFyJ7 in (_dLKCv / product_code).glob('*.lic'):
            yield _jhzbC.from_file(_zFyJ7)
    if TYPE_CHECKING:
        pass

    def _s4zAO(ld):
        if isinstance(ld, str):
            ld = ld.strip()
            if ld.startswith('-----BEGIN LICENSE FILE-----'):
                return _rMzYK(ld)
            if ld.endswith('-V3'):
                _v5kN1 = _rpuQp(ld, 'fp/')
                _TctPn = _eo43R.from_key(_pJm8K(_v5kN1), _v5kN1)
                _TctPn.validate(activate_if_required=True)
                return _RmQwA(_TctPn)
            if ld.startswith('key/'):
                _TctPn = _7dYGZ(ld)
                _TGn0H(_TctPn)
                return _TctPn
            if ld.startswith('slicv1/'):
                return _lKqLb(ld)
        if Path(ld).exists():
            return _65bXh(Path(ld))
        _i662F = f"Don't know how to handle license_data {ld}"
        raise _5CyRv(_i662F)

    def _65bXh(license_file):
        if not license_file.exists():
            _E32dc = f'File {license_file} not found'
            raise _5CyRv(_E32dc)
        if license_file.suffix == '.toml':
            return _HqpHn(license_file)
        if license_file.suffix == '.lic':
            with license_file.open() as _w99XJ:
                _98Bj4 = _w99XJ.read()
            if _98Bj4.startswith('-----BEGIN LICENSE FILE-----'):
                return _rMzYK(license_file)
            return _rl4q5(license_file)
        if license_file.suffix == '.key':
            _ChAYM = _7dYGZ.from_file(license_file)
            _TGn0H(_ChAYM)
            return _ChAYM
        if license_file.suffix == '.skm':
            return _ohmTQ(license_file)
        _E32dc = f'Unknown license file format {license_file}'
        raise _5CyRv(_E32dc)

    def _qSV2y(license_keys_or_ids=None, product_id=None):
        assert isinstance(license_keys_or_ids, set) or license_keys_or_ids is None
        return _7Xblr(_qwXwD(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _kLf5j(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _0il6L(license_keys_or_ids=license_keys_or_ids, product_id=product_id), _XrWnY(license_keys_or_ids=license_keys_or_ids, product_code=product_id), _5EJ2N(license_keys_or_ids=license_keys_or_ids, product_id=product_id))

    def _v2hRf():
        _z0cxQ()
    _S3dnx = 0
    _5elWI = 1
    RichHelpFormatter.styles['argparse.args'] = 'cyan'
    RichHelpFormatter.styles['argparse.groups'] = 'yellow'
    RichHelpFormatter.styles['argparse.metavar'] = 'green'

    def _qX1N8(license_data):
        if license_data.startswith('key/'):
            return _7dYGZ(license_data)
        if license_data.endswith('-V3'):
            _zKFUv = _rpuQp(license_data, 'fp/')
            return _eo43R.from_key(_pJm8K(_zKFUv), _zKFUv)
        if license_data.startswith('-----BEGIN LICENSE FILE-----'):
            return _Rnzmf(license_data, update_if_expired=True, override_original=False)
        if license_data.startswith('slicv1/'):
            return _ZTZMc(license_data)
        if Path(license_data).exists():
            _vTKTK = Path(license_data)
            if _vTKTK.suffix == '.toml':
                return _qX1N8(_bIn0J(_vTKTK))
            if _vTKTK.suffix == '.lic':
                return _Rnzmf(_vTKTK, update_if_expired=True, override_original=False)
            if _vTKTK.suffix == '.skm':
                return _R717p.from_file(_vTKTK, token=None)
            _hSQmK = f'Unknown license format in file {_vTKTK}'
            raise RuntimeError(_hSQmK)
        _hSQmK = 'Unknown key type'
        raise RuntimeError(_hSQmK)

    def _WALWm(_):
        _lhrkA(_rdZ7v())
        return _S3dnx

    def _RcSZo(license_keys_or_ids, raw=False, show_keys=False):
        assert isinstance(license_keys_or_ids, set)
        try:
            _DHiSa = list(_qSV2y(license_keys_or_ids=license_keys_or_ids or None))
        except _5CyRv as e:
            _VWpFZ(str(e))
            return _5elWI
        if license_keys_or_ids:
            for _tAKEp in license_keys_or_ids:
                try:
                    _DHiSa.append((None, _qX1N8(_tAKEp)))
                except RuntimeError:
                    _VWpFZ(f'{_tAKEp}: No such license.')
                    return _5elWI
        try:
            for _BIYVK, _s1wxB in _DHiSa:
                if raw:
                    _lhrkA(_s1wxB.data)
                else:
                    _s1wxB.prettyprint(show_key=show_keys)
        except Exception as e:
            _VWpFZ(str(e))
            return _5elWI
        return _S3dnx

    def _gm76B(license_keys_or_ids, automatic_yes=False):
        license_keys_or_ids = set(license_keys_or_ids)
        if license_keys_or_ids:
            license_keys_or_ids = {k.strip().replace('\n', '') for k in license_keys_or_ids}
        try:
            _73ONZ = list(_qSV2y(license_keys_or_ids=license_keys_or_ids))
        except _5CyRv as e:
            _VWpFZ(str(e))
            return _5elWI
        if license_keys_or_ids:
            _pfHjB = ', '.join(license_keys_or_ids)
            _azGjD = '' if len(license_keys_or_ids) == 1 else 's'
            _VWpFZ(f'Could not find the following license{_azGjD}: {_pfHjB}')
            return _5elWI
        for _oOcOM, _4VYmw in _73ONZ:
            _4VYmw.prettyprint()
        if not _73ONZ:
            return _S3dnx
        _azGjD = '' if len(_73ONZ) == 1 else 's'
        if automatic_yes or Confirm.ask(f'Uninstall the above license{_azGjD} and deactivate machine?'):
            for _3He5r, _4mgws in _73ONZ:
                try:
                    _4mgws.deactivate({_rdZ7v()})
                except Exception:
                    pass
            for _VYtlM, _vp7tY in _73ONZ:
                _VYtlM.unlink()
            if not any(_VYtlM.parent.iterdir()):
                _VYtlM.parent.rmdir()
            _lhrkA('Removed.', style='green')
            return _S3dnx
        _lhrkA('Abort.')
        return _5elWI

    def _m4mwD(license_data):
        try:
            _vFjMt = _s4zAO(license_data)
        except Exception as e:
            _VWpFZ(str(e))
            return _5elWI
        _vFjMt.prettyprint()
        return _S3dnx

    def _3rpsp(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _VJTGP = list(_qSV2y(license_keys_or_ids={license_key_or_id}))
        except _5CyRv as e:
            _VWpFZ(str(e))
            return _5elWI
        if not _VJTGP:
            _ddhCb = f"Couldn't find license with key or ID {license_key_or_id}"
            _VWpFZ(_ddhCb)
            return _5elWI
        _tOYDr = _rdZ7v()
        if not machine_fingerprints:
            machine_fingerprints = {_tOYDr}
        _lhrkA()
        for _Koso9 in machine_fingerprints:
            _lhrkA(_Koso9, style='bold')
        _lhrkA()
        if automatic_yes or Confirm.ask(f'Activate the above machine(s) for license {license_key_or_id}?'):
            for _X5Efd, _unSyz in _VJTGP:
                try:
                    _unSyz.activate()
                except (RuntimeError, _Tron3) as e:
                    _VWpFZ(str(e))
                    return _5elWI
                _unSyz.prettyprint()
        return _S3dnx

    def _Fl5Sz(license_key_or_id, machine_fingerprints, automatic_yes=False):
        assert isinstance(license_key_or_id, str)
        assert isinstance(machine_fingerprints, set)
        try:
            _WBqIZ = list(_qSV2y(license_keys_or_ids={license_key_or_id}))
        except _5CyRv as e:
            _VWpFZ(str(e))
            return _5elWI
        if not _WBqIZ:
            _mmCso = f"Couldn't find license with key or ID {license_key_or_id}"
            _VWpFZ(_mmCso)
            return _5elWI
        _C8Ln2 = _rdZ7v()
        if not machine_fingerprints:
            machine_fingerprints = {_C8Ln2}
        _lhrkA()
        for _DE73w in machine_fingerprints:
            _lhrkA(_DE73w, style='bold')
        _lhrkA()
        if automatic_yes or Confirm.ask(f'Deactivate the above machine(s) for license {license_key_or_id}?'):
            for _3qq2O, _G9rkm in _WBqIZ:
                try:
                    _G9rkm.deactivate(machine_fingerprints)
                except Exception as e:
                    _VWpFZ(str(e))
                    return _5elWI
                _G9rkm.prettyprint()
        return _S3dnx

    def _r8FRZ(argv=None):
        _QAHlv = argparse.ArgumentParser(description='Stonefish License Manager.', formatter_class=RichHelpFormatter)
        _QAHlv.add_argument('--version', '-v', action='version', version=_NDWhk(), help='display version information')
        _1D4Im = _QAHlv.add_subparsers(title='subcommands', required=True)
        _irq1F = _1D4Im.add_parser('versions', help='Display version information, including dependencies', aliases=['vv'], formatter_class=_QAHlv.formatter_class)
        _irq1F.set_defaults(func=lambda _63CFY: _W8rpr())
        _OF2CU = _1D4Im.add_parser('list', help='List installed licenses', aliases=['ls', 'show', 'info'], formatter_class=_QAHlv.formatter_class)
        _OF2CU.add_argument('-r', '--raw', action='store_true', help='Show raw license data')
        _OF2CU.add_argument('-k', '--show-keys', action='store_true', help='Show license keys')
        _OF2CU.add_argument('license_ids_or_keys', type=str, nargs='*', help='License IDs or keys (optional)')
        _OF2CU.set_defaults(func=lambda _Ynboa: _RcSZo(set(_Ynboa.license_ids_or_keys), _Ynboa.raw, _Ynboa.show_keys))
        _fTgYX = _1D4Im.add_parser('install', help='Install (and activate) licenses', aliases=['add', 'a'], formatter_class=_QAHlv.formatter_class)
        _fTgYX.add_argument('license_file', type=str, help='License file')
        _fTgYX.set_defaults(func=lambda _lSSPb: _m4mwD(str(_lSSPb.license_file)))
        _ZuZgN = _1D4Im.add_parser('uninstall', help='Uninstall (and deactivate) licenses', aliases=['remove', 'rm', 'delete', 'del'], formatter_class=_QAHlv.formatter_class)
        _ZuZgN.add_argument('license_key_or_id', type=str, nargs='+', help='License keys or IDs')
        _ZuZgN.add_argument('-y', '--yes', action='store_true', help='Automatic yes to prompts')
        _ZuZgN.set_defaults(func=lambda _93YlH: _gm76B(_93YlH.license_key_or_id, _93YlH.yes))
        _fTgYX = _1D4Im.add_parser('activate', help='Activate machine for license', formatter_class=_QAHlv.formatter_class)
        _fTgYX.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _fTgYX.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _fTgYX.set_defaults(func=lambda _awkfX: _3rpsp(_awkfX.license_file_or_id_or_key, set(_awkfX.machine_fingerprints)))
        _fTgYX = _1D4Im.add_parser('deactivate', help='Deactivate machine for license', formatter_class=_QAHlv.formatter_class)
        _fTgYX.add_argument('license_file_or_id_or_key', type=str, help='License file or ID or key')
        _fTgYX.add_argument('machine_fingerprints', type=str, nargs='*', help='Machine fingerprints (default: this machine)')
        _fTgYX.set_defaults(func=lambda _YNrTN: _Fl5Sz(_YNrTN.license_file_or_id_or_key, set(_YNrTN.machine_fingerprints)))
        _OF2CU = _1D4Im.add_parser('fingerprint', help='Display machine fingerprint', aliases=['fp'], formatter_class=_QAHlv.formatter_class)
        _OF2CU.set_defaults(func=_WALWm)
        _1SWy5 = _1D4Im.add_parser('refresh', help='Refresh license files and cache', formatter_class=_QAHlv.formatter_class)
        _1SWy5.set_defaults(func=_6kps0)
        _KpfOj = _1D4Im.add_parser('cache', help='Manage the cache', formatter_class=_QAHlv.formatter_class)
        _avEoT = _KpfOj.add_subparsers(title='subcommands', required=True)
        _Ct58q = _avEoT.add_parser('clear', help='Remove all items from the cache', aliases=['clean'], formatter_class=_QAHlv.formatter_class)
        _Ct58q.set_defaults(func=_aIrpL)
        _nE9Bh = _avEoT.add_parser('dir', help='Show the cache directory', formatter_class=_QAHlv.formatter_class)
        _nE9Bh.set_defaults(func=_zto2H)
        _YNrTN = _QAHlv.parse_args(argv)
        return _YNrTN.func(_YNrTN)

    def _NDWhk():
        _N4Fk7 = _igKWe('stonefish-license-manager')
        return '\n'.join([f'Stonefish License Manager {_N4Fk7} [Python {_eqrJe()}]'])

    def _W8rpr():
        for _ksgtC in python_package_info.yield_info_lines('stonefish-license-manager'):
            print(_ksgtC)

    def _6kps0(_):
        _Lvm8N = _z0cxQ()
        _lhrkA(f'Refreshed {_Lvm8N} installed licenses')
        _aIrpL(_)
        return _S3dnx

    def _aIrpL(_):
        _sCNsZ()
        _R1tXt()
        _hBrNf()
        return _S3dnx

    def _zto2H(_):
        _lhrkA(_VMujV)
        return _S3dnx
_HOK8e()
del _HOK8e
