"""
Implements optimization methods for AMM arbitrage and routing

All classes derived from the ``ArbOptimizerBase`` class answer
two fundamental questions in relation to a market consisting
of multiple AMMs in one or multiple token pairs:

-   **Arbitrage**: Are there arbitrage opportunities in the
    market and how can we exploit them?
    
-   **Routing**: Given a set of desired in and out tokens
    (typically one in, one out), what is the optimal route,
    taking into account arbitrage opportunities that may be
    present int the market

This class mostly defines common interface code that the derived classes
are meant to implement, and contains a number of utilities that are useful
across those classes.

The most importance objects contained in this class are

- The ``MargPOptimizerResult`` class, which encapsulates the result of the marginal
    price optimization method (1)
    
- The ``TradeInstruction`` class, which encapsulates the trade instructions that
    are generated by the optimization methods; it serves as an abstraction layer
    between the results of the optimization and the format in which subsequent code
    wants to consume the results

- The ``SelfFinancingConstraints`` class, which is used to define the context
    of the optimization, notably the token amounts in and out of the overall 
    market, and which token receives the arbitrage profit, if any (2)
    

    
NOTE 1. The marginal price optimization method is now the only method in use, all other
optimization methods have been deprecated and are available only for historical and research
purposes, which explains its predominant role in this module

NOTE 2. For arbitrage purposes this class is overkill, but it allows for defining arbitrary 
optimal routing problems; in current optimizer usage the target token is indicated as
string, and the optimizer constructs the constraint object automatically. Therefore, the
constraints object should not be considered API.

---
This module is still subject to active research, and comments and suggestions are welcome. 
The corresponding author is Stefan Loesch <stefan@bancor.network>

(c) Copyright Bprotocol foundation 2023. 
Licensed under MIT
"""
__VERSION__ = "6.0-rc3" # TODO-RELEASE
__DATE__ = "01/Jun/2024+"

from dataclasses import dataclass, field, InitVar
import sys
import math
import numpy as np
import pandas as pd
from abc import ABC, abstractmethod

from ..curves import SimplePair as Pair
from ..curves import CurveContainer
from ..helpers.dcbase import DCBase
from .base import OptimizerBase, OptimizerResult
from enum import Enum

FORMATTER = lambda x: "" if ((abs(x) < 1e-10) or math.isnan(x)) else f"{x:,.2f}"

F = OptimizerBase.F


class TIF(Enum):
    """
    trade instruction formats (``enum``)
    """
    OBJECTS = "objects"
    DICTS = "dicts"
    DFRAW = "dfraw"
    DFAGGR = "dfaggr"
    DFAGGR8 = "dfaggr8"
    DFPG = "dfgain"
    DFPG8 = "dfgain8"
    
    # NOTE: there is a line `elif ti_format.name[:2] == "df":`
    # so do not change those names
    
@dataclass
class TradeInstruction(DCBase):
    """
    encodes a single trade on a single curve (1)

    as seen from the AMM; in-numbers must be positive, out-numbers negative

    :cid:               the curve id
    :tknin:             token in
    :amtin:             amount in (``>0``)
    :tknout:            token out
    :amtout:            amount out (``<0``)
    :error:             error message (if any; ``None`` means no error)
    :curve:             the curve object (optional); note: users of this object need
                        to decide whether they trust the preparing code to set curve
                        or whether they fetch it via the ``cid`` themselves
    :raiseonerror:      if ``True``, raise an error if the trade instruction is invalid,
                        otherwise just set the error message
    
    NOTE 1. The ``TradeInstruction`` object is used to represent the results of the 
    optimization; every ``TradeInstruction`` represents a single trade on a single 
    curve, and trade instructions issued will consist of a list of ``TradeInstruction`` 
    objects. Importantly, those instructions do not take financing into account, ie they
    assume that all tokens going into the curves are present in the wallet, and will only
    be returned into the wallet at the end. If this is not the case, the transaction must
    be *linerarized* so that at no point the wallet goes into overdraft. In the general
    case this is a complex problem and is not being addressed in this library. However,
    the ``ArbGraphs`` module provides some analysis functions in this respect. 
    """

    cid: any
    tknin: str
    amtin: float
    tknout: str
    amtout: float
    error: str = field(repr=True, default=None)
    curve: InitVar = None
    raiseonerror: InitVar = False

    POSNEGEPS = 1e-8

    def __post_init__(self, curve=None, raiseonerror=False):
        self.curve = curve
        if curve is not None:
            if self.cid != curve.cid:
                err = f"curve/cid mismatch [{self.cid} vs {curve.cid}]"
                self.error = err
                if raiseonerror:
                    raise ValueError(err)
        if self.tknin == self.tknout:
            err = f"tknin and tknout must be different [{self.tknin} {self.tknout}]"
            self.error = err
            if raiseonerror:
                raise ValueError(err)
        self.cid = str(self.cid)
        self.tknin = str(self.tknin)
        self.tknout = str(self.tknout)
        self.amtin = float(self.amtin)
        self.amtout = float(self.amtout)
        if not self.amtin * self.amtout < 0:
            if (abs(self.amtin) < self.POSNEGEPS and abs(self.amtout) < self.POSNEGEPS):
                self.amtin = 0
                self.amtout = 0
            else:
                err = f"amtin and amtout must be of different sign [{self.amtin} {self.tknin}, {self.amtout} {self.tknout}]"
                self.error = err
                if raiseonerror:
                    raise ValueError(err)

        if not self.amtin >= 0:
            err = f"amtin must be positive [{self.amtin}]"  # seen from AMM
            self.error = err
            if raiseonerror:
                raise ValueError(err)

        if not self.amtout <= 0:
            err = f"amtout must be negative [{self.amtout}]"  # seen from AMM
            self.error = err
            if raiseonerror:
                raise ValueError(err)

    TIEPS = 1e-10

    @classmethod
    def new(cls, curve_or_cid, tkn1, amt1, tkn2, amt2, *, eps=None, raiseonerror=False):
        """
        alternative constructor: automatically determines direction [API]
        
        NOTE: This alternative constructor recommended over the native constructor. The key
        difference is that it determines automatically which token is ``in`` and which 
        token is ``out``
        """
        try:
            cid = curve_or_cid.cid
            curve = curve_or_cid
        except:
            cid = curve_or_cid
            curve = None
        if eps is None:
            eps = cls.TIEPS
        if amt1 > 0:
            newobj = cls(
                cid=cid,
                tknin=tkn1,
                amtin=amt1,
                tknout=tkn2,
                amtout=amt2,
                curve=curve,
                raiseonerror=raiseonerror,
            )
        else:
            newobj = cls(
                cid=cid,
                tknin=tkn2,
                amtin=amt2,
                tknout=tkn1,
                amtout=amt1,
                curve=curve,
                raiseonerror=raiseonerror,
            )

        return newobj

    @property
    def is_empty(self):
        """
        returns ``True`` if this is an empty trade instruction [API]
        
        NOTE 1: for numerical reasons the optimizer can sometimes create trade instructions
        that are effectively empty, ie the amounts are zero; this function returns ``True``
        in those cases
        """
        return self.amtin == 0 or self.amtout == 0

    @classmethod
    def to_dicts(cls, trade_instructions):
        """converts iterable of ``TradeInstruction`` objects to a ``tuple`` of ``dict`` [API]"""
        return tuple(ti.as_dict() for ti in trade_instructions)

    @classmethod
    def to_df(cls, trade_instructions, robj, ti_format=None):
        """
        converts iterable ot ``TradeInstruction`` objects to a pandas ``DataFrame`` [API]

        :trade_instructions:    iterable of ``TradeInstruction`` objects
        :robj:                  ``OptimizationResult`` object generating the trade instructions
        :ti_format:             see ``to_format`` for details
        """
        
        # TODO: Passing ``robj`` may pose issues with the GraphOptimizer that does not have the 
        # fields needed in the object; this output is for Human interface purposes only in any case 
        # search for `robj` to see how it is used
        if ti_format is None:
            ti_format = cls.TIF.DFRAW
        cid8 = ti_format in set([cls.TIF.DFAGGR8, cls.TIF.DFPG8])
        dicts = (
            {
                "cid": ti.cid if not cid8 else ti.cid[-10:],
                "pair": ti.curve.pair if not ti.curve is None else "",
                "pairp": ti.curve.pairp if not ti.curve is None else "",
                "tknin": ti.tknin,
                "tknout": ti.tknout,
                ti.tknin: ti.amtin,
                ti.tknout: ti.amtout,
            }
            for ti in trade_instructions
        )
        df = pd.DataFrame.from_dict(list(dicts)).set_index("cid")
        if ti_format in set([cls.TIF.DFRAW]):
            return df
        if ti_format in set([cls.TIF.DFAGGR, cls.TIF.DFAGGR8]):
            df1r = df[df.columns[4:]]
            df1 = df1r.fillna(0)
            dfa = df1.sum().to_frame(name="TOTAL NET").T
            dfp = df1[df1 > 0].sum().to_frame(name="AMMIn").T
            dfn = df1[df1 < 0].sum().to_frame(name="AMMOut").T
            try:
                # create line for prices, if possible, and create the full df
                # [it may not be possible because p_optimal is not defined in all results]
                dfpr = pd.Series(robj.p_optimal).to_frame(name="PRICE").T
                df = pd.concat([df1r, dfpr, dfp, dfn, dfa], axis=0)
            except:
                # otherwise create the full df without prices
                df = pd.concat([df1r, dfp, dfn, dfa], axis=0)
            
            dfc = df.copy()
            try:
                # fillna on the prices if they are available (see above)
                dfc.loc["PRICE"].fillna(1, inplace=True)
            except: pass
            return dfc
        
        if ti_format in set([cls.TIF.DFPG, cls.TIF.DFPG8]):
            ti = trade_instructions
            r = robj
            eff_p_out_per_in = [-ti_.amtout / ti_.amtin for ti_ in ti]
            data = dict(
                exch=[ti_.curve.P("exchange_name") for ti_ in ti],
                cid=[
                    ti_.cid if ti_format == cls.TIF.DFPG else ti_.cid[-10:]
                    for ti_ in ti
                ],
                fee=[
                    ti_.curve.fee for ti_ in ti
                ],  # if split here must change conversion below
                pair=[
                    ti_.curve.pair
                    if ti_format == cls.TIF.DFPG
                    else Pair.n(ti_.curve.pair)
                    for ti_ in ti
                ],
                amt_tknq=[
                    ti_.amtin if ti_.tknin == ti_.curve.tknq else ti_.amtout
                    for ti_ in ti
                ],
                tknq=[ti_.curve.tknq for ti_ in ti],
                margp0=[ti_.curve.p for ti_ in ti],
                effp=[
                    p if ti_.tknout == ti_.curve.tknq else 1 / p
                    for p, ti_ in zip(eff_p_out_per_in, ti)
                ],
                margp=[
                    r.price(tknb=ti_.curve.tknb, tknq=ti_.curve.tknq) for ti_ in ti
                ],
            )
            df = pd.DataFrame(data)
            df["gain_r"] = np.abs(df["effp"] / df["margp"] - 1)
            df["gain_tknq"] = -df["amt_tknq"] * (df["effp"] / df["margp"] - 1)

            cgt_l = (
                (cid, gain, tkn)
                for cid, gain, tkn in zip(df.index, df["gain_tknq"], df["tknq"])
            )
            cgtp_l = (
                (cid, gain, tkn, r.price(tknb=tkn, tknq=r.targettkn))
                for cid, gain, tkn in cgt_l
            )
            cg_l = ((cid, gain * price) for cid, gain, tkn, price in cgtp_l)
            df["gain_ttkn"] = tuple(gain for cid, gain in cg_l)
            df = df.sort_values(["exch", "gain_ttkn"], ascending=False)
            df = df.set_index(["exch", "cid"])
            return df

        raise ValueError(f"unknown format {ti_format}")

    TIF = TIF

    @classmethod
    def to_format(cls, trade_instructions, robj=None, *, ti_format=None):
        """
        converts iterable of ``TradeInstruction`` objects to the given format [API]

        :trade_instructions:    iterable of TradeInstruction objects
        :robj:                  OptimizationResult object generating the trade instructions
        :ti_format:             format to convert to
        :returns:               the trade instructions in the given format (see table)
        
        ==================    ====================================================
        ``ti_format``         returns
        ==================    ====================================================
        ``OBJECTS``           a list of TradeInstruction objects (default)
        ``DICTS``             a list of TradeInstruction dictionaries
        ``DFRAW``             raw DataFrame (holes are filled with NaN)
        ``DFPG``              returns a "pretty" DataFrame (holes are spaces)
        ``DFAGRR``            aggregated DataFrame
        ==================    ====================================================
        
        NOTE. The ``DF`` formats also come in an ``8`` variant, for example ``DFRAW8``,
        which shortens the CID to 8 characters.
        """
        if ti_format is None:
            ti_format = cls.TIF.OBJECTS
        #print("[TradeInstruction] to_format", ti_format, ti_format.name)
        
        if ti_format == cls.TIF.OBJECTS:
            return tuple(trade_instructions)
        elif ti_format == cls.TIF.DICTS:
            return cls.to_dicts(trade_instructions)
        elif ti_format.name[:2] == "DF":
            trade_instructions = tuple(trade_instructions)
            if len(trade_instructions) == 0:
                return pd.DataFrame()
            return cls.to_df(trade_instructions, robj=robj, ti_format=ti_format)
        else:
            raise ValueError(f"unknown format {ti_format}")

    @property
    def price_outperin(self):
        """
        trade price expressed in out-token per in-token [API]
        
        NOTE: aliased as ``p``
        """
        return -self.amtout / self.amtin
    p = price_outperin

    @property
    def price_inperout(self):
        """
        trade price expressed in in-token per out-token [API]
        
        NOTE: aliased as ``pr`` (reverse price)
        """
        return -self.amtin / self.amtout
    pr = price_inperout

    @property
    def prices(self):
        """
        tuple (``price_outperin``, ``price_inperout``) [API]
        
        NOTE: aliased as ``pp``
        """
        return (self.price_outperin, self.price_inperout)
    pp = prices


@dataclass
class SelfFinancingConstraints(DCBase):
    """
    describes self financing constraints and determines optimization variable (1)

    :data:      a ``dict`` ``TKN -> amount``, or ``AMMPays``, ``AMMReceives``, ``OptimizationVar`` (see table)
    :tokens:    set of all tokens in the problem (if ``None``, use ``data.keys()``)
    
    =====================   ================================================================================
    value                   meaning
    =====================   ================================================================================
    amount                  from the AMM perspective, total inflows (>0) or outflows (<0);
                            for all items not present in data the value is assumed zero
    ``AMMPays``             the AMM payout should be maximized [from the trader (!) perspective]
    ``AMMReceives``         the money paid into the AMM should be minimized [ditto]
    ``OptimizationVar``     like AMMPays and AMMReceives, but if the direction of the payout is
                            not known at the beginning [not all methods allow this]
    ``OV``                  alias for ``OptimizationVar``
    =====================   ================================================================================
    
    
    NOTE 1: this class is mostly relevant for the convex optimizer, and the convex optimizer
    is not longer in active use; the marginal price optimizer does not currently implement
    routing functionality, so only trivial self financing constraints (all zero) are allowed.
    """

    class CONSTRAINT(Enum):
        """constraint type (``enum``)"""
        AMMPays = "AMMPays"
        AMMReceives = "AMMReceives"
        OptimizationVar = "OptimizationVar"
    OV = CONSTRAINT.OptimizationVar

    data: dict
    tokens: set = None

    def __post_init__(self):
        optimizationvars = tuple(k for k, v in self.data.items() if isinstance(v, self.CONSTRAINT))
        assert (len(optimizationvars) == 1), f"there must be EXACTLY one AMMPays, AMMReceives, OptimizationVar {self.data}"
        self._optimizationvar = optimizationvars[0]
        if self.tokens is None:
            self.tokens = set(self.data.keys())
        else:
            if isinstance(self.tokens, str):
                self.tokens = set(t.strip() for t in self.tokens.split(","))
            else:
                self.tokens = set(self.tokens)
            assert (set(self.data.keys()) - self.tokens == set()), f"constraint keys {set(self.data.keys())} > {self.tokens}"

    @property
    def optimizationvar(self):
        """
        optimization variable, ie the in that is set to ``AMMPays``, ``AMMReceives`` or ``OptimizationVar``
        """
        return self._optimizationvar

    @property
    def tokens_s(self):
        """tokens as a comma-separated string"""
        return ", ".join(self.tokens_l)

    @property
    def tokens_l(self):
        """tokens as a ``list``"""
        return sorted(list(self.tokens))

    def as_dict(self, *, short=False):
        """``dict`` representation including zero-valued tokens (unless short)"""
        if short:
            return {**self.data}
        return {k: self.get(k) for k in self.tokens}

    def items(self, *, short=False):
        return self.as_dict(short=short).items()

    @classmethod
    def new(cls, tokens, **data):
        """alternative constructor: ``data`` as kwargs"""
        return cls(data=data, tokens=tokens)

    @classmethod
    def arb(cls, targettkn):
        """alternative constructor: arbitrage constraint, ie all other constraints are zero"""
        return cls(data={targettkn: cls.CONSTRAINT.OptimizationVar})

    def get(self, item):
        """gets the constraint, or 0 if not present"""
        assert item in self.tokens, f"item {item} not in {self.tokens}"
        return self.data.get(item, 0)

    def is_constraint(self, item):
        """
        returns ``True`` iff ``item`` is a constraint (ie not an optimization variable)
        """
        return not self.is_optimizationvar(item)

    def is_optimizationvar(self, item):
        """
        returns ``True`` iff ``item`` is the optimization variable
        """
        assert item in self.tokens, f"item {item} not in {self.tokens}"
        return item == self.optimizationvar

    def is_arbsfc(self):
        """
        returns ``True`` iff the constraint is an arbitrage constraint
        """
        if len(self.data) == 1:
            return True
        data1 = [v for v in self.data.values() if v != 0]
        return len(data1) == 1

    def __call__(self, item):
        """alias for ``get``"""
        return self.get(item)

@dataclass
class ArbOptimizerResult(OptimizerResult, ABC):
    """
    results of the ``ArbOptimizerBase`` [API]

    :curves:        curve objects underlying the optimization, as ``CurveContainer``
    :targetkn:      target token (=profit token) of the optimization
    :raiseonerror:  it ``True``, raises on error; otherwise returns ``None``
    """
    curves: any = field(repr=False, default=None)
    targettkn: str = field(repr=True, default=None)
    raiseonerror: bool = field(repr=False, default=False)

    TIF = TIF
    
    @abstractmethod
    def trade_instructions(self, ti_format=None):
        """
        returns trade instructions in the desired format (abstract method)
        """
        raise NotImplementedError("trade_instructions must be implemented in derived class")

    @property
    def result_token(self):
        """
        returns (token) unit of the result, which is the target token [API]
        """
        return self.targettkn

@dataclass
class MargPOptimizerResult(ArbOptimizerResult):
    """
    results of the ``MargP___Optimizer`` classes [API]
    
    :p_optimal:     optimal price vector, as ``dict``
    """
    p_optimal: dict = field(repr=False, default=None)
    
    def __post_init__(self, *args, **kwargs):
        super().__post_init__(*args, **kwargs)
        if not self.is_error:
            try:
                assert isinstance(self.p_optimal, dict), f"p_optimal must be a dict {self.p_optimal}"
            except AssertionError as e:
                raise ValueError(f"missing parameters in non-error result [{e}]")

    def trade_instructions(self, ti_format=None):
        """
        returns list of ``TradeInstruction`` objects [API]

        :ti_format:     use the ``TIF`` enum constants to determine format; 
                        see ``TradeInstruction.to_format`` for details; 
                        default is ``to_format`` default (1)
        
        NOTE 1. Data frame formats are only meant for human consumption. All 
        production code must use ``TIF.OBJECTS`` or ``TIF.DICTS``.
        """
        try:
            assert (self.is_error is False), "cannot get this data from an error result"
            assert (self.curves is not None), "curves must be set [do not use minimal results]"
            result = (
                ArbOptimizerBase.TradeInstruction.new(
                    curve_or_cid=c, tkn1=c.tknx, amt1=dx, tkn2=c.tkny, amt2=dy
                )
                for c, dx, dy in zip(self.curves, self.dxvalues, self.dyvalues)
                if dx != 0 or dy != 0
            )
            return ArbOptimizerBase.TradeInstruction.to_format(
                result, robj=self, ti_format=ti_format
            )
        except AssertionError:
            if self.raiseonerror:
                raise
            return None

    def price(self, tknb, tknq):
        """
        returns the optimal price of ``tknb/tknq`` based on ``p_optimal``, in ``tknq`` per ``tknb``
        """
        assert (self.p_optimal is not None), "p_optimal must be set [do not use minimal results]"
        try:
            return self.p_optimal[tknb] / self.p_optimal[tknq]
        except KeyError as e:
            raise KeyError("Can't calculate price. Wrong token? {tknb} {tknq} {self.p_optimal} [{e}]")
    
    @property
    def tokens_t(self):
        """
        the tokens associated with the result as ``tuple`` (1)
        
        NOTE 1. technically, the dict keys of ``self.p_optimal``, as tuples
        """
        return tuple(self.p_optimal.keys())
    
    def dxdyvalues(self, as_dict=False):
        """
        returns a vector of ``(dx, dy)`` values for each curve [API]
        
        :as_dict:       specifies the return type 
        :returns:       a ``dict``, or (default) a ``tuple``
        
        see also ``dxvecvalues``
        """
        assert self.is_error is False, "cannot get this data from an error result"
        assert (not self.curves is None), "curves must be set"
        result = (
            (c.cid, c.dxdyfromp_f(self.price(c.tknb, c.tknq))[0:2])
            for c in self.curves
        )
        if as_dict:
            return {cid: dxdy for cid, dxdy in result}
        return tuple(dxdy for cid, dxdy in result)

    def dxvecvalues(self, as_dict=False):
        """
        returns a ``dict`` ``{tkn: dtknk}`` of changes for each curve
        
        :as_dict:       specifies the return type 
        :returns:       a ``dict``, or (default) a ``tuple``
        
        see also ``dxdyvalues``
        """
        assert self.is_error is False, "cannot get this data from an error result"
        assert (not self.curves is None), "curves must be set"
        result = (
                (c.cid, c.dxvecfrompvec_f(self.p_optimal)) 
                for c in self.curves
            )
        if as_dict:
            return {cid: dxvec for cid, dxvec in result}
        return tuple(dxvec for cid, dxvec in result)

    @property
    def dxvalues(self):
        """
        extracts the ``dx`` from the ``dxdyvalues``
        
        :returns:       a ``tuple`` of ``dx`` values
        """
        return tuple(dx for dx, dy in self.dxdyvalues())

    @property
    def dyvalues(self):
        """
        extracts the ``dy`` from the ``dxdyvalues`` [API]
        
        :returns:       a ``tuple`` of ``dy`` values
        """
        return tuple(dy for dx, dy in self.dxdyvalues())

    @property
    def curves_new(self):
        """
        returns a list of curve objects with the trade instructions implemented
        """
        assert self.is_error is False, "cannot get this data from an error result"
        assert not self.optimizer is None, "optimizer must be set"
        return self.optimizer.adjust_CC(dxvals=self.dxvalues)


class ArbOptimizerBase(OptimizerBase):
    """
    Arbitrage Optimizer, ie finding optimal transactions to arbitrage markets

    :curves:         the CurveContainer object (or the curves therein) the optimizer is using
    """
    __VERSION__ = __VERSION__
    __DATE__ = __DATE__
    
    TIF = TIF
    TradeInstruction = TradeInstruction
    SelfFinancingConstraints = SelfFinancingConstraints
    CONSTRAINT = SelfFinancingConstraints.CONSTRAINT
    OV = SelfFinancingConstraints.OV
    
    def __init__(self, curves):
        # TODO: convert this class into a dataclass and lose the explicit __init__ method
        self._CC = curves
        self.__post_init__()

    def __post_init__(self):
        if not isinstance(self._CC, CurveContainer):
            self._CC = CurveContainer(self._CC)
        self.CC.freeze()
    
    @property
    def CC(self):
        """
        returns the associated whole-market curve container object
        """
        return self._CC    
    
    @property
    def curves(self):
        """DEPRECTATED alias for ``CC``"""
        print("[ArbOptimizerBase] curves is deprecated; use CC")
        raise DeprecationWarning("curves is deprecated; use CC")
        return self.CC

    @property
    def tokens(self):
        return self.CC.tokens

    def SFC(self, **data):
        """alias for ``SelfFinancingConstraints.new``"""
        return self.SelfFinancingConstraints.new(self.CC.tokens(), **data)

    def SFCd(self, data_dct):
        """alias for ``SelfFinancingConstraints.new``, with ``data_dct`` a ``dict``"""
        return self.SelfFinancingConstraints.new(
            self.CC.tokens(), **data_dct
        )

    def SFCa(self, targettkn):
        """alias for ``SelfFinancingConstraints.arb``"""
        return self.SelfFinancingConstraints.arb(targettkn)
    arb = SFCa

    def price_estimates(self, *, tknq, tknbs, **kwargs):
        """
        convenience function to access ``CurveContainer.price_estimates``

        :tknq:      can only be a single token
        :tknbs:     list of tokens

        see ``help(CurveContainer.price_estimate)`` for details
        """
        return self.CC.price_estimates(tknqs=[tknq], tknbs=tknbs, **kwargs)

    def adjust_CC(self, dxvals, *, verbose=False, raiseonerror=False):
        """
        returns a new ``CurveContainer`` with the curves shifted by the given ``dx`` values
        """
        # print("[adjust_CC]", dxvals)
        if dxvals is None:
            if raiseonerror:
                raise ValueError("dxvals is None")
            else:
                print("[adjust_CC] dxvals is None")
                return None
        curves = self.CC
        try:
            newcurves = [
                c.execute(dx=dx, verbose=verbose, ignorebounds=True)
                for c, dx in zip(curves, dxvals)
            ]
            return CurveContainer(newcurves)
        except Exception as e:
            if raiseonerror:
                raise e
            else:
                print(f"Error in adjust_CC: {e}")
                # raise e
                return None

    def plot(self, *args, **kwargs):
        """
        convenience for ``self.CC.plot``

        see help(CurveContainer.plot) for details
        """
        return self.CC.plot(*args, **kwargs)

    class DC(Enum):
        """desired output of ``dump_curves`` (``enum``)"""
        DEFAULT = True
        JSON = "json"
        DICTS = "dicts"
        DF = "df"
        CONSTR = "constr"
        
    def dump_curves(self, mode=DC.DEFAULT, *, dest=None):
        """
        dumps the curves, by default to ``stdout``

        :mode:      dump mode, determining format (see below)
        :dest:      ``stdout`` (default), ``stderr``, or an open file handle (1)
        
        ===============  ===================================
        `mode`           meaning 
        ===============  ===================================
        ``DC.DEFAULT``   default mode (DC.CONSTR)
        ``DC.JSON``      JSON format
        ``DC.DICTS``     dict format
        ``DC.DF``        DataFrame format
        ``DC.CONSTR``    curve constructor format
        ===============  ===================================
        
        NOTE 1. the file must be open for writing; it will not be closed; the code below
        allows capturing the output in a string
        
        ```
        from io import StringIO
        out = StringIO()
        O.dump_curves(dest=out)
        result = out.getvalue()
        ```
        """
        dest = dest or "stdout"
        if isinstance(dest, str):
            dest = dest.lower()
            if dest == "stdout": f = sys.stdout
            elif dest == "stderr": f = sys.stderr
        else:
            f = dest
        
        if mode == self.DC.DEFAULT: mode = self.DC.CONSTR
        if mode == self.DC.JSON:
            print(self.CC.as_json(), file=f)
        elif mode == self.DC.DICTS:
            print(self.CC.as_dicts(), file=f)
        elif mode == self.DC.DF:
            print(self.CC.as_df(), file=f)
        elif mode == self.DC.CONSTR:
            print(self.CC.as_repr(), file=f)
        else:
            raise ValueError(f"unknown mode {mode}")
        
    def format(self, *args, **kwargs):
        """
        convenience for ``self.CC.format``

        see help(CurveContainer.format) for details
        """
        return self.CC.format(*args, **kwargs)
