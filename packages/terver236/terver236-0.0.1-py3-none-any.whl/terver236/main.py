def terver():
   return """#1 Инвестор сформировал портфель из акций компаний А и В, затратив на приобретение акций А в 9 раз больше средств чем на покупку акций В. Ожидаемая доходность за период владения акциями А и В составляет 4% и 3%, при этом стандартное отклонение доходности равно 6% и 6%, соответственно. 1) Найдите (в %) стандартное отклонение доходности портфеля инвестора, если известно, что коэффициент корреляции доходностей акций А и В равен 0,4.
#(((9/10)**2*(0.06)**2+(1/10)**2*(0.06)**2+2*(0.4)*(9/10*1/10)*(0.06)*(0.06))**0.5*100)
## var  = a**2 * var(a) + b**2 *var(b) + 2 * po * a * b * std(a)*std (b)
## std = var **0.5
## std * 100

#2 Ожидаемая доходность и стандартное отклонение доходности за период для акций компаний А, В, С составляют 2%, 3%, 3% и 3%, 5%, 5%, соответственно. 1) Предполагая независимость доходностей акций А, В и С, найдите (в %) ожидаемую доходность портфеля, составленного из этих акций так, чтобы дисперсия его доходности была минимальной.
#from sympy import *
#x, y = symbols('x y')
## std
#a=0.03
#b=0.05
#c=0.05

#f = a**2*x**2+y**2*b**2+(1-x-y)**2*c**2
## a - стандартное отклонение a
## b - стандартное отклонение b
## c - стандартное отклонение c
## x - доля a
## y - доля b
## (1-x-y) - доля с

#df_dx = diff(f, x)
#df_dy = diff(f, y)

#solution = solve((df_dx, df_dy), (x, y))
#((solution[x]*0.02+solution[y]*0.03+(1-solution[x]-solution[y])*0.03)*100)
## a * E(a) + b * E(b) + (1-a-b) * E(c)

#3 Математическое ожидание доходности акций компаний А и В составляет 4% и 5%, при этом стандартное отклонение доходности равно 5% и 8%, соответственно. Также известен коэффициент корреляции ρAB доходностей акций А и В, ρAB=0,30. Найдите (короткие позиции допускаются): 1) доли акций А и В в портфеле с минимальной дисперсией доходности; 2) ожидаемую доходность и стандартное отклонение доходности такого портфеля.
#from sympy import *
#x = symbols('x')
# std
#a=0.05
#b=0.08

#f = a**2*x**2+(1-x)**2*b**2 + 2*a*b*x*(1-x)*(0.3)
## a - стандартное отклонение a
## b - стандартное отклонение b
## x - доля a
## (1-X) - доля b

#df_dx = diff(f, x)
#solution = solve(df_dx)
#print(solution[0])
#print(1-solution[0])

#E=0.04 * solution[0] + 0.05 * (1-solution[0])
#print(E*100)

#var=a**2*solution[0]**2+b**2*(1-solution[0])**2+2*(0.3)*(1-solution[0])*solution[0]*a*b

#print(var**0.5*100)


#4Имеется 37 монет, из которых 6 бракованные: вследствие заводского брака на этих монетах с обеих сторон отчеканен герб. Наугад выбранную монету, не разглядывая, бросают несколько раз. 1) Какова вероятность, что при 4 бросках она ляжет гербом вверх? 2) При 4 бросках монета легла гербом вверх. Какова вероятность того, что была выбрана монета с двумя гербами?

#count_all = 37
#unique = 6

#P_A = unique/count_all + (count_all-unique)/count_all *(1/2)**4
## P_A = P(взяли брак) * P(выпадение 4-х гербов) +  P(взяли нормальную)* P (выпадение 4-х гербов)

#print(P_A)

#P_B_A = unique/count_all / P_A
## P_B_A  =(P(взяли брак)) /  P_A

#print(P_B_A)


#5В первой корзине имеется 11 шаров, при этом количество белых шаров равно либо 3, либо 10. Оба варианта равновероятны. Во второй корзине имеется 25 шаров, а количество белых шаров равно 2, 23 или 25. Эти три варианта также равновероятны. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?

## y = [ 5 , 26 , 28 , 12 , 33 , 35 ]
#y=[i+j for i in [3,10] for j in [2,23,25]]
#py=[1/6,1/6,1/6,1/6,1/6,1/6]

#Omega=11+25
#P_A=0

## P _A = (E(5)*1/6 + E(26)*1/6+ ... + E(35) *1/6) / Omega
#for i in range(len(y)):
    #P_A+=y[i]*py[i] / Omega

#print(rrstr(P_A,3))

#P_H_A = (3/2/Omega+10/2/Omega)/P_A
## (3 * 1/2 + 10 *1/2)/Omega / P_A
#print(P_H_A)

#6Имеется две корзины с белыми и черными шарами. В первой корзине всего 6 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 3 и p = 0,8. Во второй корзине имеется всего 11 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 4 и p = 0,7. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?
#from scipy.stats import *

#box1 = binom(3, 0.8)
#box2 = binom(4, 0.7)
#A = 0
#H = 0

#for n1 in range(box1.args[0]+1):
    #for n2 in range(box2.args[0]+1):
        #A += box1.pmf(n1)*box2.pmf(n2)*((n1+n2)/(6+11))
        #H += box1.pmf(n1)*box2.pmf(n2)*(n1/(6+11))
#print(A)
#print(H/A)

#7Имеется две корзины с белыми и черными шарами. В первой корзине количество белых – 9, количество черных – 13. Во второй корзине количество белых – 19, количество черных – 20. Из первой корзины случайно, без возвращения, излекаются 7 шаров, а из второй – 8 шаров. Отобранные из обеих корзин шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?

#w1 = 9
#b1 = 13
#w2 = 19
#b2 = 20

#count1 = 7
#count2 = 8

#p_white1 = w1 / (w1 + b1)
#p_black1 = b1 / (w1 + b1)
#p_white2 = w2 / (w2 + b2)
#p_black2 = b2 / (w2 + b2)

#ans = (count1 * p_white1 + count2 * p_white2) / (count1 + count2)
#print(ans)

#ans2 = (count1 * p_white1) / (count1 * p_white1 + count2 * p_white2)
#print(ans2)


#8Банк выдал кредиты двум группам заемщиков: 180 заемщиков в первой группе и 70 – во второй. Известно, что заемщики из первой группы возвращают кредит с вероятностью 0,93, а заемщики из второй группы – с вероятностью 0,92. Пусть X – суммарное количество возвращенных кредитов для обеих групп. Предполагая независимость заемщиков, найдите: 1) стандартное отклонение X; 2) асимметрию X. Указание: используйте присущее третьему центральному моменту свойство аддитивности (основное свойство семиинвариантов).

#p1 = 0.93
#n1 = 180

#p2 = 0.92
#n2 = 70

#var_X = n1*(p1 - p1**2)+ n2 * (p2 - p2**2)
#std_X = var_X**0.5

#mu3_x1=p1-3*p1**2 + 2*p1**3
#mu3_x2=p2-3*p2**2 + 2*p2**3

#AS_X = (n1*mu3_x1 + n2*mu3_x2) / std_X**3


#print(std_X)
#print(AS_X)


#9Независимые пуассоновские случайные величины X,Y,Z имеют следующие стандартные отклонения: σX=0,3; σY=0,9; σZ=1,8. Пусть S=X+Y+Z. Найдите: 1) вероятность P(S=7); 2) наиболее вероятное значение суммы S; 3) стандартное отклонение σS; 4) асимметрию As(S); 5) эксцесс Ex(S).
#from scipy.stats import *
#S = 7
#x_std = 0.3
#y_std = 0.9
#z_std = 1.8

#P_S = poisson.pmf(S, x_std**2 + y_std**2 + z_std**2)
#print(P_S,3)

#s_sum = x_std**2 + y_std**2 + z_std**2
#print(s_sum)

#s_std = (x_std**2 + y_std**2 + z_std**2)**0.5
#print(s_std)


#As_S = 1 / s_sum**0.5
#print(As_S)

#Ex_S = 1 / s_sum
#print(Ex_S)


#10Монеты в количестве 11 штук подбрасываются до тех пор, пока 14 раз не выпадет 5 гербов. Пусть X – число бросков до первого появления 5 гербов, а Y – число бросков до последнего появления 5 гербов (Y = общее число бросков). Найдите: 1) математическое ожидание X; 2) стандартное отклонение X; 3) коэффициент корреляции между X и Y; 4) математическое ожидание XY.
#import math

#n = 11
#count_g = 14
#gerb = 5

#P = math.comb(n, gerb) / 2**n

#E_X = 1/P
#print(E_X)

#var_x = (1-P)/P**2
#std_x = var_x**0.5
#print(std_x)

#po = var_x / (std_x * std_x * count_g**0.5)
#print(po)

#E_XY = var_x + count_g*E_X**2
#print(E_XY)

#11Корзина содержит 34 шаров, среди которых 14 – красных и 5 – синих. Из корзины, случайным образом, без возвращения извлекаются 12 шаров. Пусть X и Y обозначают количество красных и синих шаров среди извлеченных, соответственно. Найдите ковариацию Cov(X,Y).
#N = 34
#red = 14
#blue = 5
#n = 12


#var_x = n * (red / N) * (1 - red / N) * (N - n) / (N-1)
#var_y = n * (blue / N) * (1 - blue / N) * (N - n) / (N-1)

#var_x_y = n * ((blue + red) / N) * (1 - (blue + red) / N) * (N - n) / (N-1)
#cov_xy = (var_x_y - var_x- var_y)/2

#cov_xy


#12Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 4 и 5. Пусть X — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(4)=0,11 и P(5)=0,22. Требуется найти: 1) E(X); 2) дисперсию X, если известно, что из 4 и 5 сначала выпала цифра 5. Указание: разберите пример на применение формулы полного математичекого ожидания (лекция 14, слайд 13 из курса ТВ-2017).
#P_1 = 0.11
#P_2 = 0.22

#P_1_or_2 = P_1 + P_2
#P_H1 = P_1 / P_1_or_2
#P_H2 = P_2 / P_1_or_2


#E_Y = 1/ P_1_or_2

#E_Z = P_1/P_2/P_1_or_2 + P_2/P_1/P_1_or_2

#E_X = E_Y + E_Z
#print(E_X)


#var_y = (1 - P_1_or_2) / P_1_or_2**2
## на противоположную
#var_z = (1 - P_1) / P_1**2
#var_x = var_z + var_y
#print(var_x)


#13Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 2, 3 и 4. Пусть X — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(2)=0,17, P(3)=0,11 и P(4)=0,13. Требуется найти: 1) E(X); 2) дисперсию X, если известно, что из 2, 3 и 4 сначала выпала цифра 2, затем — 3.
#a = 0.17
#b = 0.11
#c = 0.13


#E = 1/a + 1/b + 1/c - (1/(a+b) + 1/(a+c) + 1/(b+c)) + 1/(a+b+c)

#var = (1-(a+b+c))/((a+b+c)**2) + (1-(b+c))/((b+c)**2) + (1-c)/(c**2)

#print(E)
#print(var)


#14В прямоугольной области, заданной ограничениями |x|⩽20 и |y|⩽8, случайным образом выбираются две точки: (x1,y1) и (x2,y2). Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 11; B – модуль разности |x1−x2| меньше 14. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите в заданной прямоугольной области 100000 пар точек и, используя все эти точки, найдите ответы, округляя их до одного знака после запятой.
#import random

#x = 20
#y = 8

#N = 100000

#count_A = 0
#count_B = 0
#count_A_and_B = 0

#for _ in range(N):
    #x1 = random.uniform(-x, x)
    #y1 = random.uniform(-y, y)

    #x2 = random.uniform(-x, x)
    #y2 = random.uniform(-y, y)

    #distance = ((x1 - x2)**2 + (y1 - y2)**2)**0.5

    #if distance < #11:
        #count_A += 1

    #if abs(x1 - x2) < #14:
        #count_B += 1

    #if distance < #11 and abs(x1 - x2) < #14:
        #count_A_and_B += 1

#P_A = count_A / N
#P_A_given_B = count_A_and_B/count_B


#print(P_A)
#print(P_A_given_B)


#15В области, ограниченной эллипсом (u/13)**2+(v/6)**2=1, случайным образом выбираются две точки. Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 7,9; B – все координаты обеих точек больше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.
#import numpy as np
#from scipy.stats import *
#N = 100000


#a = #13
#b = #6

#r=#1

#R1= uniform(0,1)
#Phi1=uniform(0,2)
#R2=uniform(0,1)
#Phi2=uniform(0,2)
#lengt1=np.sqrt(R1.rvs(size=N))
#angle1=np.pi*Phi1.rvs(size=N)
#lengt2=np.sqrt(R2.rvs(size=N))
#angle2=np.pi*Phi2.rvs(size=N)


#x1=a*lengt1*np.cos(angle1)
#x2=a*lengt2*np.cos(angle2)

#y1=b*lengt1*np.sin(angle1)
#y2=b*lengt2*np.sin(angle2)


#count = 0
#count_A = 0
#count_B = 0
#count_A_and_B  = 0
#for i in range(0, N):

    #distance = ((x1[i] - x2[i])**2 + (y1[i] - y2[i])**2)**0.5
    #if distance < #7.9:
        #count_A += 1

    #if x1[i] > 0 and y1[i] > 0 and x2[i] > 0 and y2[i] > 0 :
        #count_B += 1
        #if distance < #7.9:
            #count_A_and_B += 1

#P_A= count_A / N
#P_A_B = count_A_and_B / count_B


#print(P_A)
#print(P_A_B)


#16В области, ограниченной эллипсом (u/23)**2+(v/6)**2=1, случайным образом выбираются две точки. Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 9,2; B – координаты первой точки больше 0, а координаты второй точки меньше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.
#import numpy as np
#from scipy.stats import *
#N = 100000


#a = 23
#b = 6
#r=1

#R1= uniform(0,1)
#Phi1=uniform(0,2)

#R2=uniform(0,1)
#Phi2=uniform(0,2)

#lengt1=np.sqrt(R1.rvs(size=N))
#angle1=np.pi*Phi1.rvs(size=N)
#lengt2=np.sqrt(R2.rvs(size=N))
#angle2=np.pi*Phi2.rvs(size=N)

#x1=a*lengt1*np.cos(angle1)
#x2=a*lengt2*np.cos(angle2)

#y1=b*lengt1*np.sin(angle1)
#y2=b*lengt2*np.sin(angle2)


#count = 0
#count_A = 0
#count_B = 0
#count_A_and_B  = 0
#for i in range(0, N):

    #distance = ((x1[i] - x2[i])**2 + (y1[i] - y2[i])**2)**0.5
    #if distance < 9.2:
        #count_A += 1

    #if (x1[i] > 0 and y1[i] > 0 and x2[i] < 0 and y2[i] < 0) or (x1[i] < 0 and y1[i] < 0 and x2[i] > 0 and y2[i] > 0):
        #count_B += 1
        #if distance < 9.2:
            #count_A_and_B += 1

#P_A= count_A / N
#P_A_B = count_A_and_B / count_B


#print(P_A)
#print(P_A_B)

#17В кубе объема 1 случайным образом выбираются точки A, B и C. Пусть R, S и T – события, состоящие в том, что: R – наименьший угол в треугольнике ABC меньше 26,7°; S – наибольший угол в треугольнике ABC меньше 81,9°; T – треугольник ABC остроугольный. Найдите приближенно, методом Монте-Карло: 1) условную вероятность P(R|T); 2) условную вероятность P(S|T). Указание: получите 100000 остроугольных треугольников ABC и, используя все эти треугольники, найдите ответы, округляя их до одного знака после запятой.
#import random
#import numpy as np
#import math

#N = 100000


#R = 0
#S = 0
#T = 0

#V = #1

#for j in range(N):
    #x1 = random.uniform(0, V**(1/3))
    #y1 = random.uniform(0, V**(1/3))
    #z1 = random.uniform(0, V**(1/3))
    #x2 = random.uniform(0, V**(1/3))
    #y2 = random.uniform(0, V**(1/3))
    #z2 = random.uniform(0, V**(1/3))
    #x3 = random.uniform(0, V**(1/3))
    #y3 = random.uniform(0, V**(1/3))
    #z3 = random.uniform(0, V**(1/3))

    #a = ((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)**0.5
    #b = ((x3 - x2)**2 + (y3 - y2)**2 + (z3 - z2)**2)**0.5
    #c = ((x1 - x3)**2 + (y1 - y3)**2 + (z1 - z3)**2)**0.5


    #cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
    #A = math.acos(cos_A) * 180 / np.pi

    #cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
    #B = math.acos(cos_B) * 180 / np.pi

    #cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
    #C = math.acos(cos_C) * 180 / np.pi

    #if max(A, B, C) < 90:
        #T += 1
        #if min(A, B, C) < #26.7:
            #R += 1
        #if max(A, B, C) < #81.9:
            #S += 1
#print(R/T)
#print(S/T)


#18Абсолютная непрерывная случайная величина
#from scipy.stats import *
#from scipy import *
#a = 4
#b = 9
#q = 0.9
#def f(x):
    #if a <= x <= b :
        #return (1+ 7*x**0.5 + 8*x**0.7 + 4*x**0.9)**1.3
    #else:
        #return 0
#C = 1 / integrate. quad (f,a, b) [0]
#print(C)

#class distrv(rv_continuous):
    #def _pdf (self, x):
        #return C * f(x)
#X = distrv(a=a, b=b)

#'''def g(x):
    #return x*C*f(x)
#E = integrate.quad(g,a, b)[0]
#print(E)'''
#E = X.expect()
#print(rrstr(E,3))
#def g2(x):
    #return C*f(x) *(x-E)**2
#print((integrate.quad(g2,a, b)[0])**0.5)
#print(X.ppf(q))


#19Случайная величина
#from scipy import *
#from scipy.stats import *
#a = 4
#b = 8
#q =0.8
#def f(x):
    #return (1 + 6 * x**0.5 + 4 * x**0.7 + 5 * x**0.9)**1.3

#def f2(x):
    #return  f(x) * (1/ (b-a))

#E = integrate.quad(f2,a,b)[0]
#print(E)
#def f3(x):
    #return (f(x))**2 * (1/ (b-a))
#E_y_2 = integrate.quad(f3,a,b)[0]

#std  = (E_y_2 - E**2)**0.5
#print(std)

#def f3(x):
    #return f(x)**3 * (1/ (b-a))

#E_y_3 = integrate.quad(f3,a,b)[0]
#mu3 = E_y_3 - 3*E_y_2*E + 2 * E**3
#print(mu3 / std**3)

#X = uniform(loc = a, scale = (b - a))
#qv = f(X.ppf(q))
#print(qv)


#20Для нормального случайного вектора (X,Y)∼N(−8;16;49;1;0,8) найдите вероятность P((X−3)(Y−7)<0).

#import numpy as np
#E_x = -8
#E_y = 16
#var_x = 49
#std_x = 7
#var_y = 1
#std_y = 1
#po = 0.8
#x0 = 3
#y0 = 7

#mu= np.array([E_x, E_y])

#Cov = np.array([[ var_x, po*std_x*std_y], [po*std_x*std_y, var_y]])

#W=multivariate_normal(mu, Cov)

#X=norm(E_x,std_x)
#Y=norm(E_y,std_y)
#P= X.cdf(x0)+Y.cdf(y0)-2*W.cdf([x0,y0])
#print(P)


#21Для нормального случайного вектора (X,Y)∼N(−4;4;64;81;−0,31) найдите вероятность P((X−8)(X−10)(Y−1)<0).
#E_x = -4
#E_y = 4
#var_x = 64
#std_x = 8
#var_y = 81
#std_y = 9
#po = -0.31
#'''x0<x1'''
#x0 = 8
#x1 = 10
#y0 = 1
#mu= np.array([E_x, E_y])
#Cov = np.array([[ var_x, po*std_x*std_y], [po*std_x*std_y, var_y]])

#W=multivariate_normal(mu, Cov)
#X=norm(E_x,std_x)
#Y=norm(E_y,std_y)
#P = X.cdf(x1) - X.cdf(x0) + 2*W.cdf([x0,y0]) - 2*W.cdf([x1,y0]) + Y.cdf(y0)
#print(P)


#22Случайный вектор имеет плотность распределения
#import sympy as sp
#from fractions import Fraction
#x = sp.Symbol('x')
#y = sp.Symbol('y')

#q_xy = 60*x**2 +96*x*y - 16*x + 60*y**2 + 10*y + 85/12

#dq_dx = sp.diff(q_xy, x)
#dq_dy = sp.diff(q_xy, y)

#solution = sp.solve((dq_dx ,dq_dy), (x, y))

#print('E(x) = ',solution[x])
#print('E(y) = ',solution[y])

#c = np.array([[60, 48], [48, 60]])
## c = [[a,b],[c,d]]
## c_inverse = [[d,-c],[-b,a]]
## det = d*a - c*b
#c_inverse = np.array([[60, -48], [-48, 60]]) * (1/(60**2 - 48**2))
#print(c_inverse)
#var_x = c_inverse[0][0]
#print('var_x = ', Fraction(var_x).limit_denominator())

#var_y = c_inverse[1][1]
#print('var_y = ', Fraction(var_y).limit_denominator())

#cov_xy = c_inverse[0][1]
#print('cov_xy = ', Fraction(cov_xy).limit_denominator())

##po = cov_xy / (var_x*var_x)**0.5
#print('po = ', Fraction(po).limit_denominator())"""
