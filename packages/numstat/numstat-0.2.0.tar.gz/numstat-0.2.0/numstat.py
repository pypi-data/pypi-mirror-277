def f1():
    """
В первой корзине имеется 11 шаров, при этом количество белых шаров равно либо 3, либо 10.
Оба варианта равновероятны. Во второй корзине имеется 25 шаров, а количество белых шаров равно 2, 23 или 25.
Эти три варианта также равновероятны. Из обеих корзин все шары перекладываются в третью корзину.
Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)?
Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар
первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?


# Вероятности для корзины 1
P_B1 = 0.5  # Вероятность, что в корзине 1 3 белых шара
P_B2 = 0.5  # Вероятность, что в корзине 1 10 белых шаров

# Вероятности для корзины 2
P_C1 = 1/3  # Вероятность, что в корзине 2 2 белых шара
P_C2 = 1/3  # Вероятность, что в корзине 2 23 белых шара
P_C3 = 1/3  # Вероятность, что в корзине 2 25 белых шара

# Общее количество шаров в каждой корзине
total_balls_1 = 11
total_balls_2 = 25

# Число белых шаров в каждом случае
white_balls_B1 = 3
white_balls_B2 = 10

white_balls_C1 = 2
white_balls_C2 = 23
white_balls_C3 = 25

# Рассчитываем вероятности события A для каждого сочетания
P_A_given_B1_C1 = (white_balls_B1 + white_balls_C1) / (total_balls_1 + total_balls_2)
P_A_given_B1_C2 = (white_balls_B1 + white_balls_C2) / (total_balls_1 + total_balls_2)
P_A_given_B1_C3 = (white_balls_B1 + white_balls_C3) / (total_balls_1 + total_balls_2)
P_A_given_B2_C1 = (white_balls_B2 + white_balls_C1) / (total_balls_1 + total_balls_2)
P_A_given_B2_C2 = (white_balls_B2 + white_balls_C2) / (total_balls_1 + total_balls_2)
P_A_given_B2_C3 = (white_balls_B2 + white_balls_C3) / (total_balls_1 + total_balls_2)

# Общая вероятность события A
P_A = (
    P_B1 * P_C1 * P_A_given_B1_C1 +
    P_B1 * P_C2 * P_A_given_B1_C2 +
    P_B1 * P_C3 * P_A_given_B1_C3 +
    P_B2 * P_C1 * P_A_given_B2_C1 +
    P_B2 * P_C2 * P_A_given_B2_C2 +
    P_B2 * P_C3 * P_A_given_B2_C3
)

# Вероятность того, что белый шар из первой корзины
P_H = total_balls_1 / (total_balls_1 + total_balls_2)

# Вероятности P(A|H)
P_A_given_H = (P_B1 * white_balls_B1 / total_balls_1 + P_B2 * white_balls_B2 / total_balls_1)

# Условная вероятность P(H|A)
P_H_given_A = (P_A_given_H * P_H) / P_A

# Выводим результаты
print(f"Вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым: {P_A:.4f}")
print(f"Условная вероятность P(H|A), что белый шар из первой корзины: {P_H_given_A:.4f}")
----------------------------------------------

Имеется две корзины с белыми и черными шарами. В первой корзине всего 6 шаров,
при этом количество белых шаров распределено по биномиальному закону с параметрами n = 3 и p = 0,8.
Во второй корзине имеется всего 11 шаров, при этом количество белых шаров распределено
по биномиальному закону с параметрами n = 4 и p = 0,7.
Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей
корзины шар окажется белым (событие A)?
2) Найдите условную вероятность P(H|A), того, что случайно вынутый из
третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?


from scipy.stats import *
u_1 = binom(3, 0.8)
u_2 = binom(4, 0.7)
A = 0
H = 0
for n1 in range(u_1.args[0]+1):
    for n2 in range(u_2.args[0]+1):
        A += u_1.pmf(n1)*u_2.pmf(n2)*((n1+n2)/17)
        H += u_1.pmf(n1)*u_2.pmf(n2)*(n1/17)
print(A)
print(H/A)

--------------------------------

1. Имеется две корзины с белыми и черными шарами.
В первой корзине количество белых – 11, количество черных – 12.
Во второй корзине количество белых – 17, количество черных – 18.
Из первой корзины случайно, без возвращения, излекаются 5 шаров, а из второй – 6 шаров.
Отобранные из обеих корзин шары перекладываются в третью корзину.
1) Какова вероятность $P(A)$, что случайно вынутый из третьей корзины шар окажется белым (событие $A$)?
2) Найдите условную вероятность $P(H|A)$, того, что случайно вынутый из третьей корзины шар
первоначально находился в первой корзине (событие $H$), при условии, что он белый (событие $A$)?<br/>


wt1, bl1 = 11, 12

wt2, bl2 = 17, 18


take1 = 5
take2 = 6

balls1 = wt1 + bl1
balls2 = wt2 + bl2

p_h1 = take1 / (take2 + take1)
p_h2 = take2 / (take2 + take1)

p_ah1 = wt1 / balls1
p_ah2 = wt2 / balls2


p_a = p_h1 * p_ah1 + p_h2 * p_ah2
print(f"{p_a}".replace(".", ","))

p_ha = p_h1 * p_ah1 / p_a
print(f"{p_ha}".replace(".", ","))
--------------------------------------------

Имеется 37 монет, из которых 6 бракованные: вследствие заводского брака на этих монетах с обеих сторон отчеканен герб. Наугад выбранную монету, не разглядывая, бросают несколько раз.

Какова вероятность, что при 4 бросках она ляжет гербом вверх?
При 4 бросках монета легла гербом вверх. Какова вероятность того, что была выбрана монета с двумя гербами?



# Определим вероятности и количество монет
total_coins = 37
defective_coins = 6
normal_coins = total_coins - defective_coins

# Вероятности выпадения герба при броске
P_heads_normal = 0.5
P_heads_defective = 1.0

# Вероятности выпадения герба 4 раза подряд
P_4_heads_normal = P_heads_normal ** 4
P_4_heads_defective = P_heads_defective ** 4

# Вероятности выбора монет
P_normal = normal_coins / total_coins
P_defective = defective_coins / total_coins

# Общая вероятность выпадения 4 гербов подряд
P_4_heads_total = P_4_heads_normal * P_normal + P_4_heads_defective * P_defective

# Условная вероятность, что выбрана бракованная монета, если выпало 4 герба подряд
P_defective_given_4_heads = (P_4_heads_defective * P_defective) / P_4_heads_total

# Вывод результатов
print(f"Вероятность того, что при 4 бросках монета ляжет гербом вверх: {P_4_heads_total:.4f}")
print(f"Вероятность того, что была выбрана монета с двумя гербами: {P_defective_given_4_heads:.4f}")


    """

def f2():
    """
Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут
цифры $3$ и $6$. Пусть $X$ — число сделанных при этом бросков.
Даны вероятности появления цифр в одном броске: $\text{P}(3)=0,19$ и $\text{P}(6)=0,14$.
Требуется найти: 1) $\text{E}(X)$; 2) дисперсию $X$, если известно, что из $3$ и $6$ сначала выпала цифра $6$.
Указание: разберите пример на применение формулы <i>полного математичекого ожидания</i>
(лекция 14, слайд 13 из <a href=ʺhttps://kursm.ru/lib/tv2017.pdfʺ>курса ТВ-2017</a>).<br/>

a=0.14
b=0.19
ex1=1/(a+b)
ex2=1/a+1/b-2/(a+b)

x1=geom(a+b)
x2=geom(b)
ex1+ex2,x1.var()+x2.var()

-----------------------------

Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут
цифры $1$,  $2$ и $3$. Пусть $X$ — число сделанных при этом бросков.
Даны вероятности появления цифр в одном броске: $\text{P}(1)=0,19$, $\text{P}(2)=0,11$ и $\text{P}(3)=0,12$.
Требуется найти: 1) $\text{E}(X)$; 2) дисперсию $X$, если известно, что из $1$,  $2$ и $3$
сначала выпала цифра $1$, затем  — $2$.<br/>

p1 = 0.19
p2 = 0.11
p3 = 0.12

p_y = p1 + p2 + p3
E_Y = 1 / p_y

p_H1 = p1 / p_y
p_H2 = p2 / p_y
p_H3 = p3 / p_y

H1 = p2 + p3
H2 = p1 + p3
H3 = p1 + p2
E_Z = p_H1 / H1 + p_H2 / H2 + p_H3 / H3

P_H12 = p1 * p2 / (p2 + p3) / p_y
P_H13 = p1 * p3 / (p3 + p2) / p_y
P_H21 = p2 * p1 / (p1 + p3) / p_y
P_H23 = p2 * p3 / (p3 + p1) / p_y
P_H31 = p3 * p1 / (p1 + p2) / p_y
P_H32 = p3 * p2 / (p2 + p1) / p_y

E_W = P_H12 / p3 + P_H13 / p2 + P_H21/ p3 + P_H23/p1 + P_H31/p2 + P_H32/p1
print(E_W + E_Z + E_Y)

var = (1-p_y)/(p_y**2) + (1-H1)/(H1**2) + (1-p3)/(p3**2)
print(var)


    """


def f3():
    """
Банк выдал кредиты двум группам заемщиков: 180 заемщиков в первой группе и 70 – во второй.
Известно, что заемщики из первой группы возвращают кредит с вероятностью 0,93, а заемщики из второй группы – с вероятностью 0,92.
Пусть X – суммарное количество возвращенных кредитов для обеих групп.
Предполагая независимость заемщиков, найдите:
1) стандартное отклонение X; 2) асимметрию X.
Указание: используйте присущее третьему центральному моменту свойство аддитивности (основное свойство семиинвариантов).


import numpy as np

# Зададим параметры биномиальных распределений для каждой партии семян
n1, p1 = 180, 0.93  # Параметры для первой партии
n2, p2 = 70, 0.92  # Параметры для второй партии

# Рассчитаем дисперсию для каждой партии
var_S1 = n1 * p1 * (1 - p1)
var_S2 = n2 * p2 * (1 - p2)

# Общая дисперсия суммы проросших семян
var_S = var_S1 + var_S2

# Стандартное отклонение суммы
std_S = np.sqrt(var_S)

# Асимметрия для каждой партии
skew_S1 = (1 - 2 * p1) / np.sqrt(n1 * p1 * (1 - p1))
skew_S2 = (1 - 2 * p2) / np.sqrt(n2 * p2 * (1 - p2))

# Комбинированная асимметрия
combined_skewness = (skew_S1 * var_S1**1.5 + skew_S2 * var_S2**1.5) / var_S**1.5

std_S, combined_skewness
----------------------

Независимые пуассоновские случайные величины X,Y,Z
имеют следующие стандартные отклонения: σX=0,3; σY=0,9; σZ=1,8. Пусть S=X+Y+Z. Найдите:
1) вероятность P(S=7);
2) наиболее вероятное значение суммы S;
3) стандартное отклонение σS;
4) асимметрию As(S);
5) эксцесс Ex(S)


import math
from scipy.stats import poisson

# Заданные стандартные отклонения
sigma_X = 0.3
sigma_Y = 0.9
sigma_Z = 1.8

# Вычисление параметров распределений
lambda_X = sigma_X ** 2
lambda_Y = sigma_Y ** 2
lambda_Z = sigma_Z ** 2

# Параметр суммы
lambda_S = lambda_X + lambda_Y + lambda_Z

# 1. Вероятность P(S=7)
P_S_7 = poisson.pmf(7, lambda_S)
print(f"1. Вероятность P(S=7): {P_S_7}")

# 2. Наиболее вероятное значение суммы S (мода)
mode_S = math.floor(lambda_S) if poisson.pmf(math.floor(lambda_S), lambda_S) >= poisson.pmf(math.floor(lambda_S) - 1, lambda_S) else math.floor(lambda_S) - 1
print(f"2. Наиболее вероятное значение суммы S: {mode_S}")

# 3. Стандартное отклонение σS
sigma_S = math.sqrt(lambda_S)
print(f"3. Стандартное отклонение σS: {sigma_S}")

# 4. Асимметрия As(S)
asymmetry_S = 1 / math.sqrt(lambda_S)
print(f"4. Асимметрия As(S): {asymmetry_S}")

# 5. Эксцесс Ex(S)
excess_S = 1 / lambda_S
print(f"5. Эксцесс Ex(S): {excess_S}")
--------------------

Монеты в количестве 11 штук подбрасываются до тех пор, пока 14 раз не выпадет 5 гербов.
Пусть X – число бросков до первого появления 5 гербов, а Y – число бросков до последнего появления 5 гербов (Y= общее число бросков).
Найдите:
1) математическое ожидание X;
2) стандартное отклонение X;
3) коэффициент корреляции между X и Y;
4) математическое ожидание XY

import math
n = 11
count_g = 14
gerb = 5

P = math.comb(n, gerb) / 2**n

E_X = 1/P
print(E_X)

var_x = (1-P)/P**2
std_x = var_x**0.5
print(std_x)

po = var_x / (std_x * std_x * count_g**0.5)
print(po)

E_XY = var_x + count_g*E_X**2
print(E_XY)
----------------


Корзина содержит 34 шаров, среди которых 14 – красных и 5 – синих.
Из корзины, случайным образом, без возвращения извлекаются 12 шаров.
Пусть X и Y обозначают количество красных и синих шаров среди извлеченных, соответственно.
Найдите ковариацию Cov(X,Y).


# Параметры задачи
n = 12
M1 = 14
M2 = 5
N = 34

# Вычисление ковариации
cov_XY = - (n * M1 * M2 * (N - n)) / (N**2 * (N - 1))

# Вывод результата
print("Ковариация Cov(X, Y):", cov_XY)


-------------------------
mean_A = 0.01
std_A = 0.03
mean_B = 0.03
std_B = 0.06
rho_AB = 0.37

cov_matrix = np.array([[std_A**2, rho_AB * std_A * std_B],
                       [rho_AB * std_A * std_B, std_B**2]])

inv_cov_matrix = np.linalg.inv(cov_matrix)

results = []

for weight_A in np.arange(-1, 2, 0.01):
    weight_B = 1 - weight_A
    weights = np.array([weight_A, weight_B])

    mean_portfolio = np.dot([mean_A, mean_B], weights)

    std_portfolio = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))

    results.append((weights, mean_portfolio, std_portfolio))

min_std_index = np.argmin([result[2] for result in results])
min_std_weights, min_std_mean, min_std_std = results[min_std_index]

print("Доли акций A и B в портфеле с минимальной дисперсией доходности:")
print("Доля акций A:", min_std_weights[0])
print("Доля акций B:", min_std_weights[1])
print("Ожидаемая доходность портфеля:", min_std_mean)
print("Стандартное отклонение доходности портфеля:", min_std_std)


-------------------------

2. Математическое ожидание доходности акций компаний А и В составляет $1$% и $3$%,
при этом стандартное отклонение доходности равно $3$% и $6$%, соответственно. Также известен
коэффициент корреляции $\rho_{AB}$ доходностей акций А и В, $\rho_{AB}=0,37$. Найдите (короткие позиции допускаются):
1) доли акций А и В в портфеле с минимальной дисперсией доходности;
2) ожидаемую доходность и стандартное отклонение доходности такого портфеля. <br/>

mean_A = 0.01
std_A = 0.03
mean_B = 0.03
std_B = 0.06
rho_AB = 0.37

cov_matrix = np.array([[std_A**2, rho_AB * std_A * std_B],
                       [rho_AB * std_A * std_B, std_B**2]])

inv_cov_matrix = np.linalg.inv(cov_matrix)

results = []

for weight_A in np.arange(-1, 2, 0.01):
    weight_B = 1 - weight_A
    weights = np.array([weight_A, weight_B])

    mean_portfolio = np.dot([mean_A, mean_B], weights)

    std_portfolio = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))

    results.append((weights, mean_portfolio, std_portfolio))

min_std_index = np.argmin([result[2] for result in results])
min_std_weights, min_std_mean, min_std_std = results[min_std_index]

print("Доли акций A и B в портфеле с минимальной дисперсией доходности:")
print("Доля акций A:", min_std_weights[0])
print("Доля акций B:", min_std_weights[1])
print("Ожидаемая доходность портфеля:", min_std_mean)
print("Стандартное отклонение доходности портфеля:", min_std_std)


    """


def f4():
    """
 1. Абсолютно непрерывная случайная величина $X$ может принимать значения только в отрезке $[5,9]$.
На этом отрезке плотность распределения случайной величины $X$ имеет вид:
$f(x)=C(1+7x^{0,5}+4x^{0,7}+9x^{0,9})^{1,4}$, где $C$  – положительная константа.
Найдите:
1) константу $C$;
2) математическое ожидание $\text{E}(X)$;
3) стандартное отклонение $\sigma_X$;
4) квантиль уровня $0,8$ распределения $X$.<br/>

def f1(x):
    return (1+7*x**0.5+4*x**0.7+9*x**0.9)**1.4
def f(x):
    return c*f1(x)
def g(x):
    return x*f(x)
def h(x):
    return (Ex-x)**2*f(x)
x = np.linspace(5, 9, 100000000)
res = quad(f1, 5, 9)[0]
c = 1/res
Ex = quad(g, 5, 9)[0]
varx = quad(h, 5, 9)[0]
stdx = np.sqrt(varx)
print(c)
print(Ex)
print(stdx)
res1 = 0
x = 5
q = 0.8
while res1 < q:
    res1 = quad(f, 5, x)[0]
    x+=0.0001
print(x)
-----------------------------

2. Случайная величина $X$ равномерно распределена на отрезке $[5,10]$.
Случайная величина $Y$ выражается через $X$ следующим образом:
$Y=(1+5X^{0,5}+9X^{0,7}+2X^{0,9})^{1,3}$.
Найдите:
1) математическое ожидание $\text{E}(Y)$;
2) стандартное отклонение $\sigma_Y$;
3) асимметрию $\As(Y)$;
4) квантиль уровня $0,7$ распределения $Y$.<br/>


x = np.linspace(5, 10, 10000000)
def f(x):
    return (1 + 5*x**0.5+ 9*x**0.7+2*x**0.9)**1.3
y = f(x)
print(y.mean())
print(y.std())
c = skew(y)
print(c)
s = np.percentile(y, 70)
print(s)

-------------------


    """

def f5():

    """
Для нормального случайного вектора $(X,Y)\sim N(-9;3;1;4;0,9)$ найдите вероятность $\text{P}((X-1)(Y-3)<0)$.<br/>

mu = np.array([-9, 3])
cov = np.array([[1, 0.9*1*2],[0.9*1*2, 4]])
W = multivariate_normal(mu, cov)
X = norm(-9, 1)
Y = norm(3, 2)
Pa = X.cdf(1) - W.cdf([1,3])
Pb = Y.cdf(3) - W.cdf([1,3])
c = Pa+Pb
c

------------

 Для нормального случайного вектора $(X,Y)\sim N(-5;4;16;49;-0,09)$  найдите вероятность $\text{P}((X-4)(X-13)(Y-1)<0)$.<br/>
mu = np.array([-5, 4])
cov = np.array([[16, -0.09*4*7],[-0.09*4*7, 49]])
W = multivariate_normal(mu, cov)
X = norm(-5, 4)
Y = norm(4, 7)

Pa = W.cdf([4, 1])
Pb = X.cdf(13) - X.cdf(4) - (W.cdf([13, 1]) - W.cdf([4, 1]))
Pc = Y.cdf(1) - W.cdf([13, 1])

c = Pa+Pb+Pc
c

    """

def f6():

    """
 5.  Случайный вектор $(X,Y)$
имеет плотность распределения
$$
f_{X,Y}(x,y)=\frac{15 e^{- \frac{25 x^{2}}{2} - 20 x y - 4 x - \frac{25 y^{2}}{2} - 3 y - \frac{29}{90}}}{2 \pi}
$$
Найдите:
1) математическое ожидание $\text{E}(X)$;
2) математическое ожидание $\text{E}(Y)$;
3) дисперсию $\text{V}\!\text{ar}(X)$;
4) дисперсию $\text{V}\!\text{ar}(Y)$;
5) ковариацию $\text{Cov}(X,Y)$;
6) коэффициент корреляции $\rho(X,Y)$.<br/>


x, y = symbols('x, y')
q = 25*x**2+40*x*y+8*x +6*y + 25*y**2 + Rational(29, 45)
eq1 = diff(q, x)
eq2 = diff(q, y)
solve({eq1, eq2},{x,y})
C = Matrix([[25, 20],[20, 25]])
C = C**-1
rho = Rational(C[0, 1], C[0, 0])
print(solve({eq1, eq2},{x,y}))
print(C)
print(rho)
    """
def imports():
    """
from scipy.stats import *
import scipy.integrate as integrate
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import quad
import scipy.stats as sps
from scipy.stats import uniform, skew
from scipy.stats import multivariate_normal
from sympy import *
    """