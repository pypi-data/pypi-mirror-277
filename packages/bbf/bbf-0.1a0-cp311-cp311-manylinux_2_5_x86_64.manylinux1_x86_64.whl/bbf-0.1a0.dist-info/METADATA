Metadata-Version: 2.1
Name: bbf
Version: 0.1a0
Summary: Fast computation of broadband fluxes and mags
Home-page: https://gitlab.in2p3.fr/lemaitre/bbf
Author: Nicolas Regnault
Author-email: nicolas.regnault@lpnhe.in2p3.fr
License: Apache Software License
Keywords: astronomy,astrophysics
Classifier: Development Status :: 2 - Pre-Alpha
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Scientific/Engineering :: Astronomy
Classifier: Topic :: Scientific/Engineering :: Physics
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy
Requires-Dist: pandas
Requires-Dist: scipy
Requires-Dist: scikit-sparse
Requires-Dist: mkl
Requires-Dist: sparse-dot-mkl
Requires-Dist: matplotlib
Requires-Dist: platformdirs
Requires-Dist: sncosmo
Requires-Dist: astropy
Requires-Dist: getCalspec
Requires-Dist: importlib-resources ; python_version < "3.9"



# Broadband fluxes (`bbf`)

A module to evaluate the broadband fluxes and magnitudes of spectrophotometric standards. 

`bbf` relies on a modified version of `sncosmo` for passbands and magsys definition.


# Installation 

## virtual environments

It is generally a good idea to work in a virtual environment. You may use either
a classical `venv`, or you may opt for a `anaconda` / Miniconda / `mamba` environment.

Since `bbf` relies on cholmod, which is part of suitesparse, we recommend using
`conda` which comes with a compiled version of suitesparse. `venv` is also a
perfectly suitable option if suitesparse is already installed on your machine,
or if you are ready to compile it yourself.


### venv

As a reminder, a `venv` is created as follows: 

``` bash
python -m venv lemaitre
```
and activated with:

``` bash
source lemaitre/bin/activate
```

This `venv` is called `lemaitre` but you may pick anyname you like.

### conda / mamba

To create a Miniconda / Conda / Mamba virtual environment (called `lemaitre` in
this example, but you may pick another name):

``` bash
conda create -n lemaitre
```

and activated with:

``` bash
conda activate lemaitre
```


## Prerequisites

A few packages are required. If you work with conda, you may install them with:

``` bash
mamba install ipython numpy matplotlib scikit-sparse  scipy jupyter pandas mkl sparse_dot_mkl h5py fastparquet pyarrow
```


### sncosmo

Until our changes are merged in sncosmo, we use a modified version of it: 

``` bash
git clone https://github.com/nregnault/sncosmo.git
cd sncosmo
pip install . 
```

### latest Lemaitre bandpasses

If you plan to use the latest version of the megacam6, ztf and hsc passbands,
use the `lemaitre.bandpasses` package:

``` bash
git clone https://gitlab.in2p3.fr/lemaitre/lemaitre/bandpasses
# or alternatively
git clone git@gitlab.in2p3.fr:lemaitre/bbf.git
```

The `lemaitre.bandpasses` repository comes with moderately large data files,
whose history is not tracked by git. They are managed using git-lfs (large file
storage). git-lfs has been packaged for all major distributions. It is also 
available from Homebrew. 

To retrieve the data files:

``` bash
cd bandpasses/
git lfs pull
```

And to install the code:

``` bash
cd bandpasses
pip install . 
```

or `pip install -e .` to install in editable mode (if you intend to hack the code).

## Installing the `bbf` package:

``` bash
git clone https://gitlab.in2p3.fr/lemaitre/lemaitre/bbf
# or alternatively
git clone git@gitlab.in2p3.fr:lemaitre/bbf

cd bbf
 pip install . 
```

(or `pip install -e . ` to install in editable mode).

# Getting started

The goal of `bbf` is to efficiently compute broadband fluxes and magnitudes, i.e. quantities 
of the form:

$$f_{xys} = \int S(\lambda) \lambda T_{xys}(\lambda) d\lambda$$
     
where $\lambda$ is the SED of an object, $T_{xyz}(\lambda)$ is the bandpass of
the instrument used to observe it. $T$ may depend on the focal plane position of
the object and, if the focal plane is a mosaic of sensors, on the specific
sensor $s$ where the observation is made. In practice, $x,y$ are coordinates, in
pixels, in the sensor frame, and $s$ is a unique sensor index (or amplifier
index).

Computing magnitudes requires an additional ingredient: the flux of a reference
spectrum $S_{ref}(\lambda)$, usually the AB spectrum, integrated in the same
passband (same sensor, same position).

$$m = -2.5 \log_{10} \left(\frac{\int S(\lambda) \lambda T_{xyz}(\lambda) d\lambda}{\int S_{ref}(\lambda) \lambda T_{xyz}(\lambda) d\lambda}\right)$$ 

To compute these integrales, `bbf` uses the technique implemented in `nacl`,
which consists in projecting the bandpasses and SED on spline bases:

$$S(\lambda) = \sum_i \theta_i {\cal B}_i(\lambda)$$

and 

$$T(\lambda) = \sum_j t_j {\cal B}_j(\lambda)$$
    
If we precompute the products $G_{ij} = \int \lambda {\cal B}_i(\lambda)_{\cal B}_j(\lambda) d\lambda$
the integrals above can be expressed as a simple contraction:

$$f = \theta_i G_{ij} t_j$$

where $G$ is very sparse, since the B-Splines ${\cal B}_i$ have a compact
support. If the bandpass $T$ is spatially variable, the $t_j$ coefficients are
themselves developped on a spatial spline basis. 

$$t_j = \sum_{kj} \tau_{kj} {\cal K}(x,y)$$

The contraction above is then of the form:



## FilterSets and StellarLibs

`bbf` implements two main kind of objects: `FilterLib`, which holds a set of
band passes, projected on spline bases (${\cal K_j(x,y)}$ and ${\cal
B}_i_(\lambda)$), and `StellarLib` which manages a set of spectra, also
projected on a spline basis (not necessily the splines used for the filters).


## Loading a filter lib

Building a complete version of a `FilterLib` requires some care. The standard
`FilterLib` used in the LemaÃ®tre analysis is build and maintained within the 
package `lemaitre.bandpasses`. To access it: 

``` python
from lemaitre import bandpasses

flib = bandpasses.get_filterlib()
```
The first time this function is called, the `FilterLib`` is built and cached. The subsequent calls
access the cached version, and never take more than a few milliseconds. 

## Loading Stellar Libraries 

As of today, `bbf` implements two kinds of StellarLibs: pickles and Calspec. An
interface to gaiaXP is in development. 

To load the pickles library: 

``` python

import bbf.stellarlib.pickles
pickles = bbf.stellarlib.pickles.fetch()
```

To load the most recent version of Calspec:

``` python
import bbf.stellarlib.calspec
calspec = bbf.stellarlib.calspec.fetch()
```


## Computing Broadband fluxes 

With a `FilterSet` and a `StellarLib` in hand, one can compute broadband fluxes and broadband mags. 

### Broadband fluxes

``` python
import bbf.stellarlib.pickles
from lemaitre import bandpasses

flib = bandpasses.get_filterlib()
pickles = bbf.stellarlib.pickles.fetch()

# number of measurements
nmeas = 100_000

# which stars ? 
star = np.random.choice(np.arange(0, len(pickles)), size=nmeas)

# in which band ?
band = np.random.choice(['ztf::g', 'ztf::r', 'ztf::I'], size=nmeas)

# observation positions
x = np.random.uniform(0., 3072., size=nmeas)
y = np.random.uniform(0., 3080., size=nmeas)
sensor_id = np.random.choice(np.arange(1, 65), size=nmeas)

fluxes = flib.flux(pickles, star, band, x=x, y=y, sensor_id=sensor_id)
```


### Broadband magnitudes

To convert broadband fluxes into broadband magnitudes, we need to compute the reference fluxes, 
in the same effective measurement band passes. This is done using an auxiliary object called `MagSys`:  

``` python

from bbf.magsys import SpecMagSys 
import bbf.stellarlib.pickles
from lemaitre import bandpasses

flib = bandpasses.get_filterlib()
pickles = bbf.stellarlib.pickles.fetch()

# number of measurements
nmeas = 100_000

# which stars ? 
star = np.random.choice(np.arange(0, len(pickles)), size=nmeas)

# in which band ?
band = np.random.choice(['ztf::g', 'ztf::r', 'ztf::I'], size=nmeas)

# observation positions
x = np.random.uniform(0., 3072., size=nmeas)
y = np.random.uniform(0., 3080., size=nmeas)
sensor_id = np.random.choice(np.arange(1, 65), size=nmeas)

ms = SpecMagSys('AB')
mags = ms.mag(pickles, star, band, x=x, y=y, sensor_id=sensor_id)
```

