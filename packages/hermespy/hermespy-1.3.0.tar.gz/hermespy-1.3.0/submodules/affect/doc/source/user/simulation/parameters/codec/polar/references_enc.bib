@Article{Trifonov2012,
  author   = {P. Trifonov},
  title    = {Efficient Design and Decoding of Polar Codes},
  journal  = {IEEE Transactions on Communications (TCOM)},
  year     = {2012},
  volume   = {60},
  number   = {11},
  pages    = {3221--3227},
  month    = nov,
  issn     = {0090-6778},
  abstract = {Polar codes are shown to be instances of both generalized concatenated codes and multilevel codes. It is shown that the performance of a polar code can be improved by representing it as a multilevel code and applying the multistage decoding algorithm with maximum likelihood decoding of outer codes. Additional performance improvement is obtained by replacing polar outer codes with other ones with better error correction performance. In some cases this also results in complexity reduction. It is shown that Gaussian approximation for density evolution enables one to accurately predict the performance of polar codes and concatenated codes based on them.},
  doi      = {10.1109/TCOMM.2012.081512.110872},
  file     = {:pdf/Trifonov2012 - Efficient Design and Decoding of Polar Codes.pdf:PDF},
  groups   = {Polar Codes},
  keywords = {Gaussian processes, concatenated codes, design, maximum likelihood decoding, Gaussian approximation, concatenated codes, density evolution, design, maximum likelihood decoding, multilevel codes, multistage decoding algorithm, polar codes, Approximation algorithms, Concatenated codes, Constellation diagram, Error probability, Maximum likelihood decoding, Vectors, Polar codes, concatenated codes, multilevel codes},
}

@Article{Tal2013,
  author   = {I. Tal and A. Vardy},
  title    = {How to Construct Polar Codes},
  journal  = {IEEE Transactions on Information Theory (TIT)},
  year     = {2013},
  volume   = {59},
  number   = {10},
  pages    = {6562--6582},
  month    = oct,
  issn     = {0018-9448},
  abstract = {A method for efficiently constructing polar codes is presented and analyzed. Although polar codes are explicitly defined, straightforward construction is intractable since the resulting polar bit-channels have an output alphabet that grows exponentially with the code length. Thus, the core problem that needs to be solved is that of faithfully approximating a bit-channel with an intractably large alphabet by another channel having a manageable alphabet size. We devise two approximation methods which {\textquotedblleft}sandwich{\textquotedblright} the original bit-channel between a degraded and an upgraded version thereof. Both approximations can be efficiently computed and turn out to be extremely close in practice. We also provide theoretical analysis of our construction algorithms, proving that for any fixed $\epsilon$ $>$ 0 and all sufficiently large code lengths n, polar codes whose rate is within $\epsilon$ of channel capacity can be constructed in time and space that are both linear in n.},
  doi      = {10.1109/TIT.2013.2272694},
  file     = {:pdf/Tal2013 - How to Construct Polar Codes.pdf:PDF},
  groups   = {Polar Codes},
  keywords = {approximation theory, codes, alphabet size, approximation methods, channel capacity, construction algorithms, polar bit-channels, polar codes, Approximation algorithms, Approximation methods, Complexity theory, Convolutional codes, Decoding, Kernel, Quantization (signal), Channel degrading and upgrading, channel polarization, construction algorithms, polar codes},
}


@misc{3GPP2017,
  title       = {{TS} 38.212, {Multiplexing} and {Channel} {Coding} ({Release} 15)},
  author      = {{3GPP}},
  url         = {http://www.3gpp.org/ftp//Specs/archive/38_series/38.212/},
}
