# *************************************************************** #
#               Copyright Â© Hero Imaging AB 2022. 				  #
#  					  All Rights Reserved.						  #
# *************************************************************** #

from __future__ import annotations
from typing import Callable, Any, Optional
from heropytools.Serialization.Attributes import Attributes
from heropytools.Serialization.CustomSerializer import CustomSerializer

from .SettingsValueArray import SettingsValueArray


class SettingsStringArray(SettingsValueArray):

    def __init__(self, value, min_length = 0, max_length = 256 ,  min_number_of_elements = 0, max_number_of_elements = 64, read_only=False, visible=True, description="", can_be_input=False, is_input=False, full_input_name=True):

        SettingsValueArray.__init__(self, min_number_of_elements, max_number_of_elements, read_only, visible, description, can_be_input, is_input, full_input_name)
        self._min_length = min_length
        self._max_length = max_length
        self._value = value
        
    @property
    def value(self):
        return self._value
    
    @value.setter
    def value(self, value):
        raise AttributeError("Attribute is not writable.")

    @value.deleter
    def value(self):
        raise AttributeError("Attribute is not deletable.")
    
    @property
    def min_length(self):
        return self._min_length
    
    @min_length.setter
    def min_length(self, value):
        raise AttributeError("Attribute is not writable.")

    @min_length.deleter
    def min_length(self):
        raise AttributeError("Attribute is not deletable.")
    
    @property
    def max_length(self):
        return self._max_length
    
    @max_length.setter
    def max_length(self, value):
        raise AttributeError("Attribute is not writable.")

    @max_length.deleter
    def max_length(self):
        raise AttributeError("Attribute is not deletable.")

    @staticmethod
    def create_from_dict(data: dict):
        s = SettingsStringArray(data["_value"], data["_min_length"], data["_max_length"], data["_min_number_of_elements"], data["_max_number_of_elements"], data["_read_only"], data["_visible"], data["_description"], data["_can_be_input"], 
                     data["_is_input"], data["_full_input_name"])
        s._id = data["_id"]
        return s

    def __eq__(self, other: SettingsStringArray):
        return super(SettingsStringArray, self).__eq__(other) and self._compare_lists(self._value, other._value) and \
            self._min_length == other._min_length and self._max_length == other._max_length

    def __repr__(self) -> str:
        return  f'StringList: [value: {self.value}, min_value: {self.min_length}, max_value: {self.max_length}, ' + super().__repr__()

    # --- Autogenerated --- #

    # Name of the type.
    _type_str = "SettingsStringArray"

    # Datatype attributes.
    _attributes = Attributes("SettingsStringArray", version=0, member_count=12)

    # Serialization.
    def serialize(self, writer_fun: Callable[[Any, str, str, Optional[CustomSerializer]], None]):
        super(SettingsStringArray, self).serialize(writer_fun)
        writer_fun(self._min_length, "Int32", "MiL", None)
        writer_fun(self._max_length, "Int32", "ML", None)
        writer_fun(self._value, "String[]", "V", None)

    # Deserialization.
    @staticmethod
    def deserialize(reader_fun: Callable[[str, Optional[CustomSerializer]], Any]):
        data = super(SettingsStringArray, SettingsStringArray).deserialize(reader_fun)
        data["_min_length"], _ = reader_fun("Int32", None)
        data["_max_length"], _ = reader_fun("Int32", None)
        data["_value"], _ = reader_fun("String[]", None)
        return data
