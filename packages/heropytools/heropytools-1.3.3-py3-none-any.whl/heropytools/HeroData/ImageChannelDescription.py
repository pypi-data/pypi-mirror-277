# *************************************************************** #
#               Copyright Â© Hero Imaging AB 2022. 				  #
#  					  All Rights Reserved.						  #
# *************************************************************** #

from __future__ import annotations
from typing import Callable, Any, Optional
import numpy as np
from heropytools.Serialization.Attributes import Attributes
from heropytools.Serialization.CustomSerializer import CustomSerializer


class ImageChannelDescription:

    def __init__(self, Locations: np.ndarray, Name: str = "", Unit: str = ""):
        self._validate_locations(Locations)
        self._locations = Locations
        self._name = Name
        self._unit = Unit

    def __repr__(self):
        string = "ImageChannelDescription("
        string += f"locations=np.zeros({self._locations.shape}, dtype={np.float64}), "
        string += f"name=\"{self._name}\", "
        string += f"unit={self._unit}"
        string += ")"

        return string

    def __str__(self):
        string = f'ImageChannelDescription: {self.name}\n'
        string += f'  ----------------------------------\n'
        string += f'  Locations: {self._locations.shape}\n'
        string += f'  Name: {self._name}\n'
        string += f'  Unit: {self._unit}\n'
        string += f'  ----------------------------------\n'

        return string

    @property
    def Name(self):
        return self._name

    @Name.setter
    def Name(self, value):
        if not isinstance(str, value):
            raise ValueError("The name must be a string.")
        self._name = value

    @Name.deleter
    def Name(self):
        raise AttributeError("Attribute 'Name' is not deletable.")

    @property
    def Unit(self):
        return self._unit

    @Unit.setter
    def Unit(self, value):
        if not isinstance(str, value):
            raise ValueError("The 'Unit' must be a string.")
        self._unit = value

    @Unit.deleter
    def Unit(self):
        raise AttributeError("Attribute 'Unit' is not deletable.")

    @property
    def Locations(self):
        return self._locations

    @Locations.setter
    def Locations(self, value):
        if not isinstance(np.array, value):
            raise ValueError("The 'Locations' must be a numpy array.")
        if value.ndim != 1:
            raise ValueError("The 'Locations' must be a 1D array.")
        if value.dtype != np.float64:
            value = value.astype(np.float64)
        self._locations = value

    @Locations.deleter
    def Locations(self):
        raise AttributeError("Attribute 'Locations' is not deletable.")
        
    @staticmethod
    def _validate_locations(locations):
        if not isinstance(locations, np.ndarray):
            raise Exception("The ImageChannelDescription locations must be a 1D numpy array of float64 values.")
        if locations.dtype != np.float64 or locations.ndim != 1:
            raise Exception("The ImageChannelDescription locations must be a 1D numpy array of float64 values.")

    @staticmethod
    def create_from_dict(data: dict):
        s = ImageChannelDescription(data["_locations"], data["_name"], data["_unit"])
        return s

    def __eq__(self, other: ImageChannelDescription):
        if self._unit != other._unit:
            return False
        if self._name != other._name:
            return False
        if self._locations.size != other._locations.size:
            return False
        if not (self._locations == other._locations).all():
            return False
        return True

    def get_container_id(self):
        pass

    # --- Autogenerated --- #

    # Name of the type.
    _type_str = "ImageChannelDescription"

    # Datatype attributes.
    _attributes = Attributes("ImageChannelDescription", version=0, member_count=3)

    # Serialization.
    def serialize(self, writer_fun: Callable[[Any, str, str, Optional[CustomSerializer]], None]):
        writer_fun(self._locations, "Double[]", "_locations", None)
        writer_fun(self._name, "String", "Name", None)
        writer_fun(self._unit, "String", "Unit", None)

    # Deserialization.
    @staticmethod
    def deserialize(reader_fun: Callable[[str, Optional[CustomSerializer]], Any]):
        data = dict()
        data["_locations"], _ = reader_fun("Double[]", None)
        data["_name"], _ = reader_fun("String", None)
        data["_unit"], _ = reader_fun("String", None)
        return data
