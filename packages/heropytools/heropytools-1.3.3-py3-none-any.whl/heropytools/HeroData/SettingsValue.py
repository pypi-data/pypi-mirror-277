# *************************************************************** #
#               Copyright Â© Hero Imaging AB 2022. 				  #
#  					  All Rights Reserved.						  #
# *************************************************************** #

from __future__ import annotations
from typing import Callable, Any, Optional
from heropytools.Serialization.Attributes import Attributes
from heropytools.Serialization.CustomSerializer import CustomSerializer

from .SettingsItem import SettingsItem


class SettingsValue(SettingsItem):

    def __init__(self, read_only, visible, description, can_be_input, is_input, full_input_name):

        SettingsItem.__init__(self, visible, description)
        self._read_only = read_only
        self._can_be_input = can_be_input
        self._is_input = is_input
        self._full_input_name = full_input_name

    @property
    def read_only(self):
        return self._read_only
    
    @read_only.setter
    def read_only(self, value):
        raise AttributeError("Attribute is not writable.")

    @read_only.deleter
    def read_only(self):
        raise AttributeError("Attribute is not deletable.")

    @property
    def can_be_input(self):
        return self._can_be_input
    
    @can_be_input.setter
    def can_be_input(self, value):
        raise AttributeError("Attribute is not writable.")

    @can_be_input.deleter
    def can_be_input(self):
        raise AttributeError("Attribute is not deletable.")

    @property
    def is_input(self):
        return self._is_input
    
    @is_input.setter
    def is_input(self, value):
        raise AttributeError("Attribute is not writable.")

    @is_input.deleter
    def is_input(self):
        raise AttributeError("Attribute is not deletable.")

    @property
    def full_input_name(self):
        return self._full_input_name
    
    @full_input_name.setter
    def full_input_name(self, value):
        raise AttributeError("Attribute is not writable.")

    @full_input_name.deleter
    def full_input_name(self):
        raise AttributeError("Attribute is not deletable.")

    def __eq__(self, other):
        if not super(SettingsValue, self).__eq__(other): 
            return False

        return self._read_only == other._read_only and self._can_be_input == other._can_be_input and self._is_input == other._is_input and self._full_input_name == other._full_input_name

        
    def __repr__(self) -> str:
        string = f"read_only: {self.read_only}, can_be_input: {self.can_be_input}, is_input: {self.is_input}, full_input_name: {self.full_input_name}, "
        return string + super().__repr__()
    
    # --- Autogenerated --- #

    # Name of the type.
    _type_str = "SettingsValue"

    # Datatype attributes.
    _attributes = Attributes("SettingsValue", version=0, member_count=7)

    # Serialization.
    def serialize(self, writer_fun: Callable[[Any, str, str, Optional[CustomSerializer]], None]):
        super(SettingsValue, self).serialize(writer_fun)
        writer_fun(self._can_be_input, "Boolean", "CBI", None)
        writer_fun(self._full_input_name, "Boolean", "FIN", None)
        writer_fun(self._is_input, "Boolean", "IsI", None)
        writer_fun(self._read_only, "Boolean", "RO", None)

    # Deserialization.
    @staticmethod
    def deserialize(reader_fun: Callable[[str, Optional[CustomSerializer]], Any]):
        data = super(SettingsValue, SettingsValue).deserialize(reader_fun)
        data["_can_be_input"], _ = reader_fun("Boolean", None)
        data["_full_input_name"], _ = reader_fun("Boolean", None)
        data["_is_input"], _ = reader_fun("Boolean", None)
        data["_read_only"], _ = reader_fun("Boolean", None)
        return data
