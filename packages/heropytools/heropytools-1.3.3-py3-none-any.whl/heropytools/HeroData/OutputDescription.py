# *************************************************************** #
#               Copyright Â© Hero Imaging AB 2022. 				  #
#  					  All Rights Reserved.						  #
# *************************************************************** #

from __future__ import annotations
from typing import Callable, Any, Optional
from heropytools.Serialization.Attributes import Attributes
from heropytools.Serialization.CustomSerializer import CustomSerializer
from .NodeIOType import NodeIOType
from .NodeIOUtils import NodeIOUtils
from .IODescription import IODescription

from uuid import uuid4


class OutputDescription(IODescription):

    def __init__(self, output_type: NodeIOType, soft_type: str = "", id_value: str = None):
        IODescription.__init__(self, id_value)
        self._output_type = output_type
        self._type_label = soft_type

        if id_value is None:
            self._id = str(uuid4())
        else:
            self._id = id_value
    
    @property
    def output_type(self):
        return self._output_type
    
    @output_type.setter
    def output_type(self, values):
        raise AttributeError("Attribute is not writable.")

    @output_type.deleter
    def output_type(self):
        raise AttributeError("Attribute is not deletable.")
    
    @property
    def type_label(self):
        return self._soft_type
    
    @type_label.setter
    def type_label(self, values):
        raise AttributeError("Attribute is not writable.")

    @type_label.deleter
    def type_label(self):
        raise AttributeError("Attribute is not deletable.")

    @staticmethod
    def create_from_dict(data: dict):
        output_type = NodeIOUtils.name2enum(data["_output_type_as_name"])
        o = OutputDescription(output_type, data["_type_label"], data["_id"])
        return o
    
    @property
    def _output_type_as_name(self) -> str:
        return NodeIOUtils.enum2name(self.output_type)
    
    @property
    def output_type_as_display_name(self) -> str:
        return NodeIOUtils.enum2printname(self.output_type)

    def __eq__(self, other):
        return self._output_type == other._output_type and \
               self._type_label == other._type_label and \
               self._id == other._id
               
    def __repr__(self) -> str:
        return f'{self.output_type}, type_label: \'{self.type_label}\''
                   
    # --- Autogenerated --- #

    # Name of the type.
    _type_str = "OutputDescription"

    # Datatype attributes.
    _attributes = Attributes("OutputDescription", version=0, member_count=3)

    # Serialization.
    def serialize(self, writer_fun: Callable[[Any, str, str, Optional[CustomSerializer]], None]):
        super(OutputDescription, self).serialize(writer_fun)
        writer_fun(self._output_type_as_name, "String", "OT", None)
        writer_fun(self._type_label, "String", "ST", None)

    # Deserialization.
    @staticmethod
    def deserialize(reader_fun: Callable[[str, Optional[CustomSerializer]], Any]):
        data = super(OutputDescription, OutputDescription).deserialize(reader_fun)
        data["_output_type_as_name"], _ = reader_fun("String", None)
        data["_type_label"], _ = reader_fun("String", None)
        return data
