# *************************************************************** #
#               Copyright Â© Hero Imaging AB 2022. 				  #
#  					  All Rights Reserved.						  #
# *************************************************************** #

from __future__ import annotations
from typing import Callable, Any, Optional
from heropytools.Serialization.Attributes import Attributes
from heropytools.Serialization.CustomSerializer import CustomSerializer

from .SettingsValue import SettingsValue


class SettingsFileString(SettingsValue):

    def __init__(self, value="", filters=None, save_file=True, read_only=False, visible=True, description="", can_be_input=False, is_input=False, full_input_name=True):

        SettingsValue.__init__(self, read_only, visible, description, can_be_input, is_input, full_input_name)
        self._value = value
        self._filters = filters
        self._save_file = save_file
        
    @property
    def value(self):
        return self._value
    
    @value.setter
    def value(self, value):
        raise AttributeError("Attribute is not writable.")

    @value.deleter
    def value(self):
        raise AttributeError("Attribute is not deletable.")
    
    @property
    def filters(self):
        return self._filters
    
    @filters.setter
    def filters(self, value):
        raise AttributeError("Attribute is not writable.")

    @filters.deleter
    def filters(self):
        raise AttributeError("Attribute is not deletable.")
    
    @property
    def save_file(self):
        return self._save_file
    
    @save_file.setter
    def save_file(self, value):
        raise AttributeError("Attribute is not writable.")

    @save_file.deleter
    def save_file(self):
        raise AttributeError("Attribute is not deletable.")
    
    def __repr__(self) -> str:
        return f'FileString: [value: \'{self.value}\', filter: {self.filters}, save_file: {self.save_file}, ' + super().__repr__()

    @staticmethod
    def create_from_dict(data: dict):
        s = SettingsFileString(data["_value"], data["_filters"], data["_save_file"], data["_read_only"], data["_visible"], data["_description"], data["_can_be_input"], data["_is_input"], data["_full_input_name"])
        s.ID = data["_id"]
        return s

    def __eq__(self, other):
        return super(SettingsFileString, self).__eq__(other) and self._value == other._value and self._validateArray(self._filters, other._filters) and self._save_file == other._save_file

    @staticmethod
    def _validateArray(array_1, array_2):
        if len(array_1) != len(array_2):
            return False

        for e1, e2 in zip(array_1, array2):
            if e1 != e2:
                return False

        return True

    # --- Autogenerated --- #

    # Name of the type.
    _type_str = "SettingsFileString"

    # Datatype attributes.
    _attributes = Attributes("SettingsFileString", version=0, member_count=10)

    # Serialization.
    def serialize(self, writer_fun: Callable[[Any, str, str, Optional[CustomSerializer]], None]):
        super(SettingsFileString, self).serialize(writer_fun)
        writer_fun(self._filters, "String[]", "F", None)
        writer_fun(self._save_file, "Boolean", "S", None)
        writer_fun(self._value, "String", "V", None)

    # Deserialization.
    @staticmethod
    def deserialize(reader_fun: Callable[[str, Optional[CustomSerializer]], Any]):
        data = super(SettingsFileString, SettingsFileString).deserialize(reader_fun)
        data["_filters"], _ = reader_fun("String[]", None)
        data["_save_file"], _ = reader_fun("Boolean", None)
        data["_value"], _ = reader_fun("String", None)
        return data
