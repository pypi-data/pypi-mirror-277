"use strict";(self.webpackChunkjpfiddle_extension=self.webpackChunkjpfiddle_extension||[]).push([[509],{509:(e,t,n)=>{n.r(t),n.d(t,{default:()=>l});const o={id:"jpfiddle_extension:plugin",description:"A JupyterLab extension for jpfiddle.",autoStart:!0,activate:e=>{console.log("ACTIVATING: JupyterLab extension jpfiddle_extension is activating."),function(e){if(!window.parent)return void console.error("No parent window found for jpfiddle-extension");let t;e.serviceManager.contents.fileChanged.connect((async(n,o)=>{if(console.info("File changed:",o),void 0!==t)if("save"===o.type&&o.newValue){if("directory"===o.newValue.type)return;const n=o.newValue.path;if(!n)return void console.warn("No file path found in fileChanged event");if(""!==t&&!n.startsWith(t+"/"))return void console.warn("File path does not start with fiddleId:",n,t);const i=""!==t?n.slice(t.length+1):n;console.log("File saved:",i,o);let a=o.newValue.content;null===a&&(a=(await e.serviceManager.contents.get(n)).content),window.parent.postMessage({type:"file-saved",path:i,content:a},"*")}else if("delete"===o.type&&o.oldValue){const e=o.oldValue.path;if(!e)return void console.warn("No file path found in fileChanged event");if(""!==t&&!e.startsWith(t+"/"))return void console.warn("File path does not start with fiddleId:",e,t);const n=""!==t?e.slice(t.length+1):e;console.log("File deleted:",n,o),window.parent.postMessage({type:"file-deleted",path:n},"*")}else if("rename"===o.type&&o.oldValue&&o.newValue){const e=o.oldValue.path,n=o.newValue.path;if(!e||!n)return void console.warn("No file path found in fileChanged event");if(""!==t&&!e.startsWith(t+"/"))return void console.warn("File path does not start with fiddleId:",e,t);if(""!==t&&!n.startsWith(t+"/"))return void console.warn("File path does not start with fiddleId:",n,t);const i=""!==t?e.slice(t.length+1):e,a=""!==t?n.slice(t.length+1):n;console.log("File renamed:",i,a,o),window.parent.postMessage({type:"file-renamed",oldPath:i,newPath:a},"*")}else if("new"===o.type&&o.newValue){const e=o.newValue.path;if(!e)return void console.warn("No file path found in fileChanged event");if(""!==t&&!e.startsWith(t+"/"))return void console.warn("File path does not start with fiddleId:",e,t);const n=""!==t?e.slice(t.length+1):e;window.parent.postMessage({type:"file-created",path:n},"*")}else console.warn(`Unknown change type: ${o.type}`);else console.error("No fiddleId found in fileChanged event")}));const n=async()=>{if(void 0!==t){for(let t=0;t<100&&(await new Promise((e=>setTimeout(e,100))),!e.commands.hasCommand("filebrowser:go-to-path"));t++);e.commands.hasCommand("filebrowser:go-to-path")?await e.commands.execute("filebrowser:go-to-path",{path:t}):console.error("Command filebrowser:go-to-path not found")}else console.error("No fiddleId found in changeToFiddleDirectory")},o=async()=>{if(void 0===t)return void console.error("No fiddleId found in get-files event");if(""!==t)try{await e.serviceManager.contents.get(t)}catch(e){return void window.parent.postMessage({type:"files",files:null},"*")}else if(0===(await e.serviceManager.contents.get("")).content.length)return void window.parent.postMessage({type:"files",files:null},"*");console.log("Getting files in directory:",t);const n=async t=>{const o=[],a=await e.serviceManager.contents.get(t);if(a)for(const t of a.content)if("directory"===t.type)o.push(...await n(t.path));else{if(!i(t.path)){console.log("Ignoring non-text file:",t.path);continue}let n=t.content;if(null===n){const o=await e.serviceManager.contents.get(t.path);if(n=o.content,null===n){console.error("Could not get content for file:",t.path,t,o);continue}}o.push({path:t.path,content:n})}return o},o=await n(t);console.log("Sending files:",o);const a=o.map((e=>({path:""!==t?e.path.slice((t||"").length+1):e.path,content:e.content})));window.parent.postMessage({type:"files",files:a},"*")};window.addEventListener("message",(async i=>{const l=i.data;if(console.log("Message received in the iframe:",l),"set-fiddle-id"===l.type){if(t=l.fiddleId,void 0===t)return;n()}else if("set-files"===l.type){if(void 0===t)return void console.error("No fiddleId found in set-files event");if(""!==t)try{await e.serviceManager.contents.get(t)}catch(n){console.log("Creating directory:",t),await e.serviceManager.contents.save(t,{type:"directory",name:a(t)})}const l=i.data.files;for(const n of l){const o=""!==t?t+"/"+n.path:n.path;if(o.split("/").length>1&&await s(e,o.split("/").slice(0,-1).join("/")),null!==n.content)console.log("saving file",o),await e.serviceManager.contents.save(o,{type:"file",format:"text",name:a(o),content:n.content});else try{console.log("deleting file",o),await e.serviceManager.contents.delete(o)}catch(e){console.error("Could not delete file",o)}}n(),(async()=>{for(let t=0;t<100&&(await new Promise((e=>setTimeout(e,100))),!e.commands.hasCommand("application:close-all"));t++);e.commands.hasCommand("application:close-all")?await e.commands.execute("application:close-all"):console.error("Command application:close-all not found")})(),o()}else"get-files"===l.type&&o()})),window.parent.postMessage({type:"jpfiddle-extension-ready"},"*")}(e),console.log("ACTIVATED: JupyterLab extension jpfiddle_extension is activated.")}},i=e=>[".ipynb",".py",".md",".txt",".stan",".j2",".template",".csv",".json",".html",".js",".css",".ts",".tsx",".r",".rmd",".xml",".yaml",".yml",".toml",".ini",".cfg",".conf",".properties",".env",".sh",".bat",".cmd","Makefile","Dockerfile",".gitignore",".dockerignore",".gitattributes",".gitmodules",".gitconfig",".gitkeep"].some((t=>e.endsWith(t))),a=e=>e.split("/").pop()||"";async function s(e,t){const n=t.split("/");let o="";for(const t of n){o=o?o+"/"+t:t;try{await e.serviceManager.contents.get(o)}catch(t){console.log("Creating directory:",o),await e.serviceManager.contents.save(o,{type:"directory",name:a(o)})}}}const l=o}}]);