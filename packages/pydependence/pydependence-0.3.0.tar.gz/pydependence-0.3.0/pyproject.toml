# =========================================== #
# BUILD SYSTEM                                #
# =========================================== #

[build-system]
requires = ["setuptools>=61", "setuptools_scm[toml]>=6.2"]
build-backend = "setuptools.build_meta"

# =========================================== #
# TOOLS                                       #
# =========================================== #

# packing tools
[tool.setuptools]
packages = ["pydependence"]

# obtain the version from git
# https://github.com/pypa/setuptools_scm
[tool.setuptools_scm]
local_scheme = "node-and-timestamp"

# automated tests
[tool.pytest]
minversion = "6.0"
testpaths = ["tests", "pydependence"]
python_files = ["test.py", "test_*.py", "__test__*.py"]

# - - - - - - - - - - - - - - - - - - - - - - #
# BOOTSTRAPPED PYDEPENDANCE EXAMPLE           #
# - - - - - - - - - - - - - - - - - - - - - - #

# general settings / overrides
[tool.pydependence]

# defaults [don't need to specifiy in practice, unless you want different default behavior]:
# - if a relative path, then relative to the *parent* of this file
# - the resolved root is prepended to all relative paths in the rest of this config.
#   e.g. for the `pydependence` repo, with files `pydependence/pyproject.toml` and `pydependence/pydependence`, then
#        * ".." would mean relative files need to be references from the parent of the repo root e.g. "pydependence/pydependence/__main__.py",
#          this is useful when resolving across multiple repos.
#        * "." would mean relative files need to be reference from the repo root e.g. "pydependence/__main__.py",
#          this is more useful when resolving across a single repo (default).
default_root = "."

# defaults [don't need to specifiy in practice]:
# - these settings can be overridden on individual output resolvers.
# * visit_lazy:
#   | If true, then vist all the lazy imports. Usually the lazy imports are removed from
#   | the import graph and we don't traverse these edges. This on the other-hand allows
#   | all these edges to be traversed. This is often useful if you want to create
#   | packages that only require some minimal set of requirements, and everything else
#   | that you define should be optional. Also useful if you want to generate a minimal
#   | dependencies list, and then in optional dependency lists you want to create a full
#   | set of requirements for everything!
# * re_add_lazy: [A.K.A. shallow_include_lazy]
#   | only applicable when `visit_lazy=False`, then in this case we re-add the lazy
#   | imports that are directly referenced in all the traversed files, i.e. it is a
#   | shallow include of lazy imports without continuing to traverse them. This means
#   | that we add the lazy imports but we don't continue traversing. This is often not
#   | useful with complex lazy import graphs that continue to reference more module
#   | within the same scope as this could cause missing imports, rather specify
#   | `visit_lazy=True` in this case.
# * exclude_unvisited:
#   | If true, then exclude imports that were not encountered as we traversed the import
#   | graph. [NOTE]: this is probably useful if you don't want to include all imports
#   | below a specific scope, but only want to resolve what is actually encountered.
#   | Not entirely sure this has much of an effect?
# * exclude_in_search_space:
#   | If true, then exclude all imports that are part of the current scope. This usually
#   | should not have any effect because imports are replaced as we traverse the graph
#   | through the current scope, [NOTE] thus not entirely sure that this has any effect,
#   | should it be a bug if we encounter any of these?
# * exclude_builtins:
#   | If true, then exclude all the python builtin package names from being output in
#   | the requirements files. This usually should be true unless you are trying to debug
#   | as this would generate invalid requirements list as these would not exist on pypi.
# * strict_requirements_map:
#   | Check that generated imports and requirements have entries in the versions list.
#   | If strict mode is enabled, then an error is thrown if a version entry is missing.
#   | If strict mode is disabled, then a warning should be given, and the root import
#   | name is used instead of the requirement name, which may or may not match up
#   | to an actual python package.
default_resolve_rules = {visit_lazy=false, re_add_lazy=false, exclude_unvisited=true, exclude_in_search_space=true, exclude_builtins=true, strict_requirements_map=true}

# defaults [don't need to specifiy in practice, unless you want different default behavior]:
# - these settings can be overridden on individual scopes.
# * unreachable_mode
#   | Specify how to handle modules that are unreachable, e.g. if there is no `__init__.py`
#   | file in all the parents leading up to importing this module. If this is the case
#   | then the module/package does not correctly follow python/PEP convention and is
#   | technically invalid. By default, for `error`, we raise an exception and do not allow
#   | the scope to be created, but this can be relaxed to `skip` or `keep` these files.
default_scope_rules = {unreachable_mode="error"}

# map requirements and resolved imports to specific packages and version requirements.
# - to generate dependency lists for conflicting package versions you can specify
#   requirements more than once as long as you add a unique `env` entry. In the
#   corresponding resolver, you can then reference this `env` entry to switch out the
#   version you are after. If no `env` is set, then by default the env="default".
versions = [
    "networkx",
    "pydantic>=2.0.0",
    {requirement="pydantic<2.0.0,>=1.0.0", env='legacy'},
    "stdlib_list",
    "tomlkit",
    "packaging",
    {requirement="pydependence", scope="pydependence"},
    "pytest>=6",
    "pytest-cov>=4"
]

# Output resolvers define the resolution and generation of output requirements by
#   1. traversing a scope's directed module and import graph
#   2. collecting all imports and mapping these using the version list above to specific pypi requirements.
# Note that the starting point can be set to some subset of the scope
#   e.g. if you script that you want to generate requirements for uses the `main.py` file,
#        then you can generate requirements for this script specifically by setting it as
#        the starting point, instead of generating requirements for the entire scope. Then
#        only imports that this script uses and traverses to will actually be included in
#        the output.
# Note that by default lazy imports are not traversed or included.
#   * Lazy imports are imports that are contained inside functions, methods or TYPE_CHECKING blocks.
#     This means that some coding convention has to be followed when pydependence is used within
#     projects to generate minimal requirements as it is expected that these imports should not be
#     called at import time, instead possibly only at runtime if specific features of the library or
#     framework are requested.
# Note that by default we use a strict requirements mapping mode
#   * if resolved imports and requirements do not have a corresponding `versions` entry, then an error will
#     be thrown in this case. This is to ensure that devs know exactly what versions are being used within their
#     program.
resolvers = [
    {                                    output_mode='dependencies',          scope='pydependence'},
    {output_name='some',                 output_mode='optional-dependencies', scope='pydependence', visit_lazy=false},
    {output_name='all',                  output_mode='optional-dependencies', scope='pydependence', visit_lazy=true},
    {output_name='core',                 output_mode='optional-dependencies', scope='pydependence', start_scope='pydependence-core', visit_lazy=true},
    {output_name='example-core-no-lazy', output_mode='optional-dependencies', scope='pydependence'},
    {output_name='example-legacy',       output_mode='optional-dependencies', scope='pydependence', env='legacy', visit_lazy=true},
    {output_name='test',                 output_mode='optional-dependencies', scope="pydependence-tests", raw=["pytest-cov"], visit_lazy=true},
    {output_name='dev',                  output_mode='optional-dependencies', raw=['pre-commit'], strict_requirements_map=false},
]

# Scopes represent graphs of modules (nodes) and their interconnecting
# import statements (directed edges) that reference themselves or other modules.
# - scopes are traversed by the resolvers in different ways to generate lists of requirements.
# - scopes can be constructed from various different sources.
#   * `pkg_paths` / `search_paths`
# - scopes can inherit from eachother with `parents`
# - scopes can be filtered down with `limit`
# - scopes cannot have conflicting module names, each module name should have a one to one mapping to a specific file.
scopes = [
    {name = "pydependence", pkg_paths = "./pydependence"},
    {name = "pydependence-core", parents = ["pydependence"], limit = "pydependence._core"},
    {name = "pydependence-tests", parents = ["pydependence"], pkg_paths = "./tests"}
]

# =========================================== #
# PROJECT                                     #
# =========================================== #

[project]
name = "pydependence"
dynamic = ["version"]
description = "Python local package dependency discovery, resolution and requirements generation."
urls = {repository = "https://github.com/nmichlo/pydependence"}
authors = [{name = "Nathan Michlo", email = "nathanjmichlo@gmail.com"}]
readme = "README.md"
license = {file="LICENSE"}
classifiers = [
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]

# - - - - - - - - - - - - - - - - - - - - - - #
# [AUTOGEN] PROJECT: DEPS           [AUTOGEN] #
# !!! do not modify this section manually !!! #
# !!! do not modify this section manually !!! #
# !!! do not modify this section manually !!! #
# - - - - - - - - - - - - - - - - - - - - - - #

requires-python = ">=3.8"
dependencies = [
    # [AUTOGEN] by pydependence resolver 'pydependence' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic>=2.0.0",
    #     ← pydependence._cli
    "stdlib_list",
    #     ← pydependence._core.builtin
]

# - - - - - - - - - - - - - - - - - - - - - - #
# [AUTOGEN] PROJECT: OPTIONAL DEPS  [AUTOGEN] #
# !!! do not modify this section manually !!! #
# !!! do not modify this section manually !!! #
# !!! do not modify this section manually !!! #
# - - - - - - - - - - - - - - - - - - - - - - #

[project.optional-dependencies]

dev = [
    # [AUTOGEN] by pydependence resolver 'dev' **DO NOT EDIT** [AUTOGEN]
    "pre_commit", # [M]
    #     ← <manual: pre_commit>
]
test = [
    # [AUTOGEN] by pydependence resolver 'test' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic>=2.0.0",
    #     ← pydependence._cli
    "pytest-cov>=4", # [M]
    #     ← <manual: pytest_cov>
    "pytest>=6",
    #     ← tests.test_module_data
    #     ← tests.test_utils
    "stdlib_list",
    #     ← pydependence._core.builtin
    "tomlkit", # [L]
    #     ← [L] pydependence._core.requirements_out
    #     ← [L] pydependence._core.utils
    #     ← [L] tests.test_module_data
]
some = [
    # [AUTOGEN] by pydependence resolver 'some' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic>=2.0.0",
    #     ← pydependence._cli
    "stdlib_list",
    #     ← pydependence._core.builtin
]
all = [
    # [AUTOGEN] by pydependence resolver 'all' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic>=2.0.0",
    #     ← pydependence._cli
    "stdlib_list",
    #     ← pydependence._core.builtin
    "tomlkit", # [L]
    #     ← [L] pydependence._core.requirements_out
    #     ← [L] pydependence._core.utils
]
core = [
    # [AUTOGEN] by pydependence resolver 'core' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "stdlib_list",
    #     ← pydependence._core.builtin
    "tomlkit", # [L]
    #     ← [L] pydependence._core.requirements_out
    #     ← [L] pydependence._core.utils
]
example-core-no-lazy = [
    # [AUTOGEN] by pydependence resolver 'example-core-no-lazy' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic>=2.0.0",
    #     ← pydependence._cli
    "stdlib_list",
    #     ← pydependence._core.builtin
]
example-legacy = [
    # [AUTOGEN] by pydependence resolver 'example-legacy' **DO NOT EDIT** [AUTOGEN]
    "networkx",
    #     ← pydependence._core.modules_resolver
    #     ← pydependence._core.modules_scope
    "packaging",
    #     ← pydependence._cli
    "pydantic<2.0.0,>=1.0.0",
    #     ← pydependence._cli
    "stdlib_list",
    #     ← pydependence._core.builtin
    "tomlkit", # [L]
    #     ← [L] pydependence._core.requirements_out
    #     ← [L] pydependence._core.utils
]
