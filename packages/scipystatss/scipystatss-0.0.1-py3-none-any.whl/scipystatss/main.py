def stats():
   return """
#ПЕРВЫЙ НОМЕР(7) Имеется две корзины с белыми и черными шарами. В первой корзине количество белых – 9, количество черных – 13. Во второй корзине количество белых – 19, количество черных – 20. Из первой корзины случайно, без возвращения, излекаются 7 шаров, а из второй – 8 шаров. Отобранные из обеих корзин шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?

w1 = 9
b1 = 13
w2 = 19
b2 = 20

count1 = 7
count2 = 8

p_white1 = w1 / (w1 + b1)
p_black1 = b1 / (w1 + b1)
p_white2 = w2 / (w2 + b2)
p_black2 = b2 / (w2 + b2)

ans = (count1 * p_white1 + count2 * p_white2) / (count1 + count2)
print(ans)

ans2 = (count1 * p_white1) / (count1 * p_white1 + count2 * p_white2)
print(ans2)

#ПЕРВЫЙ НОМЕР(5) В первой корзине имеется 11 шаров, при этом количество белых шаров равно либо 3, либо 10. Оба варианта равновероятны. Во второй корзине имеется 25 шаров, а количество белых шаров равно 2, 23 или 25. Эти три варианта также равновероятны. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?

## y = [ 5 , 26 , 28 , 12 , 33 , 35 ]
y=[i+j for i in [3,10] for j in [2,23,25]]
py=[1/6,1/6,1/6,1/6,1/6,1/6]

Omega=11+25
P_A=0

## P _A = (E(5)*1/6 + E(26)*1/6+ ... + E(35) *1/6) / Omega
for i in range(len(y)):
    P_A+=y[i]*py[i] / Omega

print(rrstr(P_A,3))

P_H_A = (3/2/Omega+10/2/Omega)/P_A
## (3 * 1/2 + 10 *1/2)/Omega / P_A
print(P_H_A)

#ВТОРОЙ НОМЕР (10) Монеты в количестве 11 штук подбрасываются до тех пор, пока 14 раз не выпадет 5 гербов. Пусть X – число бросков до первого появления 5 гербов, а Y – число бросков до последнего появления 5 гербов (Y = общее число бросков). Найдите: 1) математическое ожидание X; 2) стандартное отклонение X; 3) коэффициент корреляции между X и Y; 4) математическое ожидание XY.
import math

n = 11
count_g = 14
gerb = 5

P = math.comb(n, gerb) / 2**n

E_X = 1/P
print(E_X)

var_x = (1-P)/P**2
std_x = var_x**0.5
print(std_x)

po = var_x / (std_x * std_x * count_g**0.5)
print(po)

E_XY = var_x + count_g*E_X**2
print(E_XY)

#ТРЕТИЙ НОМЕР (15) В области, ограниченной эллипсом (u/13)**2+(v/6)**2=1, случайным образом выбираются две точки. Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 7,9; B – все координаты обеих точек больше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.
import numpy as np
from scipy.stats import *
N = 100000


a = #13
b = #6

r=#1

R1= uniform(0,1)
Phi1=uniform(0,2)
R2=uniform(0,1)
Phi2=uniform(0,2)
lengt1=np.sqrt(R1.rvs(size=N))
angle1=np.pi*Phi1.rvs(size=N)
lengt2=np.sqrt(R2.rvs(size=N))
angle2=np.pi*Phi2.rvs(size=N)


x1=a*lengt1*np.cos(angle1)
x2=a*lengt2*np.cos(angle2)

y1=b*lengt1*np.sin(angle1)
y2=b*lengt2*np.sin(angle2)


count = 0
count_A = 0
count_B = 0
count_A_and_B  = 0
for i in range(0, N):

    distance = ((x1[i] - x2[i])**2 + (y1[i] - y2[i])**2)**0.5
    if distance < #7.9:
        count_A += 1

    if x1[i] > 0 and y1[i] > 0 and x2[i] > 0 and y2[i] > 0 :
        count_B += 1
        if distance < #7.9:
            count_A_and_B += 1

P_A= count_A / N
P_A_B = count_A_and_B / count_B


print(P_A)
print(P_A_B)


#ТРЕТИЙ НОМЕР(16)В области, ограниченной эллипсом (u/23)**2+(v/6)**2=1, случайным образом выбираются две точки. Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 9,2; B – координаты первой точки больше 0, а координаты второй точки меньше 0. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите внутри заданного эллипса 100000 пар точек и, используя все эти пары точек, найдите ответы, округляя их до одного знака после запятой.
import numpy as np
from scipy.stats import *
N = 100000


a = 23
b = 6
r=1

R1= uniform(0,1)
Phi1=uniform(0,2)

R2=uniform(0,1)
Phi2=uniform(0,2)

lengt1=np.sqrt(R1.rvs(size=N))
angle1=np.pi*Phi1.rvs(size=N)
lengt2=np.sqrt(R2.rvs(size=N))
angle2=np.pi*Phi2.rvs(size=N)

x1=a*lengt1*np.cos(angle1)
x2=a*lengt2*np.cos(angle2)

y1=b*lengt1*np.sin(angle1)
y2=b*lengt2*np.sin(angle2)


count = 0
count_A = 0
count_B = 0
count_A_and_B  = 0
for i in range(0, N):

    distance = ((x1[i] - x2[i])**2 + (y1[i] - y2[i])**2)**0.5
    if distance < 9.2:
        count_A += 1

    if (x1[i] > 0 and y1[i] > 0 and x2[i] < 0 and y2[i] < 0) or (x1[i] < 0 and y1[i] < 0 and x2[i] > 0 and y2[i] > 0):
        count_B += 1
        if distance < 9.2:
            count_A_and_B += 1

P_A= count_A / N
P_A_B = count_A_and_B / count_B


print(P_A)
print(P_A_B)

#ЧЕТВЕРТЫЙ НОМЕР (18) Абсолютная непрерывная случайная величина
from scipy.stats import *
from scipy import *
a = 4
b = 9
q = 0.9
def f(x):
    if a <= x <= b :
        return (1+ 7*x**0.5 + 8*x**0.7 + 4*x**0.9)**1.3
    else:
        return 0
C = 1 / integrate. quad (f,a, b) [0]
print(C)

class distrv(rv_continuous):
    def _pdf (self, x):
        return C * f(x)
X = distrv(a=a, b=b)

E = X.expect()
print(rrstr(E,3))
def g2(x):
    return C*f(x) *(x-E)**2
print((integrate.quad(g2,a, b)[0])**0.5)
print(X.ppf(q))

(20)ПЯТЫЙ НОМЕР Для нормального случайного вектора (X,Y)∼N(−8;16;49;1;0,8) найдите вероятность P((X−3)(Y−7)<0).

import numpy as np
E_x = -8
E_y = 16
var_x = 49
std_x = 7
var_y = 1
std_y = 1
po = 0.8
x0 = 3
y0 = 7

mu= np.array([E_x, E_y])

Cov = np.array([[ var_x, po*std_x*std_y], [po*std_x*std_y, var_y]])

W=multivariate_normal(mu, Cov)

X=norm(E_x,std_x)
Y=norm(E_y,std_y)
P= X.cdf(x0)+Y.cdf(y0)-2*W.cdf([x0,y0])
print(P)

#(21) ШЕСТОЙ НОМЕР Для нормального случайного вектора (X,Y)∼N(−4;4;64;81;−0,31) найдите вероятность P((X−8)(X−10)(Y−1)<0).
E_x = -4
E_y = 4
var_x = 64
std_x = 8
var_y = 81
std_y = 9
po = -0.31
'''x0<x1'''
x0 = 8
x1 = 10
y0 = 1
mu= np.array([E_x, E_y])
Cov = np.array([[ var_x, po*std_x*std_y], [po*std_x*std_y, var_y]])

W=multivariate_normal(mu, Cov)
X=norm(E_x,std_x)
Y=norm(E_y,std_y)
P = X.cdf(x1) - X.cdf(x0) + 2*W.cdf([x0,y0]) - 2*W.cdf([x1,y0]) + Y.cdf(y0)
print(P)


#1 Инвестор сформировал портфель из акций компаний А и В, затратив на приобретение акций А в 9 раз больше средств чем на покупку акций В. Ожидаемая доходность за период владения акциями А и В составляет 4% и 3%, при этом стандартное отклонение доходности равно 6% и 6%, соответственно. 1) Найдите (в %) стандартное отклонение доходности портфеля инвестора, если известно, что коэффициент корреляции доходностей акций А и В равен 0,4.
(((9/10)**2*(0.06)**2+(1/10)**2*(0.06)**2+2*(0.4)*(9/10*1/10)*(0.06)*(0.06))**0.5*100)
## var  = a**2 * var(a) + b**2 *var(b) + 2 * po * a * b * std(a)*std (b)
## std = var **0.5
## std * 100

#2 Ожидаемая доходность и стандартное отклонение доходности за период для акций компаний А, В, С составляют 2%, 3%, 3% и 3%, 5%, 5%, соответственно. 1) Предполагая независимость доходностей акций А, В и С, найдите (в %) ожидаемую доходность портфеля, составленного из этих акций так, чтобы дисперсия его доходности была минимальной.
from sympy import *
x, y = symbols('x y')
## std
a=0.03
b=0.05
c=0.05

f = a**2*x**2+y**2*b**2+(1-x-y)**2*c**2
## a - стандартное отклонение a
## b - стандартное отклонение b
## c - стандартное отклонение c
## x - доля a
## y - доля b
## (1-x-y) - доля с

df_dx = diff(f, x)
df_dy = diff(f, y)

solution = solve((df_dx, df_dy), (x, y))
((solution[x]*0.02+solution[y]*0.03+(1-solution[x]-solution[y])*0.03)*100)
## a * E(a) + b * E(b) + (1-a-b) * E(c)

#3 Математическое ожидание доходности акций компаний А и В составляет 4% и 5%, при этом стандартное отклонение доходности равно 5% и 8%, соответственно. Также известен коэффициент корреляции ρAB доходностей акций А и В, ρAB=0,30. Найдите (короткие позиции допускаются): 1) доли акций А и В в портфеле с минимальной дисперсией доходности; 2) ожидаемую доходность и стандартное отклонение доходности такого портфеля.
from sympy import *
x = symbols('x')
# std
a=0.05
b=0.08

f = a**2*x**2+(1-x)**2*b**2 + 2*a*b*x*(1-x)*(0.3)
## a - стандартное отклонение a
## b - стандартное отклонение b
## x - доля a
## (1-X) - доля b

df_dx = diff(f, x)
solution = solve(df_dx)
print(solution[0])
print(1-solution[0])

E=0.04 * solution[0] + 0.05 * (1-solution[0])
print(E*100)

var=a**2*solution[0]**2+b**2*(1-solution[0])**2+2*(0.3)*(1-solution[0])*solution[0]*a*b

print(var**0.5*100)


#4Имеется 37 монет, из которых 6 бракованные: вследствие заводского брака на этих монетах с обеих сторон отчеканен герб. Наугад выбранную монету, не разглядывая, бросают несколько раз. 1) Какова вероятность, что при 4 бросках она ляжет гербом вверх? 2) При 4 бросках монета легла гербом вверх. Какова вероятность того, что была выбрана монета с двумя гербами?

count_all = 37
unique = 6

P_A = unique/count_all + (count_all-unique)/count_all *(1/2)**4
## P_A = P(взяли брак) * P(выпадение 4-х гербов) +  P(взяли нормальную)* P (выпадение 4-х гербов)

print(P_A)

P_B_A = unique/count_all / P_A
## P_B_A  =(P(взяли брак)) /  P_A

print(P_B_A)




#6Имеется две корзины с белыми и черными шарами. В первой корзине всего 6 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 3 и p = 0,8. Во второй корзине имеется всего 11 шаров, при этом количество белых шаров распределено по биномиальному закону с параметрами n = 4 и p = 0,7. Из обеих корзин все шары перекладываются в третью корзину. 1) Какова вероятность P(A), что случайно вынутый из третьей корзины шар окажется белым (событие A)? 2) Найдите условную вероятность P(H|A), того, что случайно вынутый из третьей корзины шар первоначально находился в первой корзине (событие H), при условии, что он белый (событие A)?
from scipy.stats import *

box1 = binom(3, 0.8)
box2 = binom(4, 0.7)
A = 0
H = 0

for n1 in range(box1.args[0]+1):
    for n2 in range(box2.args[0]+1):
        A += box1.pmf(n1)*box2.pmf(n2)*((n1+n2)/(6+11))
        H += box1.pmf(n1)*box2.pmf(n2)*(n1/(6+11))
print(A)
print(H/A)

#8Банк выдал кредиты двум группам заемщиков: 180 заемщиков в первой группе и 70 – во второй. Известно, что заемщики из первой группы возвращают кредит с вероятностью 0,93, а заемщики из второй группы – с вероятностью 0,92. Пусть X – суммарное количество возвращенных кредитов для обеих групп. Предполагая независимость заемщиков, найдите: 1) стандартное отклонение X; 2) асимметрию X. Указание: используйте присущее третьему центральному моменту свойство аддитивности (основное свойство семиинвариантов).

p1 = 0.93
n1 = 180

p2 = 0.92
n2 = 70

var_X = n1*(p1 - p1**2)+ n2 * (p2 - p2**2)
std_X = var_X**0.5

mu3_x1=p1-3*p1**2 + 2*p1**3
mu3_x2=p2-3*p2**2 + 2*p2**3

AS_X = (n1*mu3_x1 + n2*mu3_x2) / std_X**3


print(std_X)
print(AS_X)


#9Независимые пуассоновские случайные величины X,Y,Z имеют следующие стандартные отклонения: σX=0,3; σY=0,9; σZ=1,8. Пусть S=X+Y+Z. Найдите: 1) вероятность P(S=7); 2) наиболее вероятное значение суммы S; 3) стандартное отклонение σS; 4) асимметрию As(S); 5) эксцесс Ex(S).
from scipy.stats import *
S = 7
x_std = 0.3
y_std = 0.9
z_std = 1.8

P_S = poisson.pmf(S, x_std**2 + y_std**2 + z_std**2)
print(P_S,3)

s_sum = x_std**2 + y_std**2 + z_std**2
print(s_sum)

s_std = (x_std**2 + y_std**2 + z_std**2)**0.5
print(s_std)


As_S = 1 / s_sum**0.5
print(As_S)

Ex_S = 1 / s_sum
print(Ex_S)


#11Корзина содержит 34 шаров, среди которых 14 – красных и 5 – синих. Из корзины, случайным образом, без возвращения извлекаются 12 шаров. Пусть X и Y обозначают количество красных и синих шаров среди извлеченных, соответственно. Найдите ковариацию Cov(X,Y).
N = 34
red = 14
blue = 5
n = 12


var_x = n * (red / N) * (1 - red / N) * (N - n) / (N-1)
var_y = n * (blue / N) * (1 - blue / N) * (N - n) / (N-1)

var_x_y = n * ((blue + red) / N) * (1 - (blue + red) / N) * (N - n) / (N-1)
cov_xy = (var_x_y - var_x- var_y)/2

cov_xy


#12Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 4 и 5. Пусть X — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(4)=0,11 и P(5)=0,22. Требуется найти: 1) E(X); 2) дисперсию X, если известно, что из 4 и 5 сначала выпала цифра 5. Указание: разберите пример на применение формулы полного математичекого ожидания (лекция 14, слайд 13 из курса ТВ-2017).
P_1 = 0.11
P_2 = 0.22

P_1_or_2 = P_1 + P_2
P_H1 = P_1 / P_1_or_2
P_H2 = P_2 / P_1_or_2


E_Y = 1/ P_1_or_2

E_Z = P_1/P_2/P_1_or_2 + P_2/P_1/P_1_or_2

E_X = E_Y + E_Z
print(E_X)


var_y = (1 - P_1_or_2) / P_1_or_2**2
## на противоположную
var_z = (1 - P_1) / P_1**2
var_x = var_z + var_y
print(var_x)


#13Несимметричная игральная кость подбрасывается до тех пор, пока не выпадут цифры 2, 3 и 4. Пусть X — число сделанных при этом бросков. Даны вероятности появления цифр в одном броске: P(2)=0,17, P(3)=0,11 и P(4)=0,13. Требуется найти: 1) E(X); 2) дисперсию X, если известно, что из 2, 3 и 4 сначала выпала цифра 2, затем — 3.
a = 0.17
b = 0.11
c = 0.13


E = 1/a + 1/b + 1/c - (1/(a+b) + 1/(a+c) + 1/(b+c)) + 1/(a+b+c)

var = (1-(a+b+c))/((a+b+c)**2) + (1-(b+c))/((b+c)**2) + (1-c)/(c**2)

print(E)
print(var)


#14В прямоугольной области, заданной ограничениями |x|⩽20 и |y|⩽8, случайным образом выбираются две точки: (x1,y1) и (x2,y2). Пусть A и B – события, состоящие в том, что: A – расстояние между выбранными точками меньше 11; B – модуль разности |x1−x2| меньше 14. Найдите приближенно, методом Монте-Карло: 1) вероятность P(A); 2) условную вероятность P(A|B). Указание: получите в заданной прямоугольной области 100000 пар точек и, используя все эти точки, найдите ответы, округляя их до одного знака после запятой.
import random

x = 20
y = 8

N = 100000

count_A = 0
count_B = 0
count_A_and_B = 0

for _ in range(N):
    x1 = random.uniform(-x, x)
    y1 = random.uniform(-y, y)

    x2 = random.uniform(-x, x)
    y2 = random.uniform(-y, y)

    distance = ((x1 - x2)**2 + (y1 - y2)**2)**0.5

    if distance < #11:
        count_A += 1

    if abs(x1 - x2) < #14:
        count_B += 1

    if distance < #11 and abs(x1 - x2) < #14:
        count_A_and_B += 1

P_A = count_A / N
P_A_given_B = count_A_and_B/count_B


print(P_A)
print(P_A_given_B)

#17В кубе объема 1 случайным образом выбираются точки A, B и C. Пусть R, S и T – события, состоящие в том, что: R – наименьший угол в треугольнике ABC меньше 26,7°; S – наибольший угол в треугольнике ABC меньше 81,9°; T – треугольник ABC остроугольный. Найдите приближенно, методом Монте-Карло: 1) условную вероятность P(R|T); 2) условную вероятность P(S|T). Указание: получите 100000 остроугольных треугольников ABC и, используя все эти треугольники, найдите ответы, округляя их до одного знака после запятой.
import random
import numpy as np
import math

N = 100000


R = 0
S = 0
T = 0

V = #1

for j in range(N):
    x1 = random.uniform(0, V**(1/3))
    y1 = random.uniform(0, V**(1/3))
    z1 = random.uniform(0, V**(1/3))
    x2 = random.uniform(0, V**(1/3))
    y2 = random.uniform(0, V**(1/3))
    z2 = random.uniform(0, V**(1/3))
    x3 = random.uniform(0, V**(1/3))
    y3 = random.uniform(0, V**(1/3))
    z3 = random.uniform(0, V**(1/3))

    a = ((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)**0.5
    b = ((x3 - x2)**2 + (y3 - y2)**2 + (z3 - z2)**2)**0.5
    c = ((x1 - x3)**2 + (y1 - y3)**2 + (z1 - z3)**2)**0.5


    cos_A = (b**2 + c**2 - a**2) / (2 * b * c)
    A = math.acos(cos_A) * 180 / np.pi

    cos_B = (a**2 + c**2 - b**2) / (2 * a * c)
    B = math.acos(cos_B) * 180 / np.pi

    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)
    C = math.acos(cos_C) * 180 / np.pi

    if max(A, B, C) < 90:
        T += 1
        if min(A, B, C) < #26.7:
            R += 1
        if max(A, B, C) < #81.9:
            #S += 1
print(R/T)
print(S/T)

#19Случайная величина
from scipy import *
from scipy.stats import *
a = 4
b = 8
q =0.8
def f(x):
    return (1 + 6 * x**0.5 + 4 * x**0.7 + 5 * x**0.9)**1.3

def f2(x):
    return  f(x) * (1/ (b-a))

E = integrate.quad(f2,a,b)[0]
print(E)
def f3(x):
    return (f(x))**2 * (1/ (b-a))
E_y_2 = integrate.quad(f3,a,b)[0]

std  = (E_y_2 - E**2)**0.5
print(std)

def f3(x):
    return f(x)**3 * (1/ (b-a))

E_y_3 = integrate.quad(f3,a,b)[0]
mu3 = E_y_3 - 3*E_y_2*E + 2 * E**3
print(mu3 / std**3)

X = uniform(loc = a, scale = (b - a))
qv = f(X.ppf(q))
print(qv)


#22Случайный вектор имеет плотность распределения
import sympy as sp
from fractions import Fraction
x = sp.Symbol('x')
y = sp.Symbol('y')

q_xy = 60*x**2 +96*x*y - 16*x + 60*y**2 + 10*y + 85/12

dq_dx = sp.diff(q_xy, x)
dq_dy = sp.diff(q_xy, y)

solution = sp.solve((dq_dx ,dq_dy), (x, y))

print('E(x) = ',solution[x])
print('E(y) = ',solution[y])

c = np.array([[60, 48], [48, 60]])
## c = [[a,b],[c,d]]
## c_inverse = [[d,-c],[-b,a]]
## det = d*a - c*b
c_inverse = np.array([[60, -48], [-48, 60]]) * (1/(60**2 - 48**2))
print(c_inverse)
var_x = c_inverse[0][0]
print('var_x = ', Fraction(var_x).limit_denominator())

var_y = c_inverse[1][1]
print('var_y = ', Fraction(var_y).limit_denominator())

cov_xy = c_inverse[0][1]
print('cov_xy = ', Fraction(cov_xy).limit_denominator())

##po = cov_xy / (var_x*var_x)**0.5
print('po = ', Fraction(po).limit_denominator())"""
